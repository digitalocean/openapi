# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.8.3, generator: @autorest/python@5.16.0)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    import __init__ as _models


class Account(msrest.serialization.Model):
    """Account.

    All required parameters must be populated in order to send to Azure.

    :ivar droplet_limit: Required. The total number of Droplets current user or team may have
     active at one time.
    :vartype droplet_limit: int
    :ivar floating_ip_limit: Required. The total number of Floating IPs the current user or team
     may have.
    :vartype floating_ip_limit: int
    :ivar email: Required. The email address used by the current user to register for DigitalOcean.
    :vartype email: str
    :ivar uuid: Required. The unique universal identifier for the current user.
    :vartype uuid: str
    :ivar email_verified: Required. If true, the user has verified their account via email. False
     otherwise.
    :vartype email_verified: bool
    :ivar status: Required. This value is one of "active", "warning" or "locked". Known values are:
     "active", "warning", "locked". Default value: "active".
    :vartype status: str or ~digital_ocean_api.models.AccountStatus
    :ivar status_message: Required. A human-readable message giving more details about the status
     of the account.
    :vartype status_message: str
    """

    _validation = {
        'droplet_limit': {'required': True},
        'floating_ip_limit': {'required': True},
        'email': {'required': True},
        'uuid': {'required': True},
        'email_verified': {'required': True},
        'status': {'required': True},
        'status_message': {'required': True},
    }

    _attribute_map = {
        'droplet_limit': {'key': 'droplet_limit', 'type': 'int'},
        'floating_ip_limit': {'key': 'floating_ip_limit', 'type': 'int'},
        'email': {'key': 'email', 'type': 'str'},
        'uuid': {'key': 'uuid', 'type': 'str'},
        'email_verified': {'key': 'email_verified', 'type': 'bool'},
        'status': {'key': 'status', 'type': 'str'},
        'status_message': {'key': 'status_message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        droplet_limit: int,
        floating_ip_limit: int,
        email: str,
        uuid: str,
        email_verified: bool,
        status: Union[str, "_models.AccountStatus"] = "active",
        status_message: str,
        **kwargs
    ):
        """
        :keyword droplet_limit: Required. The total number of Droplets current user or team may have
         active at one time.
        :paramtype droplet_limit: int
        :keyword floating_ip_limit: Required. The total number of Floating IPs the current user or team
         may have.
        :paramtype floating_ip_limit: int
        :keyword email: Required. The email address used by the current user to register for
         DigitalOcean.
        :paramtype email: str
        :keyword uuid: Required. The unique universal identifier for the current user.
        :paramtype uuid: str
        :keyword email_verified: Required. If true, the user has verified their account via email.
         False otherwise.
        :paramtype email_verified: bool
        :keyword status: Required. This value is one of "active", "warning" or "locked". Known values
         are: "active", "warning", "locked". Default value: "active".
        :paramtype status: str or ~digital_ocean_api.models.AccountStatus
        :keyword status_message: Required. A human-readable message giving more details about the
         status of the account.
        :paramtype status_message: str
        """
        super(Account, self).__init__(**kwargs)
        self.droplet_limit = droplet_limit
        self.floating_ip_limit = floating_ip_limit
        self.email = email
        self.uuid = uuid
        self.email_verified = email_verified
        self.status = status
        self.status_message = status_message


class Action(msrest.serialization.Model):
    """Action.

    :ivar id: A unique numeric ID that can be used to identify and reference an action.
    :vartype id: int
    :ivar status: The current status of the action. This can be "in-progress", "completed", or
     "errored". Known values are: "in-progress", "completed", "errored". Default value:
     "in-progress".
    :vartype status: str or ~digital_ocean_api.models.ActionStatus
    :ivar type: This is the type of action that the object represents. For example, this could be
     "transfer" to represent the state of an image transfer action.
    :vartype type: str
    :ivar started_at: A time value given in ISO8601 combined date and time format that represents
     when the action was initiated.
    :vartype started_at: ~datetime.datetime
    :ivar completed_at: A time value given in ISO8601 combined date and time format that represents
     when the action was completed.
    :vartype completed_at: ~datetime.datetime
    :ivar resource_id: A unique identifier for the resource that the action is associated with.
    :vartype resource_id: int
    :ivar resource_type: The type of resource that the action is associated with.
    :vartype resource_type: str
    :ivar region:
    :vartype region: ~digital_ocean_api.models.Region
    :ivar region_slug: Any object.
    :vartype region_slug: any
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'status': {'key': 'status', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'started_at': {'key': 'started_at', 'type': 'iso-8601'},
        'completed_at': {'key': 'completed_at', 'type': 'iso-8601'},
        'resource_id': {'key': 'resource_id', 'type': 'int'},
        'resource_type': {'key': 'resource_type', 'type': 'str'},
        'region': {'key': 'region', 'type': 'Region'},
        'region_slug': {'key': 'region_slug', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        status: Optional[Union[str, "_models.ActionStatus"]] = "in-progress",
        type: Optional[str] = None,
        started_at: Optional[datetime.datetime] = None,
        completed_at: Optional[datetime.datetime] = None,
        resource_id: Optional[int] = None,
        resource_type: Optional[str] = None,
        region: Optional["_models.Region"] = None,
        region_slug: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword id: A unique numeric ID that can be used to identify and reference an action.
        :paramtype id: int
        :keyword status: The current status of the action. This can be "in-progress", "completed", or
         "errored". Known values are: "in-progress", "completed", "errored". Default value:
         "in-progress".
        :paramtype status: str or ~digital_ocean_api.models.ActionStatus
        :keyword type: This is the type of action that the object represents. For example, this could
         be "transfer" to represent the state of an image transfer action.
        :paramtype type: str
        :keyword started_at: A time value given in ISO8601 combined date and time format that
         represents when the action was initiated.
        :paramtype started_at: ~datetime.datetime
        :keyword completed_at: A time value given in ISO8601 combined date and time format that
         represents when the action was completed.
        :paramtype completed_at: ~datetime.datetime
        :keyword resource_id: A unique identifier for the resource that the action is associated with.
        :paramtype resource_id: int
        :keyword resource_type: The type of resource that the action is associated with.
        :paramtype resource_type: str
        :keyword region:
        :paramtype region: ~digital_ocean_api.models.Region
        :keyword region_slug: Any object.
        :paramtype region_slug: any
        """
        super(Action, self).__init__(**kwargs)
        self.id = id
        self.status = status
        self.type = type
        self.started_at = started_at
        self.completed_at = completed_at
        self.resource_id = resource_id
        self.resource_type = resource_type
        self.region = region
        self.region_slug = region_slug


class ActionLink(msrest.serialization.Model):
    """The linked actions can be used to check the status of a Droplet's create event.

    :ivar id: A unique numeric ID that can be used to identify and reference an action.
    :vartype id: int
    :ivar rel: A string specifying the type of the related action.
    :vartype rel: str
    :ivar href: A URL that can be used to access the action.
    :vartype href: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'rel': {'key': 'rel', 'type': 'str'},
        'href': {'key': 'href', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        rel: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: A unique numeric ID that can be used to identify and reference an action.
        :paramtype id: int
        :keyword rel: A string specifying the type of the related action.
        :paramtype rel: str
        :keyword href: A URL that can be used to access the action.
        :paramtype href: str
        """
        super(ActionLink, self).__init__(**kwargs)
        self.id = id
        self.rel = rel
        self.href = href


class AlertPolicy(msrest.serialization.Model):
    """AlertPolicy.

    All required parameters must be populated in order to send to Azure.

    :ivar alerts: Required.
    :vartype alerts: ~digital_ocean_api.models.Alerts
    :ivar compare: Required. Known values are: "GreaterThan", "LessThan".
    :vartype compare: str or ~digital_ocean_api.models.AlertPolicyCompare
    :ivar description: Required.
    :vartype description: str
    :ivar enabled: Required.
    :vartype enabled: bool
    :ivar entities: Required.
    :vartype entities: list[str]
    :ivar tags: Required. A set of tags.
    :vartype tags: list[str]
    :ivar type: Required. Known values are: "v1/insights/droplet/load_1",
     "v1/insights/droplet/load_5", "v1/insights/droplet/load_15",
     "v1/insights/droplet/memory_utilization_percent",
     "v1/insights/droplet/disk_utilization_percent", "v1/insights/droplet/cpu",
     "v1/insights/droplet/disk_read", "v1/insights/droplet/disk_write",
     "v1/insights/droplet/public_outbound_bandwidth",
     "v1/insights/droplet/public_inbound_bandwidth",
     "v1/insights/droplet/private_outbound_bandwidth",
     "v1/insights/droplet/private_inbound_bandwidth",
     "v1/insights/lbaas/avg_cpu_utilization_percent",
     "v1/insights/lbaas/connection_utilization_percent", "v1/insights/lbaas/droplet_health".
    :vartype type: str or ~digital_ocean_api.models.AlertPolicyType
    :ivar uuid: Required.
    :vartype uuid: str
    :ivar value: Required.
    :vartype value: float
    :ivar window: Required. Known values are: "5m", "10m", "30m", "1h".
    :vartype window: str or ~digital_ocean_api.models.AlertPolicyWindow
    """

    _validation = {
        'alerts': {'required': True},
        'compare': {'required': True},
        'description': {'required': True},
        'enabled': {'required': True},
        'entities': {'required': True},
        'tags': {'required': True},
        'type': {'required': True},
        'uuid': {'required': True},
        'value': {'required': True},
        'window': {'required': True},
    }

    _attribute_map = {
        'alerts': {'key': 'alerts', 'type': 'Alerts'},
        'compare': {'key': 'compare', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'entities': {'key': 'entities', 'type': '[str]'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'type': {'key': 'type', 'type': 'str'},
        'uuid': {'key': 'uuid', 'type': 'str'},
        'value': {'key': 'value', 'type': 'float'},
        'window': {'key': 'window', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        alerts: "_models.Alerts",
        compare: Union[str, "_models.AlertPolicyCompare"],
        description: str,
        enabled: bool,
        entities: List[str],
        tags: List[str],
        type: Union[str, "_models.AlertPolicyType"],
        uuid: str,
        value: float,
        window: Union[str, "_models.AlertPolicyWindow"],
        **kwargs
    ):
        """
        :keyword alerts: Required.
        :paramtype alerts: ~digital_ocean_api.models.Alerts
        :keyword compare: Required. Known values are: "GreaterThan", "LessThan".
        :paramtype compare: str or ~digital_ocean_api.models.AlertPolicyCompare
        :keyword description: Required.
        :paramtype description: str
        :keyword enabled: Required.
        :paramtype enabled: bool
        :keyword entities: Required.
        :paramtype entities: list[str]
        :keyword tags: Required. A set of tags.
        :paramtype tags: list[str]
        :keyword type: Required. Known values are: "v1/insights/droplet/load_1",
         "v1/insights/droplet/load_5", "v1/insights/droplet/load_15",
         "v1/insights/droplet/memory_utilization_percent",
         "v1/insights/droplet/disk_utilization_percent", "v1/insights/droplet/cpu",
         "v1/insights/droplet/disk_read", "v1/insights/droplet/disk_write",
         "v1/insights/droplet/public_outbound_bandwidth",
         "v1/insights/droplet/public_inbound_bandwidth",
         "v1/insights/droplet/private_outbound_bandwidth",
         "v1/insights/droplet/private_inbound_bandwidth",
         "v1/insights/lbaas/avg_cpu_utilization_percent",
         "v1/insights/lbaas/connection_utilization_percent", "v1/insights/lbaas/droplet_health".
        :paramtype type: str or ~digital_ocean_api.models.AlertPolicyType
        :keyword uuid: Required.
        :paramtype uuid: str
        :keyword value: Required.
        :paramtype value: float
        :keyword window: Required. Known values are: "5m", "10m", "30m", "1h".
        :paramtype window: str or ~digital_ocean_api.models.AlertPolicyWindow
        """
        super(AlertPolicy, self).__init__(**kwargs)
        self.alerts = alerts
        self.compare = compare
        self.description = description
        self.enabled = enabled
        self.entities = entities
        self.tags = tags
        self.type = type
        self.uuid = uuid
        self.value = value
        self.window = window


class AlertPolicyRequest(msrest.serialization.Model):
    """AlertPolicyRequest.

    All required parameters must be populated in order to send to Azure.

    :ivar alerts: Required.
    :vartype alerts: ~digital_ocean_api.models.Alerts
    :ivar compare: Required. Known values are: "GreaterThan", "LessThan".
    :vartype compare: str or ~digital_ocean_api.models.AlertPolicyRequestCompare
    :ivar description: Required.
    :vartype description: str
    :ivar enabled: Required.
    :vartype enabled: bool
    :ivar entities: Required.
    :vartype entities: list[str]
    :ivar tags: Required. A set of tags.
    :vartype tags: list[str]
    :ivar type: Required. Known values are: "v1/insights/droplet/load_1",
     "v1/insights/droplet/load_5", "v1/insights/droplet/load_15",
     "v1/insights/droplet/memory_utilization_percent",
     "v1/insights/droplet/disk_utilization_percent", "v1/insights/droplet/cpu",
     "v1/insights/droplet/disk_read", "v1/insights/droplet/disk_write",
     "v1/insights/droplet/public_outbound_bandwidth",
     "v1/insights/droplet/public_inbound_bandwidth",
     "v1/insights/droplet/private_outbound_bandwidth",
     "v1/insights/droplet/private_inbound_bandwidth",
     "v1/insights/lbaas/avg_cpu_utilization_percent",
     "v1/insights/lbaas/connection_utilization_percent", "v1/insights/lbaas/droplet_health".
    :vartype type: str or ~digital_ocean_api.models.AlertPolicyRequestType
    :ivar value: Required.
    :vartype value: float
    :ivar window: Required. Known values are: "5m", "10m", "30m", "1h".
    :vartype window: str or ~digital_ocean_api.models.AlertPolicyRequestWindow
    """

    _validation = {
        'alerts': {'required': True},
        'compare': {'required': True},
        'description': {'required': True},
        'enabled': {'required': True},
        'entities': {'required': True},
        'tags': {'required': True},
        'type': {'required': True},
        'value': {'required': True},
        'window': {'required': True},
    }

    _attribute_map = {
        'alerts': {'key': 'alerts', 'type': 'Alerts'},
        'compare': {'key': 'compare', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'entities': {'key': 'entities', 'type': '[str]'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'type': {'key': 'type', 'type': 'str'},
        'value': {'key': 'value', 'type': 'float'},
        'window': {'key': 'window', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        alerts: "_models.Alerts",
        compare: Union[str, "_models.AlertPolicyRequestCompare"],
        description: str,
        enabled: bool,
        entities: List[str],
        tags: List[str],
        type: Union[str, "_models.AlertPolicyRequestType"],
        value: float,
        window: Union[str, "_models.AlertPolicyRequestWindow"],
        **kwargs
    ):
        """
        :keyword alerts: Required.
        :paramtype alerts: ~digital_ocean_api.models.Alerts
        :keyword compare: Required. Known values are: "GreaterThan", "LessThan".
        :paramtype compare: str or ~digital_ocean_api.models.AlertPolicyRequestCompare
        :keyword description: Required.
        :paramtype description: str
        :keyword enabled: Required.
        :paramtype enabled: bool
        :keyword entities: Required.
        :paramtype entities: list[str]
        :keyword tags: Required. A set of tags.
        :paramtype tags: list[str]
        :keyword type: Required. Known values are: "v1/insights/droplet/load_1",
         "v1/insights/droplet/load_5", "v1/insights/droplet/load_15",
         "v1/insights/droplet/memory_utilization_percent",
         "v1/insights/droplet/disk_utilization_percent", "v1/insights/droplet/cpu",
         "v1/insights/droplet/disk_read", "v1/insights/droplet/disk_write",
         "v1/insights/droplet/public_outbound_bandwidth",
         "v1/insights/droplet/public_inbound_bandwidth",
         "v1/insights/droplet/private_outbound_bandwidth",
         "v1/insights/droplet/private_inbound_bandwidth",
         "v1/insights/lbaas/avg_cpu_utilization_percent",
         "v1/insights/lbaas/connection_utilization_percent", "v1/insights/lbaas/droplet_health".
        :paramtype type: str or ~digital_ocean_api.models.AlertPolicyRequestType
        :keyword value: Required.
        :paramtype value: float
        :keyword window: Required. Known values are: "5m", "10m", "30m", "1h".
        :paramtype window: str or ~digital_ocean_api.models.AlertPolicyRequestWindow
        """
        super(AlertPolicyRequest, self).__init__(**kwargs)
        self.alerts = alerts
        self.compare = compare
        self.description = description
        self.enabled = enabled
        self.entities = entities
        self.tags = tags
        self.type = type
        self.value = value
        self.window = window


class Alerts(msrest.serialization.Model):
    """Alerts.

    All required parameters must be populated in order to send to Azure.

    :ivar email: Required. An email to notify on an alert trigger.
    :vartype email: list[str]
    :ivar slack: Required. Slack integration details.
    :vartype slack: list[~digital_ocean_api.models.SlackDetails]
    """

    _validation = {
        'email': {'required': True},
        'slack': {'required': True},
    }

    _attribute_map = {
        'email': {'key': 'email', 'type': '[str]'},
        'slack': {'key': 'slack', 'type': '[SlackDetails]'},
    }

    def __init__(
        self,
        *,
        email: List[str],
        slack: List["_models.SlackDetails"],
        **kwargs
    ):
        """
        :keyword email: Required. An email to notify on an alert trigger.
        :paramtype email: list[str]
        :keyword slack: Required. Slack integration details.
        :paramtype slack: list[~digital_ocean_api.models.SlackDetails]
        """
        super(Alerts, self).__init__(**kwargs)
        self.email = email
        self.slack = slack


class App(msrest.serialization.Model):
    """An application's configuration and status.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar active_deployment: An app deployment.
    :vartype active_deployment: ~digital_ocean_api.models.AppsDeployment
    :ivar created_at: The creation time of the app.
    :vartype created_at: ~datetime.datetime
    :ivar default_ingress: The default hostname on which the app is accessible.
    :vartype default_ingress: str
    :ivar domains: Contains all domains for the app.
    :vartype domains: list[~digital_ocean_api.models.AppsDomain]
    :ivar id: The ID of the application.
    :vartype id: str
    :ivar in_progress_deployment: An app deployment.
    :vartype in_progress_deployment: ~digital_ocean_api.models.AppsDeployment
    :ivar last_deployment_created_at: The creation time of the last deployment.
    :vartype last_deployment_created_at: ~datetime.datetime
    :ivar live_domain: The live domain of the app.
    :vartype live_domain: str
    :ivar live_url: The live URL of the app.
    :vartype live_url: str
    :ivar live_url_base: The live URL base of the app, the URL excluding the path.
    :vartype live_url_base: str
    :ivar owner_uuid: The ID of the account to which the application belongs.
    :vartype owner_uuid: str
    :ivar region: Geographical information about an app origin.
    :vartype region: ~digital_ocean_api.models.AppsRegion
    :ivar spec: Required. The desired configuration of an application.
    :vartype spec: ~digital_ocean_api.models.AppSpec
    :ivar tier_slug: The current pricing tier slug of the app.
    :vartype tier_slug: str
    :ivar updated_at: Time of the app's last configuration update.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        'created_at': {'readonly': True},
        'default_ingress': {'readonly': True},
        'domains': {'readonly': True},
        'id': {'readonly': True},
        'last_deployment_created_at': {'readonly': True},
        'live_domain': {'readonly': True},
        'live_url': {'readonly': True},
        'live_url_base': {'readonly': True},
        'owner_uuid': {'readonly': True},
        'spec': {'required': True},
        'tier_slug': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'active_deployment': {'key': 'active_deployment', 'type': 'AppsDeployment'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'default_ingress': {'key': 'default_ingress', 'type': 'str'},
        'domains': {'key': 'domains', 'type': '[AppsDomain]'},
        'id': {'key': 'id', 'type': 'str'},
        'in_progress_deployment': {'key': 'in_progress_deployment', 'type': 'AppsDeployment'},
        'last_deployment_created_at': {'key': 'last_deployment_created_at', 'type': 'iso-8601'},
        'live_domain': {'key': 'live_domain', 'type': 'str'},
        'live_url': {'key': 'live_url', 'type': 'str'},
        'live_url_base': {'key': 'live_url_base', 'type': 'str'},
        'owner_uuid': {'key': 'owner_uuid', 'type': 'str'},
        'region': {'key': 'region', 'type': 'AppsRegion'},
        'spec': {'key': 'spec', 'type': 'AppSpec'},
        'tier_slug': {'key': 'tier_slug', 'type': 'str'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        spec: "_models.AppSpec",
        active_deployment: Optional["_models.AppsDeployment"] = None,
        in_progress_deployment: Optional["_models.AppsDeployment"] = None,
        region: Optional["_models.AppsRegion"] = None,
        **kwargs
    ):
        """
        :keyword active_deployment: An app deployment.
        :paramtype active_deployment: ~digital_ocean_api.models.AppsDeployment
        :keyword in_progress_deployment: An app deployment.
        :paramtype in_progress_deployment: ~digital_ocean_api.models.AppsDeployment
        :keyword region: Geographical information about an app origin.
        :paramtype region: ~digital_ocean_api.models.AppsRegion
        :keyword spec: Required. The desired configuration of an application.
        :paramtype spec: ~digital_ocean_api.models.AppSpec
        """
        super(App, self).__init__(**kwargs)
        self.active_deployment = active_deployment
        self.created_at = None
        self.default_ingress = None
        self.domains = None
        self.id = None
        self.in_progress_deployment = in_progress_deployment
        self.last_deployment_created_at = None
        self.live_domain = None
        self.live_url = None
        self.live_url_base = None
        self.owner_uuid = None
        self.region = region
        self.spec = spec
        self.tier_slug = None
        self.updated_at = None


class AppAlert(msrest.serialization.Model):
    """AppAlert.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The ID of the alert.
    :vartype id: str
    :ivar component_name: Name of component the alert belongs to.
    :vartype component_name: str
    :ivar spec:
    :vartype spec: ~digital_ocean_api.models.AppAlertSpec
    :ivar emails: Emails for alerts to go to.
    :vartype emails: list[str]
    :ivar slack_webhooks: Slack Webhooks to send alerts to.
    :vartype slack_webhooks: list[~digital_ocean_api.models.AppAlertSlackWebhook]
    :ivar phase: Known values are: "UNKNOWN", "PENDING", "CONFIGURING", "ACTIVE", "ERROR". Default
     value: "UNKNOWN".
    :vartype phase: str or ~digital_ocean_api.models.AppAlertPhase
    :ivar progress:
    :vartype progress: ~digital_ocean_api.models.AppAlertProgress
    """

    _validation = {
        'id': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'component_name': {'key': 'component_name', 'type': 'str'},
        'spec': {'key': 'spec', 'type': 'AppAlertSpec'},
        'emails': {'key': 'emails', 'type': '[str]'},
        'slack_webhooks': {'key': 'slack_webhooks', 'type': '[AppAlertSlackWebhook]'},
        'phase': {'key': 'phase', 'type': 'str'},
        'progress': {'key': 'progress', 'type': 'AppAlertProgress'},
    }

    def __init__(
        self,
        *,
        component_name: Optional[str] = None,
        spec: Optional["_models.AppAlertSpec"] = None,
        emails: Optional[List[str]] = None,
        slack_webhooks: Optional[List["_models.AppAlertSlackWebhook"]] = None,
        phase: Optional[Union[str, "_models.AppAlertPhase"]] = "UNKNOWN",
        progress: Optional["_models.AppAlertProgress"] = None,
        **kwargs
    ):
        """
        :keyword component_name: Name of component the alert belongs to.
        :paramtype component_name: str
        :keyword spec:
        :paramtype spec: ~digital_ocean_api.models.AppAlertSpec
        :keyword emails: Emails for alerts to go to.
        :paramtype emails: list[str]
        :keyword slack_webhooks: Slack Webhooks to send alerts to.
        :paramtype slack_webhooks: list[~digital_ocean_api.models.AppAlertSlackWebhook]
        :keyword phase: Known values are: "UNKNOWN", "PENDING", "CONFIGURING", "ACTIVE", "ERROR".
         Default value: "UNKNOWN".
        :paramtype phase: str or ~digital_ocean_api.models.AppAlertPhase
        :keyword progress:
        :paramtype progress: ~digital_ocean_api.models.AppAlertProgress
        """
        super(AppAlert, self).__init__(**kwargs)
        self.id = None
        self.component_name = component_name
        self.spec = spec
        self.emails = emails
        self.slack_webhooks = slack_webhooks
        self.phase = phase
        self.progress = progress


class AppAlertProgress(msrest.serialization.Model):
    """AppAlertProgress.

    :ivar steps: Steps of an alert's progress.
    :vartype steps: list[~digital_ocean_api.models.AppAlertProgressStep]
    """

    _attribute_map = {
        'steps': {'key': 'steps', 'type': '[AppAlertProgressStep]'},
    }

    def __init__(
        self,
        *,
        steps: Optional[List["_models.AppAlertProgressStep"]] = None,
        **kwargs
    ):
        """
        :keyword steps: Steps of an alert's progress.
        :paramtype steps: list[~digital_ocean_api.models.AppAlertProgressStep]
        """
        super(AppAlertProgress, self).__init__(**kwargs)
        self.steps = steps


class AppAlertProgressStep(msrest.serialization.Model):
    """AppAlertProgressStep.

    :ivar name: The name of this step.
    :vartype name: str
    :ivar status: Known values are: "UNKNOWN", "PENDING", "RUNNING", "ERROR", "SUCCESS". Default
     value: "UNKNOWN".
    :vartype status: str or ~digital_ocean_api.models.AppAlertProgressStepStatus
    :ivar started_at: The start time of this step.
    :vartype started_at: ~datetime.datetime
    :ivar ended_at: The start time of this step.
    :vartype ended_at: ~datetime.datetime
    :ivar reason:
    :vartype reason: ~digital_ocean_api.models.AppAlertProgressStepReason
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'started_at': {'key': 'started_at', 'type': 'iso-8601'},
        'ended_at': {'key': 'ended_at', 'type': 'iso-8601'},
        'reason': {'key': 'reason', 'type': 'AppAlertProgressStepReason'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        status: Optional[Union[str, "_models.AppAlertProgressStepStatus"]] = "UNKNOWN",
        started_at: Optional[datetime.datetime] = None,
        ended_at: Optional[datetime.datetime] = None,
        reason: Optional["_models.AppAlertProgressStepReason"] = None,
        **kwargs
    ):
        """
        :keyword name: The name of this step.
        :paramtype name: str
        :keyword status: Known values are: "UNKNOWN", "PENDING", "RUNNING", "ERROR", "SUCCESS". Default
         value: "UNKNOWN".
        :paramtype status: str or ~digital_ocean_api.models.AppAlertProgressStepStatus
        :keyword started_at: The start time of this step.
        :paramtype started_at: ~datetime.datetime
        :keyword ended_at: The start time of this step.
        :paramtype ended_at: ~datetime.datetime
        :keyword reason:
        :paramtype reason: ~digital_ocean_api.models.AppAlertProgressStepReason
        """
        super(AppAlertProgressStep, self).__init__(**kwargs)
        self.name = name
        self.status = status
        self.started_at = started_at
        self.ended_at = ended_at
        self.reason = reason


class AppAlertProgressStepReason(msrest.serialization.Model):
    """AppAlertProgressStepReason.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword code: The error code.
        :paramtype code: str
        :keyword message: The error message.
        :paramtype message: str
        """
        super(AppAlertProgressStepReason, self).__init__(**kwargs)
        self.code = code
        self.message = message


class AppAlertSlackWebhook(msrest.serialization.Model):
    """AppAlertSlackWebhook.

    :ivar url: URL of the Slack webhook.
    :vartype url: str
    :ivar channel: Name of the Slack Webhook Channel.
    :vartype channel: str
    """

    _attribute_map = {
        'url': {'key': 'url', 'type': 'str'},
        'channel': {'key': 'channel', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        url: Optional[str] = None,
        channel: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword url: URL of the Slack webhook.
        :paramtype url: str
        :keyword channel: Name of the Slack Webhook Channel.
        :paramtype channel: str
        """
        super(AppAlertSlackWebhook, self).__init__(**kwargs)
        self.url = url
        self.channel = channel


class AppAlertSpec(msrest.serialization.Model):
    """AppAlertSpec.

    :ivar rule: Known values are: "UNSPECIFIED_RULE", "CPU_UTILIZATION", "MEM_UTILIZATION",
     "RESTART_COUNT", "DEPLOYMENT_FAILED", "DEPLOYMENT_LIVE", "DOMAIN_FAILED", "DOMAIN_LIVE".
     Default value: "UNSPECIFIED_RULE".
    :vartype rule: str or ~digital_ocean_api.models.AppAlertSpecRule
    :ivar disabled: Is the alert disabled?.
    :vartype disabled: bool
    :ivar operator: Known values are: "UNSPECIFIED_OPERATOR", "GREATER_THAN", "LESS_THAN". Default
     value: "UNSPECIFIED_OPERATOR".
    :vartype operator: str or ~digital_ocean_api.models.AppAlertSpecOperator
    :ivar value: Threshold value for alert.
    :vartype value: float
    :ivar window: Known values are: "UNSPECIFIED_WINDOW", "FIVE_MINUTES", "TEN_MINUTES",
     "THIRTY_MINUTES", "ONE_HOUR". Default value: "UNSPECIFIED_WINDOW".
    :vartype window: str or ~digital_ocean_api.models.AppAlertSpecWindow
    """

    _attribute_map = {
        'rule': {'key': 'rule', 'type': 'str'},
        'disabled': {'key': 'disabled', 'type': 'bool'},
        'operator': {'key': 'operator', 'type': 'str'},
        'value': {'key': 'value', 'type': 'float'},
        'window': {'key': 'window', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        rule: Optional[Union[str, "_models.AppAlertSpecRule"]] = "UNSPECIFIED_RULE",
        disabled: Optional[bool] = None,
        operator: Optional[Union[str, "_models.AppAlertSpecOperator"]] = "UNSPECIFIED_OPERATOR",
        value: Optional[float] = None,
        window: Optional[Union[str, "_models.AppAlertSpecWindow"]] = "UNSPECIFIED_WINDOW",
        **kwargs
    ):
        """
        :keyword rule: Known values are: "UNSPECIFIED_RULE", "CPU_UTILIZATION", "MEM_UTILIZATION",
         "RESTART_COUNT", "DEPLOYMENT_FAILED", "DEPLOYMENT_LIVE", "DOMAIN_FAILED", "DOMAIN_LIVE".
         Default value: "UNSPECIFIED_RULE".
        :paramtype rule: str or ~digital_ocean_api.models.AppAlertSpecRule
        :keyword disabled: Is the alert disabled?.
        :paramtype disabled: bool
        :keyword operator: Known values are: "UNSPECIFIED_OPERATOR", "GREATER_THAN", "LESS_THAN".
         Default value: "UNSPECIFIED_OPERATOR".
        :paramtype operator: str or ~digital_ocean_api.models.AppAlertSpecOperator
        :keyword value: Threshold value for alert.
        :paramtype value: float
        :keyword window: Known values are: "UNSPECIFIED_WINDOW", "FIVE_MINUTES", "TEN_MINUTES",
         "THIRTY_MINUTES", "ONE_HOUR". Default value: "UNSPECIFIED_WINDOW".
        :paramtype window: str or ~digital_ocean_api.models.AppAlertSpecWindow
        """
        super(AppAlertSpec, self).__init__(**kwargs)
        self.rule = rule
        self.disabled = disabled
        self.operator = operator
        self.value = value
        self.window = window


class AppComponentBase(msrest.serialization.Model):
    """AppComponentBase.

    :ivar name: The name. Must be unique across all components within the same app.
    :vartype name: str
    :ivar git:
    :vartype git: ~digital_ocean_api.models.AppsGitSourceSpec
    :ivar github:
    :vartype github: ~digital_ocean_api.models.AppsGithubSourceSpec
    :ivar gitlab:
    :vartype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
    :ivar image:
    :vartype image: ~digital_ocean_api.models.AppsImageSourceSpec
    :ivar dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it
     will be used to build this component. Otherwise, App Platform will attempt to build it using
     buildpacks.
    :vartype dockerfile_path: str
    :ivar build_command: An optional build command to run while building this component from
     source.
    :vartype build_command: str
    :ivar run_command: An optional run command to override the component's default.
    :vartype run_command: str
    :ivar source_dir: An optional path to the working directory to use for the build. For
     Dockerfile builds, this will be used as the build context. Must be relative to the root of the
     repo.
    :vartype source_dir: str
    :ivar envs: A list of environment variables made available to the component.
    :vartype envs: list[~digital_ocean_api.models.AppVariableDefinition]
    :ivar environment_slug: An environment slug describing the type of this app. For a full list,
     please refer to `the product documentation <https://www.digitalocean.com/docs/app-platform/>`_.
    :vartype environment_slug: str
    """

    _validation = {
        'name': {'max_length': 32, 'min_length': 2, 'pattern': r'^[a-z][a-z0-9-]{0,30}[a-z0-9]$'},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'git': {'key': 'git', 'type': 'AppsGitSourceSpec'},
        'github': {'key': 'github', 'type': 'AppsGithubSourceSpec'},
        'gitlab': {'key': 'gitlab', 'type': 'AppsGitlabSourceSpec'},
        'image': {'key': 'image', 'type': 'AppsImageSourceSpec'},
        'dockerfile_path': {'key': 'dockerfile_path', 'type': 'str'},
        'build_command': {'key': 'build_command', 'type': 'str'},
        'run_command': {'key': 'run_command', 'type': 'str'},
        'source_dir': {'key': 'source_dir', 'type': 'str'},
        'envs': {'key': 'envs', 'type': '[AppVariableDefinition]'},
        'environment_slug': {'key': 'environment_slug', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        git: Optional["_models.AppsGitSourceSpec"] = None,
        github: Optional["_models.AppsGithubSourceSpec"] = None,
        gitlab: Optional["_models.AppsGitlabSourceSpec"] = None,
        image: Optional["_models.AppsImageSourceSpec"] = None,
        dockerfile_path: Optional[str] = None,
        build_command: Optional[str] = None,
        run_command: Optional[str] = None,
        source_dir: Optional[str] = None,
        envs: Optional[List["_models.AppVariableDefinition"]] = None,
        environment_slug: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name. Must be unique across all components within the same app.
        :paramtype name: str
        :keyword git:
        :paramtype git: ~digital_ocean_api.models.AppsGitSourceSpec
        :keyword github:
        :paramtype github: ~digital_ocean_api.models.AppsGithubSourceSpec
        :keyword gitlab:
        :paramtype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
        :keyword image:
        :paramtype image: ~digital_ocean_api.models.AppsImageSourceSpec
        :keyword dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set,
         it will be used to build this component. Otherwise, App Platform will attempt to build it using
         buildpacks.
        :paramtype dockerfile_path: str
        :keyword build_command: An optional build command to run while building this component from
         source.
        :paramtype build_command: str
        :keyword run_command: An optional run command to override the component's default.
        :paramtype run_command: str
        :keyword source_dir: An optional path to the working directory to use for the build. For
         Dockerfile builds, this will be used as the build context. Must be relative to the root of the
         repo.
        :paramtype source_dir: str
        :keyword envs: A list of environment variables made available to the component.
        :paramtype envs: list[~digital_ocean_api.models.AppVariableDefinition]
        :keyword environment_slug: An environment slug describing the type of this app. For a full
         list, please refer to `the product documentation
         <https://www.digitalocean.com/docs/app-platform/>`_.
        :paramtype environment_slug: str
        """
        super(AppComponentBase, self).__init__(**kwargs)
        self.name = name
        self.git = git
        self.github = github
        self.gitlab = gitlab
        self.image = image
        self.dockerfile_path = dockerfile_path
        self.build_command = build_command
        self.run_command = run_command
        self.source_dir = source_dir
        self.envs = envs
        self.environment_slug = environment_slug


class AppComponentInstanceBase(msrest.serialization.Model):
    """AppComponentInstanceBase.

    :ivar instance_count: The amount of instances that this component should be scaled to. Default:
     1.
    :vartype instance_count: long
    :ivar instance_size_slug: The instance size to use for this component. Default: ``basic-xxs``.
     Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m", "professional-xs",
     "professional-s", "professional-m", "professional-1l", "professional-l", "professional-xl".
     Default value: "basic-xxs".
    :vartype instance_size_slug: str or
     ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
    """

    _validation = {
        'instance_count': {'minimum': 1},
    }

    _attribute_map = {
        'instance_count': {'key': 'instance_count', 'type': 'long'},
        'instance_size_slug': {'key': 'instance_size_slug', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        instance_count: Optional[int] = 1,
        instance_size_slug: Optional[Union[str, "_models.AppComponentInstanceBaseInstanceSizeSlug"]] = "basic-xxs",
        **kwargs
    ):
        """
        :keyword instance_count: The amount of instances that this component should be scaled to.
         Default: 1.
        :paramtype instance_count: long
        :keyword instance_size_slug: The instance size to use for this component. Default:
         ``basic-xxs``. Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m",
         "professional-xs", "professional-s", "professional-m", "professional-1l", "professional-l",
         "professional-xl". Default value: "basic-xxs".
        :paramtype instance_size_slug: str or
         ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
        """
        super(AppComponentInstanceBase, self).__init__(**kwargs)
        self.instance_count = instance_count
        self.instance_size_slug = instance_size_slug


class AppDatabaseSpec(msrest.serialization.Model):
    """AppDatabaseSpec.

    All required parameters must be populated in order to send to Azure.

    :ivar cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for
     production databases. For dev databases, if cluster_name is not set, a new cluster will be
     provisioned.
    :vartype cluster_name: str
    :ivar db_name: The name of the MySQL or PostgreSQL database to configure.
    :vartype db_name: str
    :ivar db_user: The name of the MySQL or PostgreSQL user to configure.
    :vartype db_user: str
    :ivar engine: * MYSQL: MySQL
     * PG: PostgreSQL
     * REDIS: Redis. Known values are: "UNSET", "MYSQL", "PG", "REDIS". Default value: "UNSET".
    :vartype engine: str or ~digital_ocean_api.models.AppDatabaseSpecEngine
    :ivar name: Required. The name. Must be unique across all components within the same app.
    :vartype name: str
    :ivar production: Whether this is a production or dev database.
    :vartype production: bool
    :ivar version: The version of the database engine.
    :vartype version: str
    """

    _validation = {
        'name': {'required': True, 'max_length': 32, 'min_length': 2, 'pattern': r'^[a-z][a-z0-9-]{0,30}[a-z0-9]$'},
    }

    _attribute_map = {
        'cluster_name': {'key': 'cluster_name', 'type': 'str'},
        'db_name': {'key': 'db_name', 'type': 'str'},
        'db_user': {'key': 'db_user', 'type': 'str'},
        'engine': {'key': 'engine', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'production': {'key': 'production', 'type': 'bool'},
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        cluster_name: Optional[str] = None,
        db_name: Optional[str] = None,
        db_user: Optional[str] = None,
        engine: Optional[Union[str, "_models.AppDatabaseSpecEngine"]] = "UNSET",
        production: Optional[bool] = None,
        version: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required
         for production databases. For dev databases, if cluster_name is not set, a new cluster will be
         provisioned.
        :paramtype cluster_name: str
        :keyword db_name: The name of the MySQL or PostgreSQL database to configure.
        :paramtype db_name: str
        :keyword db_user: The name of the MySQL or PostgreSQL user to configure.
        :paramtype db_user: str
        :keyword engine: * MYSQL: MySQL
         * PG: PostgreSQL
         * REDIS: Redis. Known values are: "UNSET", "MYSQL", "PG", "REDIS". Default value: "UNSET".
        :paramtype engine: str or ~digital_ocean_api.models.AppDatabaseSpecEngine
        :keyword name: Required. The name. Must be unique across all components within the same app.
        :paramtype name: str
        :keyword production: Whether this is a production or dev database.
        :paramtype production: bool
        :keyword version: The version of the database engine.
        :paramtype version: str
        """
        super(AppDatabaseSpec, self).__init__(**kwargs)
        self.cluster_name = cluster_name
        self.db_name = db_name
        self.db_user = db_user
        self.engine = engine
        self.name = name
        self.production = production
        self.version = version


class AppDomainSpec(msrest.serialization.Model):
    """AppDomainSpec.

    All required parameters must be populated in order to send to Azure.

    :ivar domain: Required. The hostname for the domain.
    :vartype domain: str
    :ivar type: * DEFAULT: The default ``.ondigitalocean.app`` domain assigned to this app
     * PRIMARY: The primary domain for this app that is displayed as the default in the control
     panel, used in bindable environment variables, and any other places that reference an app's
     live URL. Only one domain may be set as primary.
     * ALIAS: A non-primary domain. Known values are: "UNSPECIFIED", "DEFAULT", "PRIMARY", "ALIAS".
     Default value: "UNSPECIFIED".
    :vartype type: str or ~digital_ocean_api.models.AppDomainSpecType
    :ivar wildcard: Indicates whether the domain includes all sub-domains, in addition to the given
     domain.
    :vartype wildcard: bool
    :ivar zone: Optional. If the domain uses DigitalOcean DNS and you would like App
     Platform to automatically manage it for you, set this to the name of the
     domain on your account.
    
     For example, If the domain you are adding is ``app.domain.com``\ , the zone
     could be ``domain.com``.
    :vartype zone: str
    """

    _validation = {
        'domain': {'required': True, 'max_length': 253, 'min_length': 4, 'pattern': r'^((xn--)?[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\.)+[a-zA-Z]{2,}\.?$'},
    }

    _attribute_map = {
        'domain': {'key': 'domain', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'wildcard': {'key': 'wildcard', 'type': 'bool'},
        'zone': {'key': 'zone', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        domain: str,
        type: Optional[Union[str, "_models.AppDomainSpecType"]] = "UNSPECIFIED",
        wildcard: Optional[bool] = None,
        zone: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword domain: Required. The hostname for the domain.
        :paramtype domain: str
        :keyword type: * DEFAULT: The default ``.ondigitalocean.app`` domain assigned to this app
         * PRIMARY: The primary domain for this app that is displayed as the default in the control
         panel, used in bindable environment variables, and any other places that reference an app's
         live URL. Only one domain may be set as primary.
         * ALIAS: A non-primary domain. Known values are: "UNSPECIFIED", "DEFAULT", "PRIMARY", "ALIAS".
         Default value: "UNSPECIFIED".
        :paramtype type: str or ~digital_ocean_api.models.AppDomainSpecType
        :keyword wildcard: Indicates whether the domain includes all sub-domains, in addition to the
         given domain.
        :paramtype wildcard: bool
        :keyword zone: Optional. If the domain uses DigitalOcean DNS and you would like App
         Platform to automatically manage it for you, set this to the name of the
         domain on your account.
        
         For example, If the domain you are adding is ``app.domain.com``\ , the zone
         could be ``domain.com``.
        :paramtype zone: str
        """
        super(AppDomainSpec, self).__init__(**kwargs)
        self.domain = domain
        self.type = type
        self.wildcard = wildcard
        self.zone = zone


class AppJobSpec(AppComponentBase, AppComponentInstanceBase):
    """AppJobSpec.

    :ivar instance_count: The amount of instances that this component should be scaled to. Default:
     1.
    :vartype instance_count: long
    :ivar instance_size_slug: The instance size to use for this component. Default: ``basic-xxs``.
     Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m", "professional-xs",
     "professional-s", "professional-m", "professional-1l", "professional-l", "professional-xl".
     Default value: "basic-xxs".
    :vartype instance_size_slug: str or
     ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
    :ivar name: The name. Must be unique across all components within the same app.
    :vartype name: str
    :ivar git:
    :vartype git: ~digital_ocean_api.models.AppsGitSourceSpec
    :ivar github:
    :vartype github: ~digital_ocean_api.models.AppsGithubSourceSpec
    :ivar gitlab:
    :vartype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
    :ivar image:
    :vartype image: ~digital_ocean_api.models.AppsImageSourceSpec
    :ivar dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it
     will be used to build this component. Otherwise, App Platform will attempt to build it using
     buildpacks.
    :vartype dockerfile_path: str
    :ivar build_command: An optional build command to run while building this component from
     source.
    :vartype build_command: str
    :ivar run_command: An optional run command to override the component's default.
    :vartype run_command: str
    :ivar source_dir: An optional path to the working directory to use for the build. For
     Dockerfile builds, this will be used as the build context. Must be relative to the root of the
     repo.
    :vartype source_dir: str
    :ivar envs: A list of environment variables made available to the component.
    :vartype envs: list[~digital_ocean_api.models.AppVariableDefinition]
    :ivar environment_slug: An environment slug describing the type of this app. For a full list,
     please refer to `the product documentation <https://www.digitalocean.com/docs/app-platform/>`_.
    :vartype environment_slug: str
    :ivar kind: * UNSPECIFIED: Default job type, will auto-complete to POST_DEPLOY kind.
     * PRE_DEPLOY: Indicates a job that runs before an app deployment.
     * POST_DEPLOY: Indicates a job that runs after an app deployment.
     * FAILED_DEPLOY: Indicates a job that runs after a component fails to deploy. Known values
     are: "UNSPECIFIED", "PRE_DEPLOY", "POST_DEPLOY", "FAILED_DEPLOY". Default value: "UNSPECIFIED".
    :vartype kind: str or ~digital_ocean_api.models.AppJobSpecKind
    """

    _validation = {
        'instance_count': {'minimum': 1},
        'name': {'max_length': 32, 'min_length': 2, 'pattern': r'^[a-z][a-z0-9-]{0,30}[a-z0-9]$'},
    }

    _attribute_map = {
        'instance_count': {'key': 'instance_count', 'type': 'long'},
        'instance_size_slug': {'key': 'instance_size_slug', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'git': {'key': 'git', 'type': 'AppsGitSourceSpec'},
        'github': {'key': 'github', 'type': 'AppsGithubSourceSpec'},
        'gitlab': {'key': 'gitlab', 'type': 'AppsGitlabSourceSpec'},
        'image': {'key': 'image', 'type': 'AppsImageSourceSpec'},
        'dockerfile_path': {'key': 'dockerfile_path', 'type': 'str'},
        'build_command': {'key': 'build_command', 'type': 'str'},
        'run_command': {'key': 'run_command', 'type': 'str'},
        'source_dir': {'key': 'source_dir', 'type': 'str'},
        'envs': {'key': 'envs', 'type': '[AppVariableDefinition]'},
        'environment_slug': {'key': 'environment_slug', 'type': 'str'},
        'kind': {'key': 'kind', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        instance_count: Optional[int] = 1,
        instance_size_slug: Optional[Union[str, "_models.AppComponentInstanceBaseInstanceSizeSlug"]] = "basic-xxs",
        name: Optional[str] = None,
        git: Optional["_models.AppsGitSourceSpec"] = None,
        github: Optional["_models.AppsGithubSourceSpec"] = None,
        gitlab: Optional["_models.AppsGitlabSourceSpec"] = None,
        image: Optional["_models.AppsImageSourceSpec"] = None,
        dockerfile_path: Optional[str] = None,
        build_command: Optional[str] = None,
        run_command: Optional[str] = None,
        source_dir: Optional[str] = None,
        envs: Optional[List["_models.AppVariableDefinition"]] = None,
        environment_slug: Optional[str] = None,
        kind: Optional[Union[str, "_models.AppJobSpecKind"]] = "UNSPECIFIED",
        **kwargs
    ):
        """
        :keyword instance_count: The amount of instances that this component should be scaled to.
         Default: 1.
        :paramtype instance_count: long
        :keyword instance_size_slug: The instance size to use for this component. Default:
         ``basic-xxs``. Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m",
         "professional-xs", "professional-s", "professional-m", "professional-1l", "professional-l",
         "professional-xl". Default value: "basic-xxs".
        :paramtype instance_size_slug: str or
         ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
        :keyword name: The name. Must be unique across all components within the same app.
        :paramtype name: str
        :keyword git:
        :paramtype git: ~digital_ocean_api.models.AppsGitSourceSpec
        :keyword github:
        :paramtype github: ~digital_ocean_api.models.AppsGithubSourceSpec
        :keyword gitlab:
        :paramtype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
        :keyword image:
        :paramtype image: ~digital_ocean_api.models.AppsImageSourceSpec
        :keyword dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set,
         it will be used to build this component. Otherwise, App Platform will attempt to build it using
         buildpacks.
        :paramtype dockerfile_path: str
        :keyword build_command: An optional build command to run while building this component from
         source.
        :paramtype build_command: str
        :keyword run_command: An optional run command to override the component's default.
        :paramtype run_command: str
        :keyword source_dir: An optional path to the working directory to use for the build. For
         Dockerfile builds, this will be used as the build context. Must be relative to the root of the
         repo.
        :paramtype source_dir: str
        :keyword envs: A list of environment variables made available to the component.
        :paramtype envs: list[~digital_ocean_api.models.AppVariableDefinition]
        :keyword environment_slug: An environment slug describing the type of this app. For a full
         list, please refer to `the product documentation
         <https://www.digitalocean.com/docs/app-platform/>`_.
        :paramtype environment_slug: str
        :keyword kind: * UNSPECIFIED: Default job type, will auto-complete to POST_DEPLOY kind.
         * PRE_DEPLOY: Indicates a job that runs before an app deployment.
         * POST_DEPLOY: Indicates a job that runs after an app deployment.
         * FAILED_DEPLOY: Indicates a job that runs after a component fails to deploy. Known values
         are: "UNSPECIFIED", "PRE_DEPLOY", "POST_DEPLOY", "FAILED_DEPLOY". Default value: "UNSPECIFIED".
        :paramtype kind: str or ~digital_ocean_api.models.AppJobSpecKind
        """
        super(AppJobSpec, self).__init__(name=name, git=git, github=github, gitlab=gitlab, image=image, dockerfile_path=dockerfile_path, build_command=build_command, run_command=run_command, source_dir=source_dir, envs=envs, environment_slug=environment_slug, instance_count=instance_count, instance_size_slug=instance_size_slug, **kwargs)
        self.instance_count = instance_count
        self.instance_size_slug = instance_size_slug
        self.kind = kind
        self.name = name
        self.git = git
        self.github = github
        self.gitlab = gitlab
        self.image = image
        self.dockerfile_path = dockerfile_path
        self.build_command = build_command
        self.run_command = run_command
        self.source_dir = source_dir
        self.envs = envs
        self.environment_slug = environment_slug


class AppPropose(msrest.serialization.Model):
    """AppPropose.

    All required parameters must be populated in order to send to Azure.

    :ivar spec: Required. The desired configuration of an application.
    :vartype spec: ~digital_ocean_api.models.AppSpec
    :ivar app_id: An optional ID of an existing app. If set, the spec will be treated as a proposed
     update to the specified app. The existing app is not modified using this method.
    :vartype app_id: str
    """

    _validation = {
        'spec': {'required': True},
    }

    _attribute_map = {
        'spec': {'key': 'spec', 'type': 'AppSpec'},
        'app_id': {'key': 'app_id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        spec: "_models.AppSpec",
        app_id: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword spec: Required. The desired configuration of an application.
        :paramtype spec: ~digital_ocean_api.models.AppSpec
        :keyword app_id: An optional ID of an existing app. If set, the spec will be treated as a
         proposed update to the specified app. The existing app is not modified using this method.
        :paramtype app_id: str
        """
        super(AppPropose, self).__init__(**kwargs)
        self.spec = spec
        self.app_id = app_id


class AppProposeResponse(msrest.serialization.Model):
    """AppProposeResponse.

    :ivar app_is_static: Indicates whether the app is a static app.
    :vartype app_is_static: bool
    :ivar app_name_available: Indicates whether the app name is available.
    :vartype app_name_available: bool
    :ivar app_name_suggestion: The suggested name if the proposed app name is unavailable.
    :vartype app_name_suggestion: str
    :ivar existing_static_apps: The maximum number of free static apps the account can have. We
     will charge you for any additional static apps.
    :vartype existing_static_apps: str
    :ivar spec: The desired configuration of an application.
    :vartype spec: ~digital_ocean_api.models.AppSpec
    :ivar app_cost: The monthly cost of the proposed app in USD using the next pricing plan tier.
     For example, if you propose an app that uses the Basic tier, the ``app_tier_upgrade_cost``
     field displays the monthly cost of the app if it were to use the Professional tier. If the
     proposed app already uses the most expensive tier, the field is empty.
    :vartype app_cost: int
    :ivar app_tier_downgrade_cost: The monthly cost of the proposed app in USD using the previous
     pricing plan tier. For example, if you propose an app that uses the Professional tier, the
     ``app_tier_downgrade_cost`` field displays the monthly cost of the app if it were to use the
     Basic tier. If the proposed app already uses the lest expensive tier, the field is empty.
    :vartype app_tier_downgrade_cost: int
    """

    _attribute_map = {
        'app_is_static': {'key': 'app_is_static', 'type': 'bool'},
        'app_name_available': {'key': 'app_name_available', 'type': 'bool'},
        'app_name_suggestion': {'key': 'app_name_suggestion', 'type': 'str'},
        'existing_static_apps': {'key': 'existing_static_apps', 'type': 'str'},
        'spec': {'key': 'spec', 'type': 'AppSpec'},
        'app_cost': {'key': 'app_cost', 'type': 'int'},
        'app_tier_downgrade_cost': {'key': 'app_tier_downgrade_cost', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        app_is_static: Optional[bool] = None,
        app_name_available: Optional[bool] = None,
        app_name_suggestion: Optional[str] = None,
        existing_static_apps: Optional[str] = None,
        spec: Optional["_models.AppSpec"] = None,
        app_cost: Optional[int] = None,
        app_tier_downgrade_cost: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword app_is_static: Indicates whether the app is a static app.
        :paramtype app_is_static: bool
        :keyword app_name_available: Indicates whether the app name is available.
        :paramtype app_name_available: bool
        :keyword app_name_suggestion: The suggested name if the proposed app name is unavailable.
        :paramtype app_name_suggestion: str
        :keyword existing_static_apps: The maximum number of free static apps the account can have. We
         will charge you for any additional static apps.
        :paramtype existing_static_apps: str
        :keyword spec: The desired configuration of an application.
        :paramtype spec: ~digital_ocean_api.models.AppSpec
        :keyword app_cost: The monthly cost of the proposed app in USD using the next pricing plan
         tier. For example, if you propose an app that uses the Basic tier, the
         ``app_tier_upgrade_cost`` field displays the monthly cost of the app if it were to use the
         Professional tier. If the proposed app already uses the most expensive tier, the field is
         empty.
        :paramtype app_cost: int
        :keyword app_tier_downgrade_cost: The monthly cost of the proposed app in USD using the
         previous pricing plan tier. For example, if you propose an app that uses the Professional tier,
         the ``app_tier_downgrade_cost`` field displays the monthly cost of the app if it were to use
         the Basic tier. If the proposed app already uses the lest expensive tier, the field is empty.
        :paramtype app_tier_downgrade_cost: int
        """
        super(AppProposeResponse, self).__init__(**kwargs)
        self.app_is_static = app_is_static
        self.app_name_available = app_name_available
        self.app_name_suggestion = app_name_suggestion
        self.existing_static_apps = existing_static_apps
        self.spec = spec
        self.app_cost = app_cost
        self.app_tier_downgrade_cost = app_tier_downgrade_cost


class AppResponse(msrest.serialization.Model):
    """AppResponse.

    :ivar app: An application's configuration and status.
    :vartype app: ~digital_ocean_api.models.App
    """

    _attribute_map = {
        'app': {'key': 'app', 'type': 'App'},
    }

    def __init__(
        self,
        *,
        app: Optional["_models.App"] = None,
        **kwargs
    ):
        """
        :keyword app: An application's configuration and status.
        :paramtype app: ~digital_ocean_api.models.App
        """
        super(AppResponse, self).__init__(**kwargs)
        self.app = app


class AppRouteSpec(msrest.serialization.Model):
    """A criterion for routing HTTP traffic to a component.

    :ivar path: An HTTP path prefix. Paths must start with / and must be unique across all
     components within an app.
    :vartype path: str
    :ivar preserve_path_prefix: An optional flag to preserve the path that is forwarded to the
     backend service. By default, the HTTP request path will be trimmed from the left when forwarded
     to the component. For example, a component with ``path=/api`` will have requests to
     ``/api/list`` trimmed to ``/list``. If this value is ``true``\ , the path will remain
     ``/api/list``.
    :vartype preserve_path_prefix: bool
    """

    _attribute_map = {
        'path': {'key': 'path', 'type': 'str'},
        'preserve_path_prefix': {'key': 'preserve_path_prefix', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        path: Optional[str] = None,
        preserve_path_prefix: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword path: An HTTP path prefix. Paths must start with / and must be unique across all
         components within an app.
        :paramtype path: str
        :keyword preserve_path_prefix: An optional flag to preserve the path that is forwarded to the
         backend service. By default, the HTTP request path will be trimmed from the left when forwarded
         to the component. For example, a component with ``path=/api`` will have requests to
         ``/api/list`` trimmed to ``/list``. If this value is ``true``\ , the path will remain
         ``/api/list``.
        :paramtype preserve_path_prefix: bool
        """
        super(AppRouteSpec, self).__init__(**kwargs)
        self.path = path
        self.preserve_path_prefix = preserve_path_prefix


class AppsAlertResponse(msrest.serialization.Model):
    """AppsAlertResponse.

    :ivar alert:
    :vartype alert: ~digital_ocean_api.models.AppAlert
    """

    _attribute_map = {
        'alert': {'key': 'alert', 'type': 'AppAlert'},
    }

    def __init__(
        self,
        *,
        alert: Optional["_models.AppAlert"] = None,
        **kwargs
    ):
        """
        :keyword alert:
        :paramtype alert: ~digital_ocean_api.models.AppAlert
        """
        super(AppsAlertResponse, self).__init__(**kwargs)
        self.alert = alert


class AppsAssignAppAlertDestinationsRequest(msrest.serialization.Model):
    """AppsAssignAppAlertDestinationsRequest.

    :ivar emails:
    :vartype emails: list[str]
    :ivar slack_webhooks:
    :vartype slack_webhooks: list[~digital_ocean_api.models.AppAlertSlackWebhook]
    """

    _attribute_map = {
        'emails': {'key': 'emails', 'type': '[str]'},
        'slack_webhooks': {'key': 'slack_webhooks', 'type': '[AppAlertSlackWebhook]'},
    }

    def __init__(
        self,
        *,
        emails: Optional[List[str]] = None,
        slack_webhooks: Optional[List["_models.AppAlertSlackWebhook"]] = None,
        **kwargs
    ):
        """
        :keyword emails:
        :paramtype emails: list[str]
        :keyword slack_webhooks:
        :paramtype slack_webhooks: list[~digital_ocean_api.models.AppAlertSlackWebhook]
        """
        super(AppsAssignAppAlertDestinationsRequest, self).__init__(**kwargs)
        self.emails = emails
        self.slack_webhooks = slack_webhooks


class AppsCorsPolicy(msrest.serialization.Model):
    """AppsCorsPolicy.

    :ivar allow_origins: The set of allowed CORS origins.
    :vartype allow_origins: list[~digital_ocean_api.models.AppsStringMatch]
    :ivar allow_methods: The set of allowed HTTP methods. This configures the
     ``Access-Control-Allow-Methods`` header.
    :vartype allow_methods: list[str]
    :ivar allow_headers: The set of allowed HTTP request headers. This configures the
     ``Access-Control-Allow-Headers`` header.
    :vartype allow_headers: list[str]
    :ivar expose_headers: The set of HTTP response headers that browsers are allowed to access.
     This configures the ``Access-Control-Expose-Headers`` header.
    :vartype expose_headers: list[str]
    :ivar max_age: An optional duration specifying how long browsers can cache the results of a
     preflight request. This configures the ``Access-Control-Max-Age`` header.
    :vartype max_age: str
    :ivar allow_credentials: Whether browsers should expose the response to the client-side
     JavaScript code when the requests credentials mode is include. This configures the
     ``Access-Control-Allow-Credentials`` header.
    :vartype allow_credentials: bool
    """

    _attribute_map = {
        'allow_origins': {'key': 'allow_origins', 'type': '[AppsStringMatch]'},
        'allow_methods': {'key': 'allow_methods', 'type': '[str]'},
        'allow_headers': {'key': 'allow_headers', 'type': '[str]'},
        'expose_headers': {'key': 'expose_headers', 'type': '[str]'},
        'max_age': {'key': 'max_age', 'type': 'str'},
        'allow_credentials': {'key': 'allow_credentials', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        allow_origins: Optional[List["_models.AppsStringMatch"]] = None,
        allow_methods: Optional[List[str]] = None,
        allow_headers: Optional[List[str]] = None,
        expose_headers: Optional[List[str]] = None,
        max_age: Optional[str] = None,
        allow_credentials: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword allow_origins: The set of allowed CORS origins.
        :paramtype allow_origins: list[~digital_ocean_api.models.AppsStringMatch]
        :keyword allow_methods: The set of allowed HTTP methods. This configures the
         ``Access-Control-Allow-Methods`` header.
        :paramtype allow_methods: list[str]
        :keyword allow_headers: The set of allowed HTTP request headers. This configures the
         ``Access-Control-Allow-Headers`` header.
        :paramtype allow_headers: list[str]
        :keyword expose_headers: The set of HTTP response headers that browsers are allowed to access.
         This configures the ``Access-Control-Expose-Headers`` header.
        :paramtype expose_headers: list[str]
        :keyword max_age: An optional duration specifying how long browsers can cache the results of a
         preflight request. This configures the ``Access-Control-Max-Age`` header.
        :paramtype max_age: str
        :keyword allow_credentials: Whether browsers should expose the response to the client-side
         JavaScript code when the requests credentials mode is include. This configures the
         ``Access-Control-Allow-Credentials`` header.
        :paramtype allow_credentials: bool
        """
        super(AppsCorsPolicy, self).__init__(**kwargs)
        self.allow_origins = allow_origins
        self.allow_methods = allow_methods
        self.allow_headers = allow_headers
        self.expose_headers = expose_headers
        self.max_age = max_age
        self.allow_credentials = allow_credentials


class AppsCreateAppRequest(msrest.serialization.Model):
    """AppsCreateAppRequest.

    All required parameters must be populated in order to send to Azure.

    :ivar spec: Required. The desired configuration of an application.
    :vartype spec: ~digital_ocean_api.models.AppSpec
    """

    _validation = {
        'spec': {'required': True},
    }

    _attribute_map = {
        'spec': {'key': 'spec', 'type': 'AppSpec'},
    }

    def __init__(
        self,
        *,
        spec: "_models.AppSpec",
        **kwargs
    ):
        """
        :keyword spec: Required. The desired configuration of an application.
        :paramtype spec: ~digital_ocean_api.models.AppSpec
        """
        super(AppsCreateAppRequest, self).__init__(**kwargs)
        self.spec = spec


class AppsCreateDeploymentRequest(msrest.serialization.Model):
    """AppsCreateDeploymentRequest.

    :ivar force_build: Indicates whether to force a build of app from source even if an existing
     cached build is suitable for re-use.
    :vartype force_build: bool
    """

    _attribute_map = {
        'force_build': {'key': 'force_build', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        force_build: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword force_build: Indicates whether to force a build of app from source even if an existing
         cached build is suitable for re-use.
        :paramtype force_build: bool
        """
        super(AppsCreateDeploymentRequest, self).__init__(**kwargs)
        self.force_build = force_build


class AppsDeleteAppResponse(msrest.serialization.Model):
    """AppsDeleteAppResponse.

    :ivar id: The ID of the app that was deleted.
    :vartype id: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: The ID of the app that was deleted.
        :paramtype id: str
        """
        super(AppsDeleteAppResponse, self).__init__(**kwargs)
        self.id = id


class AppsDeployment(msrest.serialization.Model):
    """An app deployment.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar cause: What caused this deployment to be created.
    :vartype cause: str
    :ivar cloned_from: The ID of a previous deployment that this deployment was cloned from.
    :vartype cloned_from: str
    :ivar created_at: The creation time of the deployment.
    :vartype created_at: ~datetime.datetime
    :ivar id: The ID of the deployment.
    :vartype id: str
    :ivar jobs: Job components that are part of this deployment.
    :vartype jobs: list[~digital_ocean_api.models.AppsDeploymentJob]
    :ivar phase: Known values are: "UNKNOWN", "PENDING_BUILD", "BUILDING", "PENDING_DEPLOY",
     "DEPLOYING", "ACTIVE", "SUPERSEDED", "ERROR", "CANCELED". Default value: "UNKNOWN".
    :vartype phase: str or ~digital_ocean_api.models.AppsDeploymentPhase
    :ivar phase_last_updated_at: When the deployment phase was last updated.
    :vartype phase_last_updated_at: ~datetime.datetime
    :ivar progress:
    :vartype progress: ~digital_ocean_api.models.AppsDeploymentProgress
    :ivar services: Service components that are part of this deployment.
    :vartype services: list[~digital_ocean_api.models.AppsDeploymentService]
    :ivar spec: The desired configuration of an application.
    :vartype spec: ~digital_ocean_api.models.AppSpec
    :ivar static_sites: Static Site components that are part of this deployment.
    :vartype static_sites: list[~digital_ocean_api.models.AppsDeploymentStaticSite]
    :ivar tier_slug: The current pricing tier slug of the deployment.
    :vartype tier_slug: str
    :ivar updated_at: When the deployment was last updated.
    :vartype updated_at: ~datetime.datetime
    :ivar workers: Worker components that are part of this deployment.
    :vartype workers: list[~digital_ocean_api.models.AppsDeploymentWorker]
    """

    _validation = {
        'tier_slug': {'readonly': True},
    }

    _attribute_map = {
        'cause': {'key': 'cause', 'type': 'str'},
        'cloned_from': {'key': 'cloned_from', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'id': {'key': 'id', 'type': 'str'},
        'jobs': {'key': 'jobs', 'type': '[AppsDeploymentJob]'},
        'phase': {'key': 'phase', 'type': 'str'},
        'phase_last_updated_at': {'key': 'phase_last_updated_at', 'type': 'iso-8601'},
        'progress': {'key': 'progress', 'type': 'AppsDeploymentProgress'},
        'services': {'key': 'services', 'type': '[AppsDeploymentService]'},
        'spec': {'key': 'spec', 'type': 'AppSpec'},
        'static_sites': {'key': 'static_sites', 'type': '[AppsDeploymentStaticSite]'},
        'tier_slug': {'key': 'tier_slug', 'type': 'str'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
        'workers': {'key': 'workers', 'type': '[AppsDeploymentWorker]'},
    }

    def __init__(
        self,
        *,
        cause: Optional[str] = None,
        cloned_from: Optional[str] = None,
        created_at: Optional[datetime.datetime] = None,
        id: Optional[str] = None,
        jobs: Optional[List["_models.AppsDeploymentJob"]] = None,
        phase: Optional[Union[str, "_models.AppsDeploymentPhase"]] = "UNKNOWN",
        phase_last_updated_at: Optional[datetime.datetime] = None,
        progress: Optional["_models.AppsDeploymentProgress"] = None,
        services: Optional[List["_models.AppsDeploymentService"]] = None,
        spec: Optional["_models.AppSpec"] = None,
        static_sites: Optional[List["_models.AppsDeploymentStaticSite"]] = None,
        updated_at: Optional[datetime.datetime] = None,
        workers: Optional[List["_models.AppsDeploymentWorker"]] = None,
        **kwargs
    ):
        """
        :keyword cause: What caused this deployment to be created.
        :paramtype cause: str
        :keyword cloned_from: The ID of a previous deployment that this deployment was cloned from.
        :paramtype cloned_from: str
        :keyword created_at: The creation time of the deployment.
        :paramtype created_at: ~datetime.datetime
        :keyword id: The ID of the deployment.
        :paramtype id: str
        :keyword jobs: Job components that are part of this deployment.
        :paramtype jobs: list[~digital_ocean_api.models.AppsDeploymentJob]
        :keyword phase: Known values are: "UNKNOWN", "PENDING_BUILD", "BUILDING", "PENDING_DEPLOY",
         "DEPLOYING", "ACTIVE", "SUPERSEDED", "ERROR", "CANCELED". Default value: "UNKNOWN".
        :paramtype phase: str or ~digital_ocean_api.models.AppsDeploymentPhase
        :keyword phase_last_updated_at: When the deployment phase was last updated.
        :paramtype phase_last_updated_at: ~datetime.datetime
        :keyword progress:
        :paramtype progress: ~digital_ocean_api.models.AppsDeploymentProgress
        :keyword services: Service components that are part of this deployment.
        :paramtype services: list[~digital_ocean_api.models.AppsDeploymentService]
        :keyword spec: The desired configuration of an application.
        :paramtype spec: ~digital_ocean_api.models.AppSpec
        :keyword static_sites: Static Site components that are part of this deployment.
        :paramtype static_sites: list[~digital_ocean_api.models.AppsDeploymentStaticSite]
        :keyword updated_at: When the deployment was last updated.
        :paramtype updated_at: ~datetime.datetime
        :keyword workers: Worker components that are part of this deployment.
        :paramtype workers: list[~digital_ocean_api.models.AppsDeploymentWorker]
        """
        super(AppsDeployment, self).__init__(**kwargs)
        self.cause = cause
        self.cloned_from = cloned_from
        self.created_at = created_at
        self.id = id
        self.jobs = jobs
        self.phase = phase
        self.phase_last_updated_at = phase_last_updated_at
        self.progress = progress
        self.services = services
        self.spec = spec
        self.static_sites = static_sites
        self.tier_slug = None
        self.updated_at = updated_at
        self.workers = workers


class AppsDeploymentJob(msrest.serialization.Model):
    """AppsDeploymentJob.

    :ivar name: The name of this job.
    :vartype name: str
    :ivar source_commit_hash: The commit hash of the repository that was used to build this job.
    :vartype source_commit_hash: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'source_commit_hash': {'key': 'source_commit_hash', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        source_commit_hash: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of this job.
        :paramtype name: str
        :keyword source_commit_hash: The commit hash of the repository that was used to build this job.
        :paramtype source_commit_hash: str
        """
        super(AppsDeploymentJob, self).__init__(**kwargs)
        self.name = name
        self.source_commit_hash = source_commit_hash


class AppsDeploymentProgress(msrest.serialization.Model):
    """AppsDeploymentProgress.

    :ivar error_steps: Number of unsuccessful steps.
    :vartype error_steps: int
    :ivar pending_steps: Number of pending steps.
    :vartype pending_steps: int
    :ivar running_steps: Number of currently running steps.
    :vartype running_steps: int
    :ivar steps: The deployment's steps.
    :vartype steps: list[~digital_ocean_api.models.AppsDeploymentProgressStep]
    :ivar success_steps: Number of successful steps.
    :vartype success_steps: int
    :ivar summary_steps: A flattened summary of the steps.
    :vartype summary_steps: list[~digital_ocean_api.models.AppsDeploymentProgressStep]
    :ivar total_steps: Total number of steps.
    :vartype total_steps: int
    """

    _attribute_map = {
        'error_steps': {'key': 'error_steps', 'type': 'int'},
        'pending_steps': {'key': 'pending_steps', 'type': 'int'},
        'running_steps': {'key': 'running_steps', 'type': 'int'},
        'steps': {'key': 'steps', 'type': '[AppsDeploymentProgressStep]'},
        'success_steps': {'key': 'success_steps', 'type': 'int'},
        'summary_steps': {'key': 'summary_steps', 'type': '[AppsDeploymentProgressStep]'},
        'total_steps': {'key': 'total_steps', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        error_steps: Optional[int] = None,
        pending_steps: Optional[int] = None,
        running_steps: Optional[int] = None,
        steps: Optional[List["_models.AppsDeploymentProgressStep"]] = None,
        success_steps: Optional[int] = None,
        summary_steps: Optional[List["_models.AppsDeploymentProgressStep"]] = None,
        total_steps: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword error_steps: Number of unsuccessful steps.
        :paramtype error_steps: int
        :keyword pending_steps: Number of pending steps.
        :paramtype pending_steps: int
        :keyword running_steps: Number of currently running steps.
        :paramtype running_steps: int
        :keyword steps: The deployment's steps.
        :paramtype steps: list[~digital_ocean_api.models.AppsDeploymentProgressStep]
        :keyword success_steps: Number of successful steps.
        :paramtype success_steps: int
        :keyword summary_steps: A flattened summary of the steps.
        :paramtype summary_steps: list[~digital_ocean_api.models.AppsDeploymentProgressStep]
        :keyword total_steps: Total number of steps.
        :paramtype total_steps: int
        """
        super(AppsDeploymentProgress, self).__init__(**kwargs)
        self.error_steps = error_steps
        self.pending_steps = pending_steps
        self.running_steps = running_steps
        self.steps = steps
        self.success_steps = success_steps
        self.summary_steps = summary_steps
        self.total_steps = total_steps


class AppsDeploymentProgressStep(msrest.serialization.Model):
    """A step that is run as part of the deployment's lifecycle.

    :ivar component_name: The component name that this step is associated with.
    :vartype component_name: str
    :ivar ended_at: The end time of this step.
    :vartype ended_at: ~datetime.datetime
    :ivar message_base: The base of a human-readable description of the step intended to be
     combined with the component name for presentation. For example:
    
     ``message_base`` = "Building service"
     ``component_name`` = "api".
    :vartype message_base: str
    :ivar name: The name of this step.
    :vartype name: str
    :ivar reason:
    :vartype reason: ~digital_ocean_api.models.AppsDeploymentProgressStepReason
    :ivar started_at: The start time of this step.
    :vartype started_at: ~datetime.datetime
    :ivar status: Known values are: "UNKNOWN", "PENDING", "RUNNING", "ERROR", "SUCCESS". Default
     value: "UNKNOWN".
    :vartype status: str or ~digital_ocean_api.models.AppsDeploymentProgressStepStatus
    :ivar steps: Child steps of this step.
    :vartype steps: list[any]
    """

    _attribute_map = {
        'component_name': {'key': 'component_name', 'type': 'str'},
        'ended_at': {'key': 'ended_at', 'type': 'iso-8601'},
        'message_base': {'key': 'message_base', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'reason': {'key': 'reason', 'type': 'AppsDeploymentProgressStepReason'},
        'started_at': {'key': 'started_at', 'type': 'iso-8601'},
        'status': {'key': 'status', 'type': 'str'},
        'steps': {'key': 'steps', 'type': '[object]'},
    }

    def __init__(
        self,
        *,
        component_name: Optional[str] = None,
        ended_at: Optional[datetime.datetime] = None,
        message_base: Optional[str] = None,
        name: Optional[str] = None,
        reason: Optional["_models.AppsDeploymentProgressStepReason"] = None,
        started_at: Optional[datetime.datetime] = None,
        status: Optional[Union[str, "_models.AppsDeploymentProgressStepStatus"]] = "UNKNOWN",
        steps: Optional[List[Any]] = None,
        **kwargs
    ):
        """
        :keyword component_name: The component name that this step is associated with.
        :paramtype component_name: str
        :keyword ended_at: The end time of this step.
        :paramtype ended_at: ~datetime.datetime
        :keyword message_base: The base of a human-readable description of the step intended to be
         combined with the component name for presentation. For example:
        
         ``message_base`` = "Building service"
         ``component_name`` = "api".
        :paramtype message_base: str
        :keyword name: The name of this step.
        :paramtype name: str
        :keyword reason:
        :paramtype reason: ~digital_ocean_api.models.AppsDeploymentProgressStepReason
        :keyword started_at: The start time of this step.
        :paramtype started_at: ~datetime.datetime
        :keyword status: Known values are: "UNKNOWN", "PENDING", "RUNNING", "ERROR", "SUCCESS". Default
         value: "UNKNOWN".
        :paramtype status: str or ~digital_ocean_api.models.AppsDeploymentProgressStepStatus
        :keyword steps: Child steps of this step.
        :paramtype steps: list[any]
        """
        super(AppsDeploymentProgressStep, self).__init__(**kwargs)
        self.component_name = component_name
        self.ended_at = ended_at
        self.message_base = message_base
        self.name = name
        self.reason = reason
        self.started_at = started_at
        self.status = status
        self.steps = steps


class AppsDeploymentProgressStepReason(msrest.serialization.Model):
    """AppsDeploymentProgressStepReason.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        message: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword code: The error code.
        :paramtype code: str
        :keyword message: The error message.
        :paramtype message: str
        """
        super(AppsDeploymentProgressStepReason, self).__init__(**kwargs)
        self.code = code
        self.message = message


class AppsDeploymentResponse(msrest.serialization.Model):
    """AppsDeploymentResponse.

    :ivar deployment: An app deployment.
    :vartype deployment: ~digital_ocean_api.models.AppsDeployment
    """

    _attribute_map = {
        'deployment': {'key': 'deployment', 'type': 'AppsDeployment'},
    }

    def __init__(
        self,
        *,
        deployment: Optional["_models.AppsDeployment"] = None,
        **kwargs
    ):
        """
        :keyword deployment: An app deployment.
        :paramtype deployment: ~digital_ocean_api.models.AppsDeployment
        """
        super(AppsDeploymentResponse, self).__init__(**kwargs)
        self.deployment = deployment


class AppsDeploymentService(msrest.serialization.Model):
    """AppsDeploymentService.

    :ivar name: The name of this service.
    :vartype name: str
    :ivar source_commit_hash: The commit hash of the repository that was used to build this
     service.
    :vartype source_commit_hash: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'source_commit_hash': {'key': 'source_commit_hash', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        source_commit_hash: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of this service.
        :paramtype name: str
        :keyword source_commit_hash: The commit hash of the repository that was used to build this
         service.
        :paramtype source_commit_hash: str
        """
        super(AppsDeploymentService, self).__init__(**kwargs)
        self.name = name
        self.source_commit_hash = source_commit_hash


class Meta(msrest.serialization.Model):
    """Meta.

    All required parameters must be populated in order to send to Azure.

    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        **kwargs
    ):
        """
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        """
        super(Meta, self).__init__(**kwargs)
        self.meta = meta


class Pagination(msrest.serialization.Model):
    """Pagination.

    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _attribute_map = {
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Pagination, self).__init__(**kwargs)
        self.links = links


class AppsDeploymentsResponse(Pagination, Meta):
    """AppsDeploymentsResponse.

    All required parameters must be populated in order to send to Azure.

    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    :ivar deployments: A list of deployments.
    :vartype deployments: list[~digital_ocean_api.models.AppsDeployment]
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
        'deployments': {'key': 'deployments', 'type': '[AppsDeployment]'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        deployments: Optional[List["_models.AppsDeployment"]] = None,
        **kwargs
    ):
        """
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        :keyword deployments: A list of deployments.
        :paramtype deployments: list[~digital_ocean_api.models.AppsDeployment]
        """
        super(AppsDeploymentsResponse, self).__init__(links=links, meta=meta, **kwargs)
        self.meta = meta
        self.deployments = deployments
        self.links = links


class AppsDeploymentStaticSite(msrest.serialization.Model):
    """AppsDeploymentStaticSite.

    :ivar name: The name of this static site.
    :vartype name: str
    :ivar source_commit_hash: The commit hash of the repository that was used to build this static
     site.
    :vartype source_commit_hash: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'source_commit_hash': {'key': 'source_commit_hash', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        source_commit_hash: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of this static site.
        :paramtype name: str
        :keyword source_commit_hash: The commit hash of the repository that was used to build this
         static site.
        :paramtype source_commit_hash: str
        """
        super(AppsDeploymentStaticSite, self).__init__(**kwargs)
        self.name = name
        self.source_commit_hash = source_commit_hash


class AppsDeploymentWorker(msrest.serialization.Model):
    """AppsDeploymentWorker.

    :ivar name: The name of this worker.
    :vartype name: str
    :ivar source_commit_hash: The commit hash of the repository that was used to build this worker.
    :vartype source_commit_hash: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'source_commit_hash': {'key': 'source_commit_hash', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        source_commit_hash: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of this worker.
        :paramtype name: str
        :keyword source_commit_hash: The commit hash of the repository that was used to build this
         worker.
        :paramtype source_commit_hash: str
        """
        super(AppsDeploymentWorker, self).__init__(**kwargs)
        self.name = name
        self.source_commit_hash = source_commit_hash


class AppsDomain(msrest.serialization.Model):
    """AppsDomain.

    :ivar id: The ID of the domain.
    :vartype id: str
    :ivar phase: Known values are: "UNKNOWN", "PENDING", "CONFIGURING", "ACTIVE", "ERROR". Default
     value: "UNKNOWN".
    :vartype phase: str or ~digital_ocean_api.models.AppsDomainPhase
    :ivar progress:
    :vartype progress: ~digital_ocean_api.models.AppsDomainProgress
    :ivar spec:
    :vartype spec: ~digital_ocean_api.models.AppDomainSpec
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'phase': {'key': 'phase', 'type': 'str'},
        'progress': {'key': 'progress', 'type': 'AppsDomainProgress'},
        'spec': {'key': 'spec', 'type': 'AppDomainSpec'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        phase: Optional[Union[str, "_models.AppsDomainPhase"]] = "UNKNOWN",
        progress: Optional["_models.AppsDomainProgress"] = None,
        spec: Optional["_models.AppDomainSpec"] = None,
        **kwargs
    ):
        """
        :keyword id: The ID of the domain.
        :paramtype id: str
        :keyword phase: Known values are: "UNKNOWN", "PENDING", "CONFIGURING", "ACTIVE", "ERROR".
         Default value: "UNKNOWN".
        :paramtype phase: str or ~digital_ocean_api.models.AppsDomainPhase
        :keyword progress:
        :paramtype progress: ~digital_ocean_api.models.AppsDomainProgress
        :keyword spec:
        :paramtype spec: ~digital_ocean_api.models.AppDomainSpec
        """
        super(AppsDomain, self).__init__(**kwargs)
        self.id = id
        self.phase = phase
        self.progress = progress
        self.spec = spec


class AppsDomainProgress(msrest.serialization.Model):
    """AppsDomainProgress.

    :ivar steps: The steps of the domain's progress.
    :vartype steps: list[any]
    """

    _attribute_map = {
        'steps': {'key': 'steps', 'type': '[object]'},
    }

    def __init__(
        self,
        *,
        steps: Optional[List[Any]] = None,
        **kwargs
    ):
        """
        :keyword steps: The steps of the domain's progress.
        :paramtype steps: list[any]
        """
        super(AppsDomainProgress, self).__init__(**kwargs)
        self.steps = steps


class AppServiceSpec(AppComponentBase, AppComponentInstanceBase):
    """AppServiceSpec.

    :ivar instance_count: The amount of instances that this component should be scaled to. Default:
     1.
    :vartype instance_count: long
    :ivar instance_size_slug: The instance size to use for this component. Default: ``basic-xxs``.
     Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m", "professional-xs",
     "professional-s", "professional-m", "professional-1l", "professional-l", "professional-xl".
     Default value: "basic-xxs".
    :vartype instance_size_slug: str or
     ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
    :ivar name: The name. Must be unique across all components within the same app.
    :vartype name: str
    :ivar git:
    :vartype git: ~digital_ocean_api.models.AppsGitSourceSpec
    :ivar github:
    :vartype github: ~digital_ocean_api.models.AppsGithubSourceSpec
    :ivar gitlab:
    :vartype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
    :ivar image:
    :vartype image: ~digital_ocean_api.models.AppsImageSourceSpec
    :ivar dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it
     will be used to build this component. Otherwise, App Platform will attempt to build it using
     buildpacks.
    :vartype dockerfile_path: str
    :ivar build_command: An optional build command to run while building this component from
     source.
    :vartype build_command: str
    :ivar run_command: An optional run command to override the component's default.
    :vartype run_command: str
    :ivar source_dir: An optional path to the working directory to use for the build. For
     Dockerfile builds, this will be used as the build context. Must be relative to the root of the
     repo.
    :vartype source_dir: str
    :ivar envs: A list of environment variables made available to the component.
    :vartype envs: list[~digital_ocean_api.models.AppVariableDefinition]
    :ivar environment_slug: An environment slug describing the type of this app. For a full list,
     please refer to `the product documentation <https://www.digitalocean.com/docs/app-platform/>`_.
    :vartype environment_slug: str
    :ivar cors:
    :vartype cors: ~digital_ocean_api.models.AppsCorsPolicy
    :ivar health_check:
    :vartype health_check: ~digital_ocean_api.models.AppServiceSpecHealthCheck
    :ivar http_port: The internal port on which this service's run command will listen. Default:
     8080
     If there is not an environment variable with the name ``PORT``\ , one will be automatically
     added with its value set to the value of this field.
    :vartype http_port: long
    :ivar internal_ports: The ports on which this service will listen for internal traffic.
    :vartype internal_ports: list[long]
    :ivar routes: A list of HTTP routes that should be routed to this component.
    :vartype routes: list[~digital_ocean_api.models.AppRouteSpec]
    """

    _validation = {
        'instance_count': {'minimum': 1},
        'name': {'max_length': 32, 'min_length': 2, 'pattern': r'^[a-z][a-z0-9-]{0,30}[a-z0-9]$'},
        'http_port': {'maximum': 65535, 'minimum': 1},
    }

    _attribute_map = {
        'instance_count': {'key': 'instance_count', 'type': 'long'},
        'instance_size_slug': {'key': 'instance_size_slug', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'git': {'key': 'git', 'type': 'AppsGitSourceSpec'},
        'github': {'key': 'github', 'type': 'AppsGithubSourceSpec'},
        'gitlab': {'key': 'gitlab', 'type': 'AppsGitlabSourceSpec'},
        'image': {'key': 'image', 'type': 'AppsImageSourceSpec'},
        'dockerfile_path': {'key': 'dockerfile_path', 'type': 'str'},
        'build_command': {'key': 'build_command', 'type': 'str'},
        'run_command': {'key': 'run_command', 'type': 'str'},
        'source_dir': {'key': 'source_dir', 'type': 'str'},
        'envs': {'key': 'envs', 'type': '[AppVariableDefinition]'},
        'environment_slug': {'key': 'environment_slug', 'type': 'str'},
        'cors': {'key': 'cors', 'type': 'AppsCorsPolicy'},
        'health_check': {'key': 'health_check', 'type': 'AppServiceSpecHealthCheck'},
        'http_port': {'key': 'http_port', 'type': 'long'},
        'internal_ports': {'key': 'internal_ports', 'type': '[long]'},
        'routes': {'key': 'routes', 'type': '[AppRouteSpec]'},
    }

    def __init__(
        self,
        *,
        instance_count: Optional[int] = 1,
        instance_size_slug: Optional[Union[str, "_models.AppComponentInstanceBaseInstanceSizeSlug"]] = "basic-xxs",
        name: Optional[str] = None,
        git: Optional["_models.AppsGitSourceSpec"] = None,
        github: Optional["_models.AppsGithubSourceSpec"] = None,
        gitlab: Optional["_models.AppsGitlabSourceSpec"] = None,
        image: Optional["_models.AppsImageSourceSpec"] = None,
        dockerfile_path: Optional[str] = None,
        build_command: Optional[str] = None,
        run_command: Optional[str] = None,
        source_dir: Optional[str] = None,
        envs: Optional[List["_models.AppVariableDefinition"]] = None,
        environment_slug: Optional[str] = None,
        cors: Optional["_models.AppsCorsPolicy"] = None,
        health_check: Optional["_models.AppServiceSpecHealthCheck"] = None,
        http_port: Optional[int] = None,
        internal_ports: Optional[List[int]] = None,
        routes: Optional[List["_models.AppRouteSpec"]] = None,
        **kwargs
    ):
        """
        :keyword instance_count: The amount of instances that this component should be scaled to.
         Default: 1.
        :paramtype instance_count: long
        :keyword instance_size_slug: The instance size to use for this component. Default:
         ``basic-xxs``. Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m",
         "professional-xs", "professional-s", "professional-m", "professional-1l", "professional-l",
         "professional-xl". Default value: "basic-xxs".
        :paramtype instance_size_slug: str or
         ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
        :keyword name: The name. Must be unique across all components within the same app.
        :paramtype name: str
        :keyword git:
        :paramtype git: ~digital_ocean_api.models.AppsGitSourceSpec
        :keyword github:
        :paramtype github: ~digital_ocean_api.models.AppsGithubSourceSpec
        :keyword gitlab:
        :paramtype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
        :keyword image:
        :paramtype image: ~digital_ocean_api.models.AppsImageSourceSpec
        :keyword dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set,
         it will be used to build this component. Otherwise, App Platform will attempt to build it using
         buildpacks.
        :paramtype dockerfile_path: str
        :keyword build_command: An optional build command to run while building this component from
         source.
        :paramtype build_command: str
        :keyword run_command: An optional run command to override the component's default.
        :paramtype run_command: str
        :keyword source_dir: An optional path to the working directory to use for the build. For
         Dockerfile builds, this will be used as the build context. Must be relative to the root of the
         repo.
        :paramtype source_dir: str
        :keyword envs: A list of environment variables made available to the component.
        :paramtype envs: list[~digital_ocean_api.models.AppVariableDefinition]
        :keyword environment_slug: An environment slug describing the type of this app. For a full
         list, please refer to `the product documentation
         <https://www.digitalocean.com/docs/app-platform/>`_.
        :paramtype environment_slug: str
        :keyword cors:
        :paramtype cors: ~digital_ocean_api.models.AppsCorsPolicy
        :keyword health_check:
        :paramtype health_check: ~digital_ocean_api.models.AppServiceSpecHealthCheck
        :keyword http_port: The internal port on which this service's run command will listen. Default:
         8080
         If there is not an environment variable with the name ``PORT``\ , one will be automatically
         added with its value set to the value of this field.
        :paramtype http_port: long
        :keyword internal_ports: The ports on which this service will listen for internal traffic.
        :paramtype internal_ports: list[long]
        :keyword routes: A list of HTTP routes that should be routed to this component.
        :paramtype routes: list[~digital_ocean_api.models.AppRouteSpec]
        """
        super(AppServiceSpec, self).__init__(name=name, git=git, github=github, gitlab=gitlab, image=image, dockerfile_path=dockerfile_path, build_command=build_command, run_command=run_command, source_dir=source_dir, envs=envs, environment_slug=environment_slug, instance_count=instance_count, instance_size_slug=instance_size_slug, **kwargs)
        self.instance_count = instance_count
        self.instance_size_slug = instance_size_slug
        self.cors = cors
        self.health_check = health_check
        self.http_port = http_port
        self.internal_ports = internal_ports
        self.routes = routes
        self.name = name
        self.git = git
        self.github = github
        self.gitlab = gitlab
        self.image = image
        self.dockerfile_path = dockerfile_path
        self.build_command = build_command
        self.run_command = run_command
        self.source_dir = source_dir
        self.envs = envs
        self.environment_slug = environment_slug


class AppServiceSpecHealthCheck(msrest.serialization.Model):
    """AppServiceSpecHealthCheck.

    :ivar failure_threshold: The number of failed health checks before considered unhealthy.
    :vartype failure_threshold: int
    :ivar port: The port on which the health check will be performed. If not set, the health check
     will be performed on the component's http_port.
    :vartype port: long
    :ivar http_path: The route path used for the HTTP health check ping. If not set, the HTTP
     health check will be disabled and a TCP health check used instead.
    :vartype http_path: str
    :ivar initial_delay_seconds: The number of seconds to wait before beginning health checks.
    :vartype initial_delay_seconds: int
    :ivar period_seconds: The number of seconds to wait between health checks.
    :vartype period_seconds: int
    :ivar success_threshold: The number of successful health checks before considered healthy.
    :vartype success_threshold: int
    :ivar timeout_seconds: The number of seconds after which the check times out.
    :vartype timeout_seconds: int
    """

    _validation = {
        'port': {'maximum': 65535, 'minimum': 1},
    }

    _attribute_map = {
        'failure_threshold': {'key': 'failure_threshold', 'type': 'int'},
        'port': {'key': 'port', 'type': 'long'},
        'http_path': {'key': 'http_path', 'type': 'str'},
        'initial_delay_seconds': {'key': 'initial_delay_seconds', 'type': 'int'},
        'period_seconds': {'key': 'period_seconds', 'type': 'int'},
        'success_threshold': {'key': 'success_threshold', 'type': 'int'},
        'timeout_seconds': {'key': 'timeout_seconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        failure_threshold: Optional[int] = None,
        port: Optional[int] = None,
        http_path: Optional[str] = None,
        initial_delay_seconds: Optional[int] = None,
        period_seconds: Optional[int] = None,
        success_threshold: Optional[int] = None,
        timeout_seconds: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword failure_threshold: The number of failed health checks before considered unhealthy.
        :paramtype failure_threshold: int
        :keyword port: The port on which the health check will be performed. If not set, the health
         check will be performed on the component's http_port.
        :paramtype port: long
        :keyword http_path: The route path used for the HTTP health check ping. If not set, the HTTP
         health check will be disabled and a TCP health check used instead.
        :paramtype http_path: str
        :keyword initial_delay_seconds: The number of seconds to wait before beginning health checks.
        :paramtype initial_delay_seconds: int
        :keyword period_seconds: The number of seconds to wait between health checks.
        :paramtype period_seconds: int
        :keyword success_threshold: The number of successful health checks before considered healthy.
        :paramtype success_threshold: int
        :keyword timeout_seconds: The number of seconds after which the check times out.
        :paramtype timeout_seconds: int
        """
        super(AppServiceSpecHealthCheck, self).__init__(**kwargs)
        self.failure_threshold = failure_threshold
        self.port = port
        self.http_path = http_path
        self.initial_delay_seconds = initial_delay_seconds
        self.period_seconds = period_seconds
        self.success_threshold = success_threshold
        self.timeout_seconds = timeout_seconds


class AppsGetInstanceSizeResponse(msrest.serialization.Model):
    """AppsGetInstanceSizeResponse.

    :ivar instance_size:
    :vartype instance_size: ~digital_ocean_api.models.AppsInstanceSize
    """

    _attribute_map = {
        'instance_size': {'key': 'instance_size', 'type': 'AppsInstanceSize'},
    }

    def __init__(
        self,
        *,
        instance_size: Optional["_models.AppsInstanceSize"] = None,
        **kwargs
    ):
        """
        :keyword instance_size:
        :paramtype instance_size: ~digital_ocean_api.models.AppsInstanceSize
        """
        super(AppsGetInstanceSizeResponse, self).__init__(**kwargs)
        self.instance_size = instance_size


class AppsGetLogsResponse(msrest.serialization.Model):
    """AppsGetLogsResponse.

    :ivar historic_urls: A list of URLs to archived log files.
    :vartype historic_urls: list[str]
    :ivar live_url: A URL of the real-time live logs. This URL may use either the ``https://`` or
     ``wss://`` protocols and will keep pushing live logs as they become available.
    :vartype live_url: str
    """

    _attribute_map = {
        'historic_urls': {'key': 'historic_urls', 'type': '[str]'},
        'live_url': {'key': 'live_url', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        historic_urls: Optional[List[str]] = None,
        live_url: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword historic_urls: A list of URLs to archived log files.
        :paramtype historic_urls: list[str]
        :keyword live_url: A URL of the real-time live logs. This URL may use either the ``https://``
         or ``wss://`` protocols and will keep pushing live logs as they become available.
        :paramtype live_url: str
        """
        super(AppsGetLogsResponse, self).__init__(**kwargs)
        self.historic_urls = historic_urls
        self.live_url = live_url


class AppsGetTierResponse(msrest.serialization.Model):
    """AppsGetTierResponse.

    :ivar tier:
    :vartype tier: ~digital_ocean_api.models.AppsTier
    """

    _attribute_map = {
        'tier': {'key': 'tier', 'type': 'AppsTier'},
    }

    def __init__(
        self,
        *,
        tier: Optional["_models.AppsTier"] = None,
        **kwargs
    ):
        """
        :keyword tier:
        :paramtype tier: ~digital_ocean_api.models.AppsTier
        """
        super(AppsGetTierResponse, self).__init__(**kwargs)
        self.tier = tier


class AppsGithubSourceSpec(msrest.serialization.Model):
    """AppsGithubSourceSpec.

    :ivar branch: The name of the branch to use.
    :vartype branch: str
    :ivar deploy_on_push: Whether to automatically deploy new commits made to the repo.
    :vartype deploy_on_push: bool
    :ivar repo: The name of the repo in the format owner/repo. Example:
     ``digitalocean/sample-golang``.
    :vartype repo: str
    """

    _attribute_map = {
        'branch': {'key': 'branch', 'type': 'str'},
        'deploy_on_push': {'key': 'deploy_on_push', 'type': 'bool'},
        'repo': {'key': 'repo', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        branch: Optional[str] = None,
        deploy_on_push: Optional[bool] = None,
        repo: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword branch: The name of the branch to use.
        :paramtype branch: str
        :keyword deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :paramtype deploy_on_push: bool
        :keyword repo: The name of the repo in the format owner/repo. Example:
         ``digitalocean/sample-golang``.
        :paramtype repo: str
        """
        super(AppsGithubSourceSpec, self).__init__(**kwargs)
        self.branch = branch
        self.deploy_on_push = deploy_on_push
        self.repo = repo


class AppsGitlabSourceSpec(msrest.serialization.Model):
    """AppsGitlabSourceSpec.

    :ivar branch: The name of the branch to use.
    :vartype branch: str
    :ivar deploy_on_push: Whether to automatically deploy new commits made to the repo.
    :vartype deploy_on_push: bool
    :ivar repo: The name of the repo in the format owner/repo. Example:
     ``digitalocean/sample-golang``.
    :vartype repo: str
    """

    _attribute_map = {
        'branch': {'key': 'branch', 'type': 'str'},
        'deploy_on_push': {'key': 'deploy_on_push', 'type': 'bool'},
        'repo': {'key': 'repo', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        branch: Optional[str] = None,
        deploy_on_push: Optional[bool] = None,
        repo: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword branch: The name of the branch to use.
        :paramtype branch: str
        :keyword deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :paramtype deploy_on_push: bool
        :keyword repo: The name of the repo in the format owner/repo. Example:
         ``digitalocean/sample-golang``.
        :paramtype repo: str
        """
        super(AppsGitlabSourceSpec, self).__init__(**kwargs)
        self.branch = branch
        self.deploy_on_push = deploy_on_push
        self.repo = repo


class AppsGitSourceSpec(msrest.serialization.Model):
    """AppsGitSourceSpec.

    :ivar branch: The name of the branch to use.
    :vartype branch: str
    :ivar repo_clone_url: The clone URL of the repo. Example:
     ``https://github.com/digitalocean/sample-golang.git``.
    :vartype repo_clone_url: str
    """

    _attribute_map = {
        'branch': {'key': 'branch', 'type': 'str'},
        'repo_clone_url': {'key': 'repo_clone_url', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        branch: Optional[str] = None,
        repo_clone_url: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword branch: The name of the branch to use.
        :paramtype branch: str
        :keyword repo_clone_url: The clone URL of the repo. Example:
         ``https://github.com/digitalocean/sample-golang.git``.
        :paramtype repo_clone_url: str
        """
        super(AppsGitSourceSpec, self).__init__(**kwargs)
        self.branch = branch
        self.repo_clone_url = repo_clone_url


class AppsImageSourceSpec(msrest.serialization.Model):
    """AppsImageSourceSpec.

    :ivar registry: The registry name. Must be left empty for the ``DOCR`` registry type.
    :vartype registry: str
    :ivar registry_type: * DOCKER_HUB: The DockerHub container registry type.
     * DOCR: The DigitalOcean container registry type. Known values are: "DOCKER_HUB", "DOCR".
    :vartype registry_type: str or ~digital_ocean_api.models.AppsImageSourceSpecRegistryType
    :ivar repository: The repository name.
    :vartype repository: str
    :ivar tag: The repository tag. Defaults to ``latest`` if not provided.
    :vartype tag: str
    """

    _attribute_map = {
        'registry': {'key': 'registry', 'type': 'str'},
        'registry_type': {'key': 'registry_type', 'type': 'str'},
        'repository': {'key': 'repository', 'type': 'str'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        registry: Optional[str] = None,
        registry_type: Optional[Union[str, "_models.AppsImageSourceSpecRegistryType"]] = None,
        repository: Optional[str] = None,
        tag: Optional[str] = "latest",
        **kwargs
    ):
        """
        :keyword registry: The registry name. Must be left empty for the ``DOCR`` registry type.
        :paramtype registry: str
        :keyword registry_type: * DOCKER_HUB: The DockerHub container registry type.
         * DOCR: The DigitalOcean container registry type. Known values are: "DOCKER_HUB", "DOCR".
        :paramtype registry_type: str or ~digital_ocean_api.models.AppsImageSourceSpecRegistryType
        :keyword repository: The repository name.
        :paramtype repository: str
        :keyword tag: The repository tag. Defaults to ``latest`` if not provided.
        :paramtype tag: str
        """
        super(AppsImageSourceSpec, self).__init__(**kwargs)
        self.registry = registry
        self.registry_type = registry_type
        self.repository = repository
        self.tag = tag


class AppsInstanceSize(msrest.serialization.Model):
    """AppsInstanceSize.

    :ivar cpu_type: * SHARED: Shared vCPU cores
    
       * DEDICATED: Dedicated vCPU cores. Known values are: "UNSPECIFIED", "SHARED", "DEDICATED".
     Default value: "UNSPECIFIED".
    :vartype cpu_type: str or ~digital_ocean_api.models.InstanceSizeCpuType
    :ivar cpus: The number of allotted vCPU cores.
    :vartype cpus: str
    :ivar memory_bytes: The allotted memory in bytes.
    :vartype memory_bytes: str
    :ivar name: A human-readable name of the instance size.
    :vartype name: str
    :ivar slug: The slug of the instance size.
    :vartype slug: str
    :ivar tier_downgrade_to: The slug of the corresponding downgradable instance size on the lower
     tier.
    :vartype tier_downgrade_to: str
    :ivar tier_slug: The slug of the tier to which this instance size belongs.
    :vartype tier_slug: str
    :ivar tier_upgrade_to: The slug of the corresponding upgradable instance size on the higher
     tier.
    :vartype tier_upgrade_to: str
    :ivar usd_per_month: The cost of this instance size in USD per month.
    :vartype usd_per_month: str
    :ivar usd_per_second: The cost of this instance size in USD per second.
    :vartype usd_per_second: str
    """

    _attribute_map = {
        'cpu_type': {'key': 'cpu_type', 'type': 'str'},
        'cpus': {'key': 'cpus', 'type': 'str'},
        'memory_bytes': {'key': 'memory_bytes', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'tier_downgrade_to': {'key': 'tier_downgrade_to', 'type': 'str'},
        'tier_slug': {'key': 'tier_slug', 'type': 'str'},
        'tier_upgrade_to': {'key': 'tier_upgrade_to', 'type': 'str'},
        'usd_per_month': {'key': 'usd_per_month', 'type': 'str'},
        'usd_per_second': {'key': 'usd_per_second', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        cpu_type: Optional[Union[str, "_models.InstanceSizeCpuType"]] = "UNSPECIFIED",
        cpus: Optional[str] = None,
        memory_bytes: Optional[str] = None,
        name: Optional[str] = None,
        slug: Optional[str] = None,
        tier_downgrade_to: Optional[str] = None,
        tier_slug: Optional[str] = None,
        tier_upgrade_to: Optional[str] = None,
        usd_per_month: Optional[str] = None,
        usd_per_second: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword cpu_type: * SHARED: Shared vCPU cores
        
           * DEDICATED: Dedicated vCPU cores. Known values are: "UNSPECIFIED", "SHARED", "DEDICATED".
         Default value: "UNSPECIFIED".
        :paramtype cpu_type: str or ~digital_ocean_api.models.InstanceSizeCpuType
        :keyword cpus: The number of allotted vCPU cores.
        :paramtype cpus: str
        :keyword memory_bytes: The allotted memory in bytes.
        :paramtype memory_bytes: str
        :keyword name: A human-readable name of the instance size.
        :paramtype name: str
        :keyword slug: The slug of the instance size.
        :paramtype slug: str
        :keyword tier_downgrade_to: The slug of the corresponding downgradable instance size on the
         lower tier.
        :paramtype tier_downgrade_to: str
        :keyword tier_slug: The slug of the tier to which this instance size belongs.
        :paramtype tier_slug: str
        :keyword tier_upgrade_to: The slug of the corresponding upgradable instance size on the higher
         tier.
        :paramtype tier_upgrade_to: str
        :keyword usd_per_month: The cost of this instance size in USD per month.
        :paramtype usd_per_month: str
        :keyword usd_per_second: The cost of this instance size in USD per second.
        :paramtype usd_per_second: str
        """
        super(AppsInstanceSize, self).__init__(**kwargs)
        self.cpu_type = cpu_type
        self.cpus = cpus
        self.memory_bytes = memory_bytes
        self.name = name
        self.slug = slug
        self.tier_downgrade_to = tier_downgrade_to
        self.tier_slug = tier_slug
        self.tier_upgrade_to = tier_upgrade_to
        self.usd_per_month = usd_per_month
        self.usd_per_second = usd_per_second


class AppsListAlertsResponse(msrest.serialization.Model):
    """AppsListAlertsResponse.

    :ivar alerts:
    :vartype alerts: list[~digital_ocean_api.models.AppAlert]
    """

    _attribute_map = {
        'alerts': {'key': 'alerts', 'type': '[AppAlert]'},
    }

    def __init__(
        self,
        *,
        alerts: Optional[List["_models.AppAlert"]] = None,
        **kwargs
    ):
        """
        :keyword alerts:
        :paramtype alerts: list[~digital_ocean_api.models.AppAlert]
        """
        super(AppsListAlertsResponse, self).__init__(**kwargs)
        self.alerts = alerts


class AppsListInstanceSizesResponse(msrest.serialization.Model):
    """AppsListInstanceSizesResponse.

    :ivar discount_percent:
    :vartype discount_percent: float
    :ivar instance_sizes:
    :vartype instance_sizes: list[~digital_ocean_api.models.AppsInstanceSize]
    """

    _attribute_map = {
        'discount_percent': {'key': 'discount_percent', 'type': 'float'},
        'instance_sizes': {'key': 'instance_sizes', 'type': '[AppsInstanceSize]'},
    }

    def __init__(
        self,
        *,
        discount_percent: Optional[float] = None,
        instance_sizes: Optional[List["_models.AppsInstanceSize"]] = None,
        **kwargs
    ):
        """
        :keyword discount_percent:
        :paramtype discount_percent: float
        :keyword instance_sizes:
        :paramtype instance_sizes: list[~digital_ocean_api.models.AppsInstanceSize]
        """
        super(AppsListInstanceSizesResponse, self).__init__(**kwargs)
        self.discount_percent = discount_percent
        self.instance_sizes = instance_sizes


class AppsListRegionsResponse(msrest.serialization.Model):
    """AppsListRegionsResponse.

    :ivar regions:
    :vartype regions: list[~digital_ocean_api.models.AppsRegion]
    """

    _attribute_map = {
        'regions': {'key': 'regions', 'type': '[AppsRegion]'},
    }

    def __init__(
        self,
        *,
        regions: Optional[List["_models.AppsRegion"]] = None,
        **kwargs
    ):
        """
        :keyword regions:
        :paramtype regions: list[~digital_ocean_api.models.AppsRegion]
        """
        super(AppsListRegionsResponse, self).__init__(**kwargs)
        self.regions = regions


class AppsListTiersResponse(msrest.serialization.Model):
    """AppsListTiersResponse.

    :ivar tiers:
    :vartype tiers: list[~digital_ocean_api.models.AppsTier]
    """

    _attribute_map = {
        'tiers': {'key': 'tiers', 'type': '[AppsTier]'},
    }

    def __init__(
        self,
        *,
        tiers: Optional[List["_models.AppsTier"]] = None,
        **kwargs
    ):
        """
        :keyword tiers:
        :paramtype tiers: list[~digital_ocean_api.models.AppsTier]
        """
        super(AppsListTiersResponse, self).__init__(**kwargs)
        self.tiers = tiers


class AppSpec(msrest.serialization.Model):
    """The desired configuration of an application.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the app. Must be unique across all apps in the same account.
    :vartype name: str
    :ivar region: The slug form of the geographical origin of the app. Default: ``nearest
     available``. Known values are: "ams", "nyc", "fra".
    :vartype region: str or ~digital_ocean_api.models.AppSpecRegion
    :ivar domains: A set of hostnames where the application will be available.
    :vartype domains: list[~digital_ocean_api.models.AppDomainSpec]
    :ivar services: Workloads which expose publicy-accessible HTTP services.
    :vartype services: list[~digital_ocean_api.models.AppServiceSpec]
    :ivar static_sites: Content which can be rendered to static web assets.
    :vartype static_sites: list[~digital_ocean_api.models.AppStaticSiteSpec]
    :ivar jobs: Pre and post deployment workloads which do not expose publicly-accessible HTTP
     routes.
    :vartype jobs: list[~digital_ocean_api.models.AppJobSpec]
    :ivar workers: Workloads which do not expose publicly-accessible HTTP services.
    :vartype workers: list[~digital_ocean_api.models.AppWorkerSpec]
    :ivar databases: Database instances which can provide persistence to workloads within the
     application.
    :vartype databases: list[~digital_ocean_api.models.AppDatabaseSpec]
    """

    _validation = {
        'name': {'required': True, 'max_length': 32, 'min_length': 2, 'pattern': r'^[a-z][a-z0-9-]{0,30}[a-z0-9]$'},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'domains': {'key': 'domains', 'type': '[AppDomainSpec]'},
        'services': {'key': 'services', 'type': '[AppServiceSpec]'},
        'static_sites': {'key': 'static_sites', 'type': '[AppStaticSiteSpec]'},
        'jobs': {'key': 'jobs', 'type': '[AppJobSpec]'},
        'workers': {'key': 'workers', 'type': '[AppWorkerSpec]'},
        'databases': {'key': 'databases', 'type': '[AppDatabaseSpec]'},
    }

    def __init__(
        self,
        *,
        name: str,
        region: Optional[Union[str, "_models.AppSpecRegion"]] = None,
        domains: Optional[List["_models.AppDomainSpec"]] = None,
        services: Optional[List["_models.AppServiceSpec"]] = None,
        static_sites: Optional[List["_models.AppStaticSiteSpec"]] = None,
        jobs: Optional[List["_models.AppJobSpec"]] = None,
        workers: Optional[List["_models.AppWorkerSpec"]] = None,
        databases: Optional[List["_models.AppDatabaseSpec"]] = None,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the app. Must be unique across all apps in the same
         account.
        :paramtype name: str
        :keyword region: The slug form of the geographical origin of the app. Default: ``nearest
         available``. Known values are: "ams", "nyc", "fra".
        :paramtype region: str or ~digital_ocean_api.models.AppSpecRegion
        :keyword domains: A set of hostnames where the application will be available.
        :paramtype domains: list[~digital_ocean_api.models.AppDomainSpec]
        :keyword services: Workloads which expose publicy-accessible HTTP services.
        :paramtype services: list[~digital_ocean_api.models.AppServiceSpec]
        :keyword static_sites: Content which can be rendered to static web assets.
        :paramtype static_sites: list[~digital_ocean_api.models.AppStaticSiteSpec]
        :keyword jobs: Pre and post deployment workloads which do not expose publicly-accessible HTTP
         routes.
        :paramtype jobs: list[~digital_ocean_api.models.AppJobSpec]
        :keyword workers: Workloads which do not expose publicly-accessible HTTP services.
        :paramtype workers: list[~digital_ocean_api.models.AppWorkerSpec]
        :keyword databases: Database instances which can provide persistence to workloads within the
         application.
        :paramtype databases: list[~digital_ocean_api.models.AppDatabaseSpec]
        """
        super(AppSpec, self).__init__(**kwargs)
        self.name = name
        self.region = region
        self.domains = domains
        self.services = services
        self.static_sites = static_sites
        self.jobs = jobs
        self.workers = workers
        self.databases = databases


class AppsRegion(msrest.serialization.Model):
    """Geographical information about an app origin.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar continent: The continent that this region is in.
    :vartype continent: str
    :ivar data_centers: Data centers that are in this region.
    :vartype data_centers: list[str]
    :ivar default: Whether or not the region is presented as the default.
    :vartype default: bool
    :ivar disabled: Whether or not the region is open for new apps.
    :vartype disabled: bool
    :ivar flag: The flag of this region.
    :vartype flag: str
    :ivar label: A human-readable name of the region.
    :vartype label: str
    :ivar reason: Reason that this region is not available.
    :vartype reason: str
    :ivar slug: The slug form of the region name.
    :vartype slug: str
    """

    _validation = {
        'continent': {'readonly': True},
        'data_centers': {'readonly': True},
        'default': {'readonly': True},
        'disabled': {'readonly': True},
        'flag': {'readonly': True},
        'label': {'readonly': True},
        'reason': {'readonly': True},
        'slug': {'readonly': True},
    }

    _attribute_map = {
        'continent': {'key': 'continent', 'type': 'str'},
        'data_centers': {'key': 'data_centers', 'type': '[str]'},
        'default': {'key': 'default', 'type': 'bool'},
        'disabled': {'key': 'disabled', 'type': 'bool'},
        'flag': {'key': 'flag', 'type': 'str'},
        'label': {'key': 'label', 'type': 'str'},
        'reason': {'key': 'reason', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(AppsRegion, self).__init__(**kwargs)
        self.continent = None
        self.data_centers = None
        self.default = None
        self.disabled = None
        self.flag = None
        self.label = None
        self.reason = None
        self.slug = None


class AppsResponse(Pagination, Meta):
    """AppsResponse.

    All required parameters must be populated in order to send to Azure.

    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    :ivar apps: A list of apps.
    :vartype apps: list[~digital_ocean_api.models.App]
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
        'apps': {'key': 'apps', 'type': '[App]'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        apps: Optional[List["_models.App"]] = None,
        **kwargs
    ):
        """
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        :keyword apps: A list of apps.
        :paramtype apps: list[~digital_ocean_api.models.App]
        """
        super(AppsResponse, self).__init__(links=links, meta=meta, **kwargs)
        self.meta = meta
        self.apps = apps
        self.links = links


class AppsStringMatch(msrest.serialization.Model):
    """AppsStringMatch.

    :ivar exact: Exact string match. Only 1 of ``exact``\ , ``prefix``\ , or ``regex`` must be set.
    :vartype exact: str
    :ivar prefix: Prefix-based match. Only 1 of ``exact``\ , ``prefix``\ , or ``regex`` must be
     set.
    :vartype prefix: str
    :ivar regex: RE2 style regex-based match. Only 1 of ``exact``\ , ``prefix``\ , or ``regex``
     must be set. For more information about RE2 syntax, see:
     https://github.com/google/re2/wiki/Syntax.
    :vartype regex: str
    """

    _validation = {
        'exact': {'max_length': 256, 'min_length': 1},
        'prefix': {'max_length': 256, 'min_length': 1},
        'regex': {'max_length': 256, 'min_length': 1},
    }

    _attribute_map = {
        'exact': {'key': 'exact', 'type': 'str'},
        'prefix': {'key': 'prefix', 'type': 'str'},
        'regex': {'key': 'regex', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        exact: Optional[str] = None,
        prefix: Optional[str] = None,
        regex: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword exact: Exact string match. Only 1 of ``exact``\ , ``prefix``\ , or ``regex`` must be
         set.
        :paramtype exact: str
        :keyword prefix: Prefix-based match. Only 1 of ``exact``\ , ``prefix``\ , or ``regex`` must be
         set.
        :paramtype prefix: str
        :keyword regex: RE2 style regex-based match. Only 1 of ``exact``\ , ``prefix``\ , or ``regex``
         must be set. For more information about RE2 syntax, see:
         https://github.com/google/re2/wiki/Syntax.
        :paramtype regex: str
        """
        super(AppsStringMatch, self).__init__(**kwargs)
        self.exact = exact
        self.prefix = prefix
        self.regex = regex


class AppStaticSiteSpec(AppComponentBase):
    """AppStaticSiteSpec.

    :ivar name: The name. Must be unique across all components within the same app.
    :vartype name: str
    :ivar git:
    :vartype git: ~digital_ocean_api.models.AppsGitSourceSpec
    :ivar github:
    :vartype github: ~digital_ocean_api.models.AppsGithubSourceSpec
    :ivar gitlab:
    :vartype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
    :ivar image:
    :vartype image: ~digital_ocean_api.models.AppsImageSourceSpec
    :ivar dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it
     will be used to build this component. Otherwise, App Platform will attempt to build it using
     buildpacks.
    :vartype dockerfile_path: str
    :ivar build_command: An optional build command to run while building this component from
     source.
    :vartype build_command: str
    :ivar run_command: An optional run command to override the component's default.
    :vartype run_command: str
    :ivar source_dir: An optional path to the working directory to use for the build. For
     Dockerfile builds, this will be used as the build context. Must be relative to the root of the
     repo.
    :vartype source_dir: str
    :ivar envs: A list of environment variables made available to the component.
    :vartype envs: list[~digital_ocean_api.models.AppVariableDefinition]
    :ivar environment_slug: An environment slug describing the type of this app. For a full list,
     please refer to `the product documentation <https://www.digitalocean.com/docs/app-platform/>`_.
    :vartype environment_slug: str
    :ivar index_document: The name of the index document to use when serving this static site.
     Default: index.html.
    :vartype index_document: str
    :ivar error_document: The name of the error document to use when serving this static site.
     Default: 404.html. If no such file exists within the built assets, App Platform will supply
     one.
    :vartype error_document: str
    :ivar catchall_document: The name of the document to use as the fallback for any requests to
     documents that are not found when serving this static site. Only 1 of ``catchall_document`` or
     ``error_document`` can be set.
    :vartype catchall_document: str
    :ivar output_dir: An optional path to where the built assets will be located, relative to the
     build context. If not set, App Platform will automatically scan for these directory names:
     ``_static``\ , ``dist``\ , ``public``\ , ``build``.
    :vartype output_dir: str
    :ivar cors:
    :vartype cors: ~digital_ocean_api.models.AppsCorsPolicy
    :ivar routes: A list of HTTP routes that should be routed to this component.
    :vartype routes: list[~digital_ocean_api.models.AppRouteSpec]
    """

    _validation = {
        'name': {'max_length': 32, 'min_length': 2, 'pattern': r'^[a-z][a-z0-9-]{0,30}[a-z0-9]$'},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'git': {'key': 'git', 'type': 'AppsGitSourceSpec'},
        'github': {'key': 'github', 'type': 'AppsGithubSourceSpec'},
        'gitlab': {'key': 'gitlab', 'type': 'AppsGitlabSourceSpec'},
        'image': {'key': 'image', 'type': 'AppsImageSourceSpec'},
        'dockerfile_path': {'key': 'dockerfile_path', 'type': 'str'},
        'build_command': {'key': 'build_command', 'type': 'str'},
        'run_command': {'key': 'run_command', 'type': 'str'},
        'source_dir': {'key': 'source_dir', 'type': 'str'},
        'envs': {'key': 'envs', 'type': '[AppVariableDefinition]'},
        'environment_slug': {'key': 'environment_slug', 'type': 'str'},
        'index_document': {'key': 'index_document', 'type': 'str'},
        'error_document': {'key': 'error_document', 'type': 'str'},
        'catchall_document': {'key': 'catchall_document', 'type': 'str'},
        'output_dir': {'key': 'output_dir', 'type': 'str'},
        'cors': {'key': 'cors', 'type': 'AppsCorsPolicy'},
        'routes': {'key': 'routes', 'type': '[AppRouteSpec]'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        git: Optional["_models.AppsGitSourceSpec"] = None,
        github: Optional["_models.AppsGithubSourceSpec"] = None,
        gitlab: Optional["_models.AppsGitlabSourceSpec"] = None,
        image: Optional["_models.AppsImageSourceSpec"] = None,
        dockerfile_path: Optional[str] = None,
        build_command: Optional[str] = None,
        run_command: Optional[str] = None,
        source_dir: Optional[str] = None,
        envs: Optional[List["_models.AppVariableDefinition"]] = None,
        environment_slug: Optional[str] = None,
        index_document: Optional[str] = "index.html",
        error_document: Optional[str] = "404.html",
        catchall_document: Optional[str] = None,
        output_dir: Optional[str] = None,
        cors: Optional["_models.AppsCorsPolicy"] = None,
        routes: Optional[List["_models.AppRouteSpec"]] = None,
        **kwargs
    ):
        """
        :keyword name: The name. Must be unique across all components within the same app.
        :paramtype name: str
        :keyword git:
        :paramtype git: ~digital_ocean_api.models.AppsGitSourceSpec
        :keyword github:
        :paramtype github: ~digital_ocean_api.models.AppsGithubSourceSpec
        :keyword gitlab:
        :paramtype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
        :keyword image:
        :paramtype image: ~digital_ocean_api.models.AppsImageSourceSpec
        :keyword dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set,
         it will be used to build this component. Otherwise, App Platform will attempt to build it using
         buildpacks.
        :paramtype dockerfile_path: str
        :keyword build_command: An optional build command to run while building this component from
         source.
        :paramtype build_command: str
        :keyword run_command: An optional run command to override the component's default.
        :paramtype run_command: str
        :keyword source_dir: An optional path to the working directory to use for the build. For
         Dockerfile builds, this will be used as the build context. Must be relative to the root of the
         repo.
        :paramtype source_dir: str
        :keyword envs: A list of environment variables made available to the component.
        :paramtype envs: list[~digital_ocean_api.models.AppVariableDefinition]
        :keyword environment_slug: An environment slug describing the type of this app. For a full
         list, please refer to `the product documentation
         <https://www.digitalocean.com/docs/app-platform/>`_.
        :paramtype environment_slug: str
        :keyword index_document: The name of the index document to use when serving this static site.
         Default: index.html.
        :paramtype index_document: str
        :keyword error_document: The name of the error document to use when serving this static site.
         Default: 404.html. If no such file exists within the built assets, App Platform will supply
         one.
        :paramtype error_document: str
        :keyword catchall_document: The name of the document to use as the fallback for any requests to
         documents that are not found when serving this static site. Only 1 of ``catchall_document`` or
         ``error_document`` can be set.
        :paramtype catchall_document: str
        :keyword output_dir: An optional path to where the built assets will be located, relative to
         the build context. If not set, App Platform will automatically scan for these directory names:
         ``_static``\ , ``dist``\ , ``public``\ , ``build``.
        :paramtype output_dir: str
        :keyword cors:
        :paramtype cors: ~digital_ocean_api.models.AppsCorsPolicy
        :keyword routes: A list of HTTP routes that should be routed to this component.
        :paramtype routes: list[~digital_ocean_api.models.AppRouteSpec]
        """
        super(AppStaticSiteSpec, self).__init__(name=name, git=git, github=github, gitlab=gitlab, image=image, dockerfile_path=dockerfile_path, build_command=build_command, run_command=run_command, source_dir=source_dir, envs=envs, environment_slug=environment_slug, **kwargs)
        self.index_document = index_document
        self.error_document = error_document
        self.catchall_document = catchall_document
        self.output_dir = output_dir
        self.cors = cors
        self.routes = routes


class AppsTier(msrest.serialization.Model):
    """AppsTier.

    :ivar build_seconds: The amount of included build time in seconds.
    :vartype build_seconds: str
    :ivar egress_bandwidth_bytes: The amount of included outbound bandwidth in bytes.
    :vartype egress_bandwidth_bytes: str
    :ivar name: A human-readable name of the tier.
    :vartype name: str
    :ivar slug: The slug of the tier.
    :vartype slug: str
    :ivar storage_bytes: The allotted disk space in bytes.
    :vartype storage_bytes: str
    """

    _attribute_map = {
        'build_seconds': {'key': 'build_seconds', 'type': 'str'},
        'egress_bandwidth_bytes': {'key': 'egress_bandwidth_bytes', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'storage_bytes': {'key': 'storage_bytes', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        build_seconds: Optional[str] = None,
        egress_bandwidth_bytes: Optional[str] = None,
        name: Optional[str] = None,
        slug: Optional[str] = None,
        storage_bytes: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword build_seconds: The amount of included build time in seconds.
        :paramtype build_seconds: str
        :keyword egress_bandwidth_bytes: The amount of included outbound bandwidth in bytes.
        :paramtype egress_bandwidth_bytes: str
        :keyword name: A human-readable name of the tier.
        :paramtype name: str
        :keyword slug: The slug of the tier.
        :paramtype slug: str
        :keyword storage_bytes: The allotted disk space in bytes.
        :paramtype storage_bytes: str
        """
        super(AppsTier, self).__init__(**kwargs)
        self.build_seconds = build_seconds
        self.egress_bandwidth_bytes = egress_bandwidth_bytes
        self.name = name
        self.slug = slug
        self.storage_bytes = storage_bytes


class AppsUpdateAppRequest(msrest.serialization.Model):
    """AppsUpdateAppRequest.

    All required parameters must be populated in order to send to Azure.

    :ivar spec: Required. The desired configuration of an application.
    :vartype spec: ~digital_ocean_api.models.AppSpec
    """

    _validation = {
        'spec': {'required': True},
    }

    _attribute_map = {
        'spec': {'key': 'spec', 'type': 'AppSpec'},
    }

    def __init__(
        self,
        *,
        spec: "_models.AppSpec",
        **kwargs
    ):
        """
        :keyword spec: Required. The desired configuration of an application.
        :paramtype spec: ~digital_ocean_api.models.AppSpec
        """
        super(AppsUpdateAppRequest, self).__init__(**kwargs)
        self.spec = spec


class AppVariableDefinition(msrest.serialization.Model):
    """AppVariableDefinition.

    All required parameters must be populated in order to send to Azure.

    :ivar key: Required. The variable name.
    :vartype key: str
    :ivar scope: * RUN_TIME: Made available only at run-time
     * BUILD_TIME: Made available only at build-time
     * RUN_AND_BUILD_TIME: Made available at both build and run-time. Known values are: "UNSET",
     "RUN_TIME", "BUILD_TIME", "RUN_AND_BUILD_TIME". Default value: "RUN_AND_BUILD_TIME".
    :vartype scope: str or ~digital_ocean_api.models.AppVariableDefinitionScope
    :ivar type: * GENERAL: A plain-text environment variable
     * SECRET: A secret encrypted environment variable. Known values are: "GENERAL", "SECRET".
     Default value: "GENERAL".
    :vartype type: str or ~digital_ocean_api.models.AppVariableDefinitionType
    :ivar value: The value. If the type is ``SECRET``\ , the value will be encrypted on first
     submission. On following submissions, the encrypted value should be used.
    :vartype value: str
    """

    _validation = {
        'key': {'required': True, 'pattern': r'^[_A-Za-z][_A-Za-z0-9]*$'},
    }

    _attribute_map = {
        'key': {'key': 'key', 'type': 'str'},
        'scope': {'key': 'scope', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key: str,
        scope: Optional[Union[str, "_models.AppVariableDefinitionScope"]] = "RUN_AND_BUILD_TIME",
        type: Optional[Union[str, "_models.AppVariableDefinitionType"]] = "GENERAL",
        value: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword key: Required. The variable name.
        :paramtype key: str
        :keyword scope: * RUN_TIME: Made available only at run-time
         * BUILD_TIME: Made available only at build-time
         * RUN_AND_BUILD_TIME: Made available at both build and run-time. Known values are: "UNSET",
         "RUN_TIME", "BUILD_TIME", "RUN_AND_BUILD_TIME". Default value: "RUN_AND_BUILD_TIME".
        :paramtype scope: str or ~digital_ocean_api.models.AppVariableDefinitionScope
        :keyword type: * GENERAL: A plain-text environment variable
         * SECRET: A secret encrypted environment variable. Known values are: "GENERAL", "SECRET".
         Default value: "GENERAL".
        :paramtype type: str or ~digital_ocean_api.models.AppVariableDefinitionType
        :keyword value: The value. If the type is ``SECRET``\ , the value will be encrypted on first
         submission. On following submissions, the encrypted value should be used.
        :paramtype value: str
        """
        super(AppVariableDefinition, self).__init__(**kwargs)
        self.key = key
        self.scope = scope
        self.type = type
        self.value = value


class AppWorkerSpec(AppComponentBase, AppComponentInstanceBase):
    """AppWorkerSpec.

    :ivar instance_count: The amount of instances that this component should be scaled to. Default:
     1.
    :vartype instance_count: long
    :ivar instance_size_slug: The instance size to use for this component. Default: ``basic-xxs``.
     Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m", "professional-xs",
     "professional-s", "professional-m", "professional-1l", "professional-l", "professional-xl".
     Default value: "basic-xxs".
    :vartype instance_size_slug: str or
     ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
    :ivar name: The name. Must be unique across all components within the same app.
    :vartype name: str
    :ivar git:
    :vartype git: ~digital_ocean_api.models.AppsGitSourceSpec
    :ivar github:
    :vartype github: ~digital_ocean_api.models.AppsGithubSourceSpec
    :ivar gitlab:
    :vartype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
    :ivar image:
    :vartype image: ~digital_ocean_api.models.AppsImageSourceSpec
    :ivar dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set, it
     will be used to build this component. Otherwise, App Platform will attempt to build it using
     buildpacks.
    :vartype dockerfile_path: str
    :ivar build_command: An optional build command to run while building this component from
     source.
    :vartype build_command: str
    :ivar run_command: An optional run command to override the component's default.
    :vartype run_command: str
    :ivar source_dir: An optional path to the working directory to use for the build. For
     Dockerfile builds, this will be used as the build context. Must be relative to the root of the
     repo.
    :vartype source_dir: str
    :ivar envs: A list of environment variables made available to the component.
    :vartype envs: list[~digital_ocean_api.models.AppVariableDefinition]
    :ivar environment_slug: An environment slug describing the type of this app. For a full list,
     please refer to `the product documentation <https://www.digitalocean.com/docs/app-platform/>`_.
    :vartype environment_slug: str
    """

    _validation = {
        'instance_count': {'minimum': 1},
        'name': {'max_length': 32, 'min_length': 2, 'pattern': r'^[a-z][a-z0-9-]{0,30}[a-z0-9]$'},
    }

    _attribute_map = {
        'instance_count': {'key': 'instance_count', 'type': 'long'},
        'instance_size_slug': {'key': 'instance_size_slug', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'git': {'key': 'git', 'type': 'AppsGitSourceSpec'},
        'github': {'key': 'github', 'type': 'AppsGithubSourceSpec'},
        'gitlab': {'key': 'gitlab', 'type': 'AppsGitlabSourceSpec'},
        'image': {'key': 'image', 'type': 'AppsImageSourceSpec'},
        'dockerfile_path': {'key': 'dockerfile_path', 'type': 'str'},
        'build_command': {'key': 'build_command', 'type': 'str'},
        'run_command': {'key': 'run_command', 'type': 'str'},
        'source_dir': {'key': 'source_dir', 'type': 'str'},
        'envs': {'key': 'envs', 'type': '[AppVariableDefinition]'},
        'environment_slug': {'key': 'environment_slug', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        instance_count: Optional[int] = 1,
        instance_size_slug: Optional[Union[str, "_models.AppComponentInstanceBaseInstanceSizeSlug"]] = "basic-xxs",
        name: Optional[str] = None,
        git: Optional["_models.AppsGitSourceSpec"] = None,
        github: Optional["_models.AppsGithubSourceSpec"] = None,
        gitlab: Optional["_models.AppsGitlabSourceSpec"] = None,
        image: Optional["_models.AppsImageSourceSpec"] = None,
        dockerfile_path: Optional[str] = None,
        build_command: Optional[str] = None,
        run_command: Optional[str] = None,
        source_dir: Optional[str] = None,
        envs: Optional[List["_models.AppVariableDefinition"]] = None,
        environment_slug: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword instance_count: The amount of instances that this component should be scaled to.
         Default: 1.
        :paramtype instance_count: long
        :keyword instance_size_slug: The instance size to use for this component. Default:
         ``basic-xxs``. Known values are: "basic-xxs", "basic-xs", "basic-s", "basic-m",
         "professional-xs", "professional-s", "professional-m", "professional-1l", "professional-l",
         "professional-xl". Default value: "basic-xxs".
        :paramtype instance_size_slug: str or
         ~digital_ocean_api.models.AppComponentInstanceBaseInstanceSizeSlug
        :keyword name: The name. Must be unique across all components within the same app.
        :paramtype name: str
        :keyword git:
        :paramtype git: ~digital_ocean_api.models.AppsGitSourceSpec
        :keyword github:
        :paramtype github: ~digital_ocean_api.models.AppsGithubSourceSpec
        :keyword gitlab:
        :paramtype gitlab: ~digital_ocean_api.models.AppsGitlabSourceSpec
        :keyword image:
        :paramtype image: ~digital_ocean_api.models.AppsImageSourceSpec
        :keyword dockerfile_path: The path to the Dockerfile relative to the root of the repo. If set,
         it will be used to build this component. Otherwise, App Platform will attempt to build it using
         buildpacks.
        :paramtype dockerfile_path: str
        :keyword build_command: An optional build command to run while building this component from
         source.
        :paramtype build_command: str
        :keyword run_command: An optional run command to override the component's default.
        :paramtype run_command: str
        :keyword source_dir: An optional path to the working directory to use for the build. For
         Dockerfile builds, this will be used as the build context. Must be relative to the root of the
         repo.
        :paramtype source_dir: str
        :keyword envs: A list of environment variables made available to the component.
        :paramtype envs: list[~digital_ocean_api.models.AppVariableDefinition]
        :keyword environment_slug: An environment slug describing the type of this app. For a full
         list, please refer to `the product documentation
         <https://www.digitalocean.com/docs/app-platform/>`_.
        :paramtype environment_slug: str
        """
        super(AppWorkerSpec, self).__init__(name=name, git=git, github=github, gitlab=gitlab, image=image, dockerfile_path=dockerfile_path, build_command=build_command, run_command=run_command, source_dir=source_dir, envs=envs, environment_slug=environment_slug, instance_count=instance_count, instance_size_slug=instance_size_slug, **kwargs)
        self.instance_count = instance_count
        self.instance_size_slug = instance_size_slug
        self.name = name
        self.git = git
        self.github = github
        self.gitlab = gitlab
        self.image = image
        self.dockerfile_path = dockerfile_path
        self.build_command = build_command
        self.run_command = run_command
        self.source_dir = source_dir
        self.envs = envs
        self.environment_slug = environment_slug


class LoadBalancerBase(msrest.serialization.Model):
    """LoadBalancerBase.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique ID that can be used to identify and reference a load balancer.
    :vartype id: str
    :ivar name: A human-readable name for a load balancer instance.
    :vartype name: str
    :ivar ip: An attribute containing the public-facing IP address of the load balancer.
    :vartype ip: str
    :ivar size_unit: How many nodes the load balancer contains. Each additional node increases the
     load balancer's ability to manage more connections. Load balancers can be scaled up or down,
     and you can change the number of nodes after creation up to once per hour. This field is
     currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
     load balancers that reside in these regions.
    :vartype size_unit: int
    :ivar size: This field has been replaced by the ``size_unit`` field for all regions except in
     AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having
     a set number of nodes.
    
    
     * ``lb-small`` = 1 node
     * ``lb-medium`` = 3 nodes
     * ``lb-large`` = 6 nodes
    
     You can resize load balancers after creation up to once per hour. You cannot resize a load
     balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
     "lb-large". Default value: "lb-small".
    :vartype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
    :ivar algorithm: This field has been deprecated. You can no longer specify an algorithm for
     load balancers. Known values are: "round_robin", "least_connections". Default value:
     "round_robin".
    :vartype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
    :ivar status: A status string indicating the current state of the load balancer. This can be
     ``new``\ , ``active``\ , or ``errored``. Known values are: "new", "active", "errored".
    :vartype status: str or ~digital_ocean_api.models.LoadBalancerBaseStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the load balancer was created.
    :vartype created_at: ~datetime.datetime
    :ivar forwarding_rules: Required. An array of objects specifying the forwarding rules for a
     load balancer.
    :vartype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
    :ivar health_check: An object specifying health check settings for the load balancer.
    :vartype health_check: ~digital_ocean_api.models.HealthCheck
    :ivar sticky_sessions: An object specifying sticky sessions settings for the load balancer.
    :vartype sticky_sessions: ~digital_ocean_api.models.StickySessions
    :ivar redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
     balancer on port 80 will be redirected to HTTPS on port 443.
    :vartype redirect_http_to_https: bool
    :ivar enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
    :vartype enable_proxy_protocol: bool
    :ivar enable_backend_keepalive: A boolean value indicating whether HTTP keepalive connections
     are maintained to target Droplets.
    :vartype enable_backend_keepalive: bool
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is assigned.
    :vartype vpc_uuid: str
    :ivar disable_lets_encrypt_dns_records: A boolean value indicating whether to disable automatic
     DNS record creation for Let's Encrypt certificates that are added to the load balancer.
    :vartype disable_lets_encrypt_dns_records: bool
    """

    _validation = {
        'id': {'readonly': True},
        'ip': {'readonly': True, 'pattern': r'^$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'},
        'size_unit': {'maximum': 100, 'minimum': 1},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'forwarding_rules': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'ip': {'key': 'ip', 'type': 'str'},
        'size_unit': {'key': 'size_unit', 'type': 'int'},
        'size': {'key': 'size', 'type': 'str'},
        'algorithm': {'key': 'algorithm', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'forwarding_rules': {'key': 'forwarding_rules', 'type': '[ForwardingRule]'},
        'health_check': {'key': 'health_check', 'type': 'HealthCheck'},
        'sticky_sessions': {'key': 'sticky_sessions', 'type': 'StickySessions'},
        'redirect_http_to_https': {'key': 'redirect_http_to_https', 'type': 'bool'},
        'enable_proxy_protocol': {'key': 'enable_proxy_protocol', 'type': 'bool'},
        'enable_backend_keepalive': {'key': 'enable_backend_keepalive', 'type': 'bool'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'disable_lets_encrypt_dns_records': {'key': 'disable_lets_encrypt_dns_records', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        forwarding_rules: List["_models.ForwardingRule"],
        name: Optional[str] = None,
        size_unit: Optional[int] = 1,
        size: Optional[Union[str, "_models.LoadBalancerBaseSize"]] = "lb-small",
        algorithm: Optional[Union[str, "_models.LoadBalancerBaseAlgorithm"]] = "round_robin",
        health_check: Optional["_models.HealthCheck"] = None,
        sticky_sessions: Optional["_models.StickySessions"] = None,
        redirect_http_to_https: Optional[bool] = False,
        enable_proxy_protocol: Optional[bool] = False,
        enable_backend_keepalive: Optional[bool] = False,
        vpc_uuid: Optional[str] = None,
        disable_lets_encrypt_dns_records: Optional[bool] = False,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for a load balancer instance.
        :paramtype name: str
        :keyword size_unit: How many nodes the load balancer contains. Each additional node increases
         the load balancer's ability to manage more connections. Load balancers can be scaled up or
         down, and you can change the number of nodes after creation up to once per hour. This field is
         currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
         load balancers that reside in these regions.
        :paramtype size_unit: int
        :keyword size: This field has been replaced by the ``size_unit`` field for all regions except
         in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer
         having a set number of nodes.
        
        
         * ``lb-small`` = 1 node
         * ``lb-medium`` = 3 nodes
         * ``lb-large`` = 6 nodes
        
         You can resize load balancers after creation up to once per hour. You cannot resize a load
         balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
         "lb-large". Default value: "lb-small".
        :paramtype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
        :keyword algorithm: This field has been deprecated. You can no longer specify an algorithm for
         load balancers. Known values are: "round_robin", "least_connections". Default value:
         "round_robin".
        :paramtype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
        :keyword forwarding_rules: Required. An array of objects specifying the forwarding rules for a
         load balancer.
        :paramtype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
        :keyword health_check: An object specifying health check settings for the load balancer.
        :paramtype health_check: ~digital_ocean_api.models.HealthCheck
        :keyword sticky_sessions: An object specifying sticky sessions settings for the load balancer.
        :paramtype sticky_sessions: ~digital_ocean_api.models.StickySessions
        :keyword redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
         balancer on port 80 will be redirected to HTTPS on port 443.
        :paramtype redirect_http_to_https: bool
        :keyword enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
        :paramtype enable_proxy_protocol: bool
        :keyword enable_backend_keepalive: A boolean value indicating whether HTTP keepalive
         connections are maintained to target Droplets.
        :paramtype enable_backend_keepalive: bool
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is
         assigned.
        :paramtype vpc_uuid: str
        :keyword disable_lets_encrypt_dns_records: A boolean value indicating whether to disable
         automatic DNS record creation for Let's Encrypt certificates that are added to the load
         balancer.
        :paramtype disable_lets_encrypt_dns_records: bool
        """
        super(LoadBalancerBase, self).__init__(**kwargs)
        self.id = None
        self.name = name
        self.ip = None
        self.size_unit = size_unit
        self.size = size
        self.algorithm = algorithm
        self.status = None
        self.created_at = None
        self.forwarding_rules = forwarding_rules
        self.health_check = health_check
        self.sticky_sessions = sticky_sessions
        self.redirect_http_to_https = redirect_http_to_https
        self.enable_proxy_protocol = enable_proxy_protocol
        self.enable_backend_keepalive = enable_backend_keepalive
        self.vpc_uuid = vpc_uuid
        self.disable_lets_encrypt_dns_records = disable_lets_encrypt_dns_records


class Components187F1GeSchemasLoadBalancerCreateOneof0Allof1(msrest.serialization.Model):
    """Components187F1GeSchemasLoadBalancerCreateOneof0Allof1.

    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    """

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        **kwargs
    ):
        """
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        """
        super(Components187F1GeSchemasLoadBalancerCreateOneof0Allof1, self).__init__(**kwargs)
        self.region = region


class ComponentsKhgghzSchemasLoadBalancerCreateOneof0Allof0(msrest.serialization.Model):
    """ComponentsKhgghzSchemasLoadBalancerCreateOneof0Allof0.

    :ivar droplet_ids: An array containing the IDs of the Droplets assigned to the load balancer.
    :vartype droplet_ids: list[int]
    """

    _attribute_map = {
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
    }

    def __init__(
        self,
        *,
        droplet_ids: Optional[List[int]] = None,
        **kwargs
    ):
        """
        :keyword droplet_ids: An array containing the IDs of the Droplets assigned to the load
         balancer.
        :paramtype droplet_ids: list[int]
        """
        super(ComponentsKhgghzSchemasLoadBalancerCreateOneof0Allof0, self).__init__(**kwargs)
        self.droplet_ids = droplet_ids


class AssignDropletsByID(ComponentsKhgghzSchemasLoadBalancerCreateOneof0Allof0, Components187F1GeSchemasLoadBalancerCreateOneof0Allof1, LoadBalancerBase):
    """Assign Droplets by ID.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique ID that can be used to identify and reference a load balancer.
    :vartype id: str
    :ivar name: A human-readable name for a load balancer instance.
    :vartype name: str
    :ivar ip: An attribute containing the public-facing IP address of the load balancer.
    :vartype ip: str
    :ivar size_unit: How many nodes the load balancer contains. Each additional node increases the
     load balancer's ability to manage more connections. Load balancers can be scaled up or down,
     and you can change the number of nodes after creation up to once per hour. This field is
     currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
     load balancers that reside in these regions.
    :vartype size_unit: int
    :ivar size: This field has been replaced by the ``size_unit`` field for all regions except in
     AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having
     a set number of nodes.
    
    
     * ``lb-small`` = 1 node
     * ``lb-medium`` = 3 nodes
     * ``lb-large`` = 6 nodes
    
     You can resize load balancers after creation up to once per hour. You cannot resize a load
     balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
     "lb-large". Default value: "lb-small".
    :vartype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
    :ivar algorithm: This field has been deprecated. You can no longer specify an algorithm for
     load balancers. Known values are: "round_robin", "least_connections". Default value:
     "round_robin".
    :vartype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
    :ivar status: A status string indicating the current state of the load balancer. This can be
     ``new``\ , ``active``\ , or ``errored``. Known values are: "new", "active", "errored".
    :vartype status: str or ~digital_ocean_api.models.LoadBalancerBaseStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the load balancer was created.
    :vartype created_at: ~datetime.datetime
    :ivar forwarding_rules: Required. An array of objects specifying the forwarding rules for a
     load balancer.
    :vartype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
    :ivar health_check: An object specifying health check settings for the load balancer.
    :vartype health_check: ~digital_ocean_api.models.HealthCheck
    :ivar sticky_sessions: An object specifying sticky sessions settings for the load balancer.
    :vartype sticky_sessions: ~digital_ocean_api.models.StickySessions
    :ivar redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
     balancer on port 80 will be redirected to HTTPS on port 443.
    :vartype redirect_http_to_https: bool
    :ivar enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
    :vartype enable_proxy_protocol: bool
    :ivar enable_backend_keepalive: A boolean value indicating whether HTTP keepalive connections
     are maintained to target Droplets.
    :vartype enable_backend_keepalive: bool
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is assigned.
    :vartype vpc_uuid: str
    :ivar disable_lets_encrypt_dns_records: A boolean value indicating whether to disable automatic
     DNS record creation for Let's Encrypt certificates that are added to the load balancer.
    :vartype disable_lets_encrypt_dns_records: bool
    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar droplet_ids: An array containing the IDs of the Droplets assigned to the load balancer.
    :vartype droplet_ids: list[int]
    """

    _validation = {
        'id': {'readonly': True},
        'ip': {'readonly': True, 'pattern': r'^$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'},
        'size_unit': {'maximum': 100, 'minimum': 1},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'forwarding_rules': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'ip': {'key': 'ip', 'type': 'str'},
        'size_unit': {'key': 'size_unit', 'type': 'int'},
        'size': {'key': 'size', 'type': 'str'},
        'algorithm': {'key': 'algorithm', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'forwarding_rules': {'key': 'forwarding_rules', 'type': '[ForwardingRule]'},
        'health_check': {'key': 'health_check', 'type': 'HealthCheck'},
        'sticky_sessions': {'key': 'sticky_sessions', 'type': 'StickySessions'},
        'redirect_http_to_https': {'key': 'redirect_http_to_https', 'type': 'bool'},
        'enable_proxy_protocol': {'key': 'enable_proxy_protocol', 'type': 'bool'},
        'enable_backend_keepalive': {'key': 'enable_backend_keepalive', 'type': 'bool'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'disable_lets_encrypt_dns_records': {'key': 'disable_lets_encrypt_dns_records', 'type': 'bool'},
        'region': {'key': 'region', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
    }

    def __init__(
        self,
        *,
        forwarding_rules: List["_models.ForwardingRule"],
        name: Optional[str] = None,
        size_unit: Optional[int] = 1,
        size: Optional[Union[str, "_models.LoadBalancerBaseSize"]] = "lb-small",
        algorithm: Optional[Union[str, "_models.LoadBalancerBaseAlgorithm"]] = "round_robin",
        health_check: Optional["_models.HealthCheck"] = None,
        sticky_sessions: Optional["_models.StickySessions"] = None,
        redirect_http_to_https: Optional[bool] = False,
        enable_proxy_protocol: Optional[bool] = False,
        enable_backend_keepalive: Optional[bool] = False,
        vpc_uuid: Optional[str] = None,
        disable_lets_encrypt_dns_records: Optional[bool] = False,
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        droplet_ids: Optional[List[int]] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for a load balancer instance.
        :paramtype name: str
        :keyword size_unit: How many nodes the load balancer contains. Each additional node increases
         the load balancer's ability to manage more connections. Load balancers can be scaled up or
         down, and you can change the number of nodes after creation up to once per hour. This field is
         currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
         load balancers that reside in these regions.
        :paramtype size_unit: int
        :keyword size: This field has been replaced by the ``size_unit`` field for all regions except
         in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer
         having a set number of nodes.
        
        
         * ``lb-small`` = 1 node
         * ``lb-medium`` = 3 nodes
         * ``lb-large`` = 6 nodes
        
         You can resize load balancers after creation up to once per hour. You cannot resize a load
         balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
         "lb-large". Default value: "lb-small".
        :paramtype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
        :keyword algorithm: This field has been deprecated. You can no longer specify an algorithm for
         load balancers. Known values are: "round_robin", "least_connections". Default value:
         "round_robin".
        :paramtype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
        :keyword forwarding_rules: Required. An array of objects specifying the forwarding rules for a
         load balancer.
        :paramtype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
        :keyword health_check: An object specifying health check settings for the load balancer.
        :paramtype health_check: ~digital_ocean_api.models.HealthCheck
        :keyword sticky_sessions: An object specifying sticky sessions settings for the load balancer.
        :paramtype sticky_sessions: ~digital_ocean_api.models.StickySessions
        :keyword redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
         balancer on port 80 will be redirected to HTTPS on port 443.
        :paramtype redirect_http_to_https: bool
        :keyword enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
        :paramtype enable_proxy_protocol: bool
        :keyword enable_backend_keepalive: A boolean value indicating whether HTTP keepalive
         connections are maintained to target Droplets.
        :paramtype enable_backend_keepalive: bool
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is
         assigned.
        :paramtype vpc_uuid: str
        :keyword disable_lets_encrypt_dns_records: A boolean value indicating whether to disable
         automatic DNS record creation for Let's Encrypt certificates that are added to the load
         balancer.
        :paramtype disable_lets_encrypt_dns_records: bool
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword droplet_ids: An array containing the IDs of the Droplets assigned to the load
         balancer.
        :paramtype droplet_ids: list[int]
        """
        super(AssignDropletsByID, self).__init__(droplet_ids=droplet_ids, region=region, name=name, size_unit=size_unit, size=size, algorithm=algorithm, forwarding_rules=forwarding_rules, health_check=health_check, sticky_sessions=sticky_sessions, redirect_http_to_https=redirect_http_to_https, enable_proxy_protocol=enable_proxy_protocol, enable_backend_keepalive=enable_backend_keepalive, vpc_uuid=vpc_uuid, disable_lets_encrypt_dns_records=disable_lets_encrypt_dns_records, **kwargs)
        self.id = None
        self.name = name
        self.ip = None
        self.size_unit = size_unit
        self.size = size
        self.algorithm = algorithm
        self.status = None
        self.created_at = None
        self.forwarding_rules = forwarding_rules
        self.health_check = health_check
        self.sticky_sessions = sticky_sessions
        self.redirect_http_to_https = redirect_http_to_https
        self.enable_proxy_protocol = enable_proxy_protocol
        self.enable_backend_keepalive = enable_backend_keepalive
        self.vpc_uuid = vpc_uuid
        self.disable_lets_encrypt_dns_records = disable_lets_encrypt_dns_records
        self.region = region
        self.droplet_ids = droplet_ids


class Components71UwbvSchemasLoadBalancerCreateOneof1Allof1(msrest.serialization.Model):
    """Components71UwbvSchemasLoadBalancerCreateOneof1Allof1.

    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    """

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        **kwargs
    ):
        """
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        """
        super(Components71UwbvSchemasLoadBalancerCreateOneof1Allof1, self).__init__(**kwargs)
        self.region = region


class Components1Utru1ASchemasLoadBalancerCreateOneof1Allof0(msrest.serialization.Model):
    """Components1Utru1ASchemasLoadBalancerCreateOneof1Allof0.

    :ivar tag: The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
    :vartype tag: str
    """

    _attribute_map = {
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword tag: The name of a Droplet tag corresponding to Droplets assigned to the load
         balancer.
        :paramtype tag: str
        """
        super(Components1Utru1ASchemasLoadBalancerCreateOneof1Allof0, self).__init__(**kwargs)
        self.tag = tag


class AssignDropletsByTag(LoadBalancerBase, Components1Utru1ASchemasLoadBalancerCreateOneof1Allof0, Components71UwbvSchemasLoadBalancerCreateOneof1Allof1):
    """Assign Droplets by Tag.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar tag: The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
    :vartype tag: str
    :ivar id: A unique ID that can be used to identify and reference a load balancer.
    :vartype id: str
    :ivar name: A human-readable name for a load balancer instance.
    :vartype name: str
    :ivar ip: An attribute containing the public-facing IP address of the load balancer.
    :vartype ip: str
    :ivar size_unit: How many nodes the load balancer contains. Each additional node increases the
     load balancer's ability to manage more connections. Load balancers can be scaled up or down,
     and you can change the number of nodes after creation up to once per hour. This field is
     currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
     load balancers that reside in these regions.
    :vartype size_unit: int
    :ivar size: This field has been replaced by the ``size_unit`` field for all regions except in
     AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having
     a set number of nodes.
    
    
     * ``lb-small`` = 1 node
     * ``lb-medium`` = 3 nodes
     * ``lb-large`` = 6 nodes
    
     You can resize load balancers after creation up to once per hour. You cannot resize a load
     balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
     "lb-large". Default value: "lb-small".
    :vartype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
    :ivar algorithm: This field has been deprecated. You can no longer specify an algorithm for
     load balancers. Known values are: "round_robin", "least_connections". Default value:
     "round_robin".
    :vartype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
    :ivar status: A status string indicating the current state of the load balancer. This can be
     ``new``\ , ``active``\ , or ``errored``. Known values are: "new", "active", "errored".
    :vartype status: str or ~digital_ocean_api.models.LoadBalancerBaseStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the load balancer was created.
    :vartype created_at: ~datetime.datetime
    :ivar forwarding_rules: Required. An array of objects specifying the forwarding rules for a
     load balancer.
    :vartype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
    :ivar health_check: An object specifying health check settings for the load balancer.
    :vartype health_check: ~digital_ocean_api.models.HealthCheck
    :ivar sticky_sessions: An object specifying sticky sessions settings for the load balancer.
    :vartype sticky_sessions: ~digital_ocean_api.models.StickySessions
    :ivar redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
     balancer on port 80 will be redirected to HTTPS on port 443.
    :vartype redirect_http_to_https: bool
    :ivar enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
    :vartype enable_proxy_protocol: bool
    :ivar enable_backend_keepalive: A boolean value indicating whether HTTP keepalive connections
     are maintained to target Droplets.
    :vartype enable_backend_keepalive: bool
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is assigned.
    :vartype vpc_uuid: str
    :ivar disable_lets_encrypt_dns_records: A boolean value indicating whether to disable automatic
     DNS record creation for Let's Encrypt certificates that are added to the load balancer.
    :vartype disable_lets_encrypt_dns_records: bool
    """

    _validation = {
        'id': {'readonly': True},
        'ip': {'readonly': True, 'pattern': r'^$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'},
        'size_unit': {'maximum': 100, 'minimum': 1},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'forwarding_rules': {'required': True},
    }

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
        'tag': {'key': 'tag', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'ip': {'key': 'ip', 'type': 'str'},
        'size_unit': {'key': 'size_unit', 'type': 'int'},
        'size': {'key': 'size', 'type': 'str'},
        'algorithm': {'key': 'algorithm', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'forwarding_rules': {'key': 'forwarding_rules', 'type': '[ForwardingRule]'},
        'health_check': {'key': 'health_check', 'type': 'HealthCheck'},
        'sticky_sessions': {'key': 'sticky_sessions', 'type': 'StickySessions'},
        'redirect_http_to_https': {'key': 'redirect_http_to_https', 'type': 'bool'},
        'enable_proxy_protocol': {'key': 'enable_proxy_protocol', 'type': 'bool'},
        'enable_backend_keepalive': {'key': 'enable_backend_keepalive', 'type': 'bool'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'disable_lets_encrypt_dns_records': {'key': 'disable_lets_encrypt_dns_records', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        forwarding_rules: List["_models.ForwardingRule"],
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        tag: Optional[str] = None,
        name: Optional[str] = None,
        size_unit: Optional[int] = 1,
        size: Optional[Union[str, "_models.LoadBalancerBaseSize"]] = "lb-small",
        algorithm: Optional[Union[str, "_models.LoadBalancerBaseAlgorithm"]] = "round_robin",
        health_check: Optional["_models.HealthCheck"] = None,
        sticky_sessions: Optional["_models.StickySessions"] = None,
        redirect_http_to_https: Optional[bool] = False,
        enable_proxy_protocol: Optional[bool] = False,
        enable_backend_keepalive: Optional[bool] = False,
        vpc_uuid: Optional[str] = None,
        disable_lets_encrypt_dns_records: Optional[bool] = False,
        **kwargs
    ):
        """
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword tag: The name of a Droplet tag corresponding to Droplets assigned to the load
         balancer.
        :paramtype tag: str
        :keyword name: A human-readable name for a load balancer instance.
        :paramtype name: str
        :keyword size_unit: How many nodes the load balancer contains. Each additional node increases
         the load balancer's ability to manage more connections. Load balancers can be scaled up or
         down, and you can change the number of nodes after creation up to once per hour. This field is
         currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
         load balancers that reside in these regions.
        :paramtype size_unit: int
        :keyword size: This field has been replaced by the ``size_unit`` field for all regions except
         in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer
         having a set number of nodes.
        
        
         * ``lb-small`` = 1 node
         * ``lb-medium`` = 3 nodes
         * ``lb-large`` = 6 nodes
        
         You can resize load balancers after creation up to once per hour. You cannot resize a load
         balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
         "lb-large". Default value: "lb-small".
        :paramtype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
        :keyword algorithm: This field has been deprecated. You can no longer specify an algorithm for
         load balancers. Known values are: "round_robin", "least_connections". Default value:
         "round_robin".
        :paramtype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
        :keyword forwarding_rules: Required. An array of objects specifying the forwarding rules for a
         load balancer.
        :paramtype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
        :keyword health_check: An object specifying health check settings for the load balancer.
        :paramtype health_check: ~digital_ocean_api.models.HealthCheck
        :keyword sticky_sessions: An object specifying sticky sessions settings for the load balancer.
        :paramtype sticky_sessions: ~digital_ocean_api.models.StickySessions
        :keyword redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
         balancer on port 80 will be redirected to HTTPS on port 443.
        :paramtype redirect_http_to_https: bool
        :keyword enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
        :paramtype enable_proxy_protocol: bool
        :keyword enable_backend_keepalive: A boolean value indicating whether HTTP keepalive
         connections are maintained to target Droplets.
        :paramtype enable_backend_keepalive: bool
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is
         assigned.
        :paramtype vpc_uuid: str
        :keyword disable_lets_encrypt_dns_records: A boolean value indicating whether to disable
         automatic DNS record creation for Let's Encrypt certificates that are added to the load
         balancer.
        :paramtype disable_lets_encrypt_dns_records: bool
        """
        super(AssignDropletsByTag, self).__init__(name=name, size_unit=size_unit, size=size, algorithm=algorithm, forwarding_rules=forwarding_rules, health_check=health_check, sticky_sessions=sticky_sessions, redirect_http_to_https=redirect_http_to_https, enable_proxy_protocol=enable_proxy_protocol, enable_backend_keepalive=enable_backend_keepalive, vpc_uuid=vpc_uuid, disable_lets_encrypt_dns_records=disable_lets_encrypt_dns_records, tag=tag, region=region, **kwargs)
        self.region = region
        self.tag = tag
        self.id = None
        self.name = name
        self.ip = None
        self.size_unit = size_unit
        self.size = size
        self.algorithm = algorithm
        self.status = None
        self.created_at = None
        self.forwarding_rules = forwarding_rules
        self.health_check = health_check
        self.sticky_sessions = sticky_sessions
        self.redirect_http_to_https = redirect_http_to_https
        self.enable_proxy_protocol = enable_proxy_protocol
        self.enable_backend_keepalive = enable_backend_keepalive
        self.vpc_uuid = vpc_uuid
        self.disable_lets_encrypt_dns_records = disable_lets_encrypt_dns_records


class AssignToDroplet(msrest.serialization.Model):
    """Assign to Droplet.

    All required parameters must be populated in order to send to Azure.

    :ivar droplet_id: Required. The ID of the Droplet that the floating IP will be assigned to.
    :vartype droplet_id: int
    """

    _validation = {
        'droplet_id': {'required': True},
    }

    _attribute_map = {
        'droplet_id': {'key': 'droplet_id', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        droplet_id: int,
        **kwargs
    ):
        """
        :keyword droplet_id: Required. The ID of the Droplet that the floating IP will be assigned to.
        :paramtype droplet_id: int
        """
        super(AssignToDroplet, self).__init__(**kwargs)
        self.droplet_id = droplet_id


class AssociatedKubernetesResource(msrest.serialization.Model):
    """AssociatedKubernetesResource.

    :ivar id: The ID of a resource associated with a Kubernetes cluster.
    :vartype id: str
    :ivar name: The name of a resource associated with a Kubernetes cluster.
    :vartype name: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: The ID of a resource associated with a Kubernetes cluster.
        :paramtype id: str
        :keyword name: The name of a resource associated with a Kubernetes cluster.
        :paramtype name: str
        """
        super(AssociatedKubernetesResource, self).__init__(**kwargs)
        self.id = id
        self.name = name


class AssociatedKubernetesResources(msrest.serialization.Model):
    """An object containing the IDs of resources associated with a Kubernetes cluster.

    :ivar load_balancers: A list of names and IDs for associated load balancers that can be
     destroyed along with the cluster.
    :vartype load_balancers: list[~digital_ocean_api.models.AssociatedKubernetesResource]
    :ivar volumes: A list of names and IDs for associated volumes that can be destroyed along with
     the cluster.
    :vartype volumes: list[~digital_ocean_api.models.AssociatedKubernetesResource]
    :ivar volume_snapshots: A list of names and IDs for associated volume snapshots that can be
     destroyed along with the cluster.
    :vartype volume_snapshots: list[~digital_ocean_api.models.AssociatedKubernetesResource]
    """

    _attribute_map = {
        'load_balancers': {'key': 'load_balancers', 'type': '[AssociatedKubernetesResource]'},
        'volumes': {'key': 'volumes', 'type': '[AssociatedKubernetesResource]'},
        'volume_snapshots': {'key': 'volume_snapshots', 'type': '[AssociatedKubernetesResource]'},
    }

    def __init__(
        self,
        *,
        load_balancers: Optional[List["_models.AssociatedKubernetesResource"]] = None,
        volumes: Optional[List["_models.AssociatedKubernetesResource"]] = None,
        volume_snapshots: Optional[List["_models.AssociatedKubernetesResource"]] = None,
        **kwargs
    ):
        """
        :keyword load_balancers: A list of names and IDs for associated load balancers that can be
         destroyed along with the cluster.
        :paramtype load_balancers: list[~digital_ocean_api.models.AssociatedKubernetesResource]
        :keyword volumes: A list of names and IDs for associated volumes that can be destroyed along
         with the cluster.
        :paramtype volumes: list[~digital_ocean_api.models.AssociatedKubernetesResource]
        :keyword volume_snapshots: A list of names and IDs for associated volume snapshots that can be
         destroyed along with the cluster.
        :paramtype volume_snapshots: list[~digital_ocean_api.models.AssociatedKubernetesResource]
        """
        super(AssociatedKubernetesResources, self).__init__(**kwargs)
        self.load_balancers = load_balancers
        self.volumes = volumes
        self.volume_snapshots = volume_snapshots


class AssociatedResource(msrest.serialization.Model):
    """An objects containing information about a resource associated with a Droplet.

    :ivar id: The unique identifier for the resource associated with the Droplet.
    :vartype id: str
    :ivar name: The name of the resource associated with the Droplet.
    :vartype name: str
    :ivar cost: The cost of the resource in USD per month if the resource is retained after the
     Droplet is destroyed.
    :vartype cost: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'cost': {'key': 'cost', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        cost: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: The unique identifier for the resource associated with the Droplet.
        :paramtype id: str
        :keyword name: The name of the resource associated with the Droplet.
        :paramtype name: str
        :keyword cost: The cost of the resource in USD per month if the resource is retained after the
         Droplet is destroyed.
        :paramtype cost: str
        """
        super(AssociatedResource, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.cost = cost


class AssociatedResourceStatus(msrest.serialization.Model):
    """An objects containing information about a resources scheduled for deletion.

    :ivar droplet: An object containing information about a resource scheduled for deletion.
    :vartype droplet: ~digital_ocean_api.models.DestroyedAssociatedResource
    :ivar resources: An object containing additional information about resource related to a
     Droplet requested to be destroyed.
    :vartype resources: ~digital_ocean_api.models.AssociatedResourceStatusResources
    :ivar completed_at: A time value given in ISO8601 combined date and time format indicating when
     the requested action was completed.
    :vartype completed_at: ~datetime.datetime
    :ivar failures: A count of the associated resources that failed to be destroyed, if any.
    :vartype failures: int
    """

    _attribute_map = {
        'droplet': {'key': 'droplet', 'type': 'DestroyedAssociatedResource'},
        'resources': {'key': 'resources', 'type': 'AssociatedResourceStatusResources'},
        'completed_at': {'key': 'completed_at', 'type': 'iso-8601'},
        'failures': {'key': 'failures', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        droplet: Optional["_models.DestroyedAssociatedResource"] = None,
        resources: Optional["_models.AssociatedResourceStatusResources"] = None,
        completed_at: Optional[datetime.datetime] = None,
        failures: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword droplet: An object containing information about a resource scheduled for deletion.
        :paramtype droplet: ~digital_ocean_api.models.DestroyedAssociatedResource
        :keyword resources: An object containing additional information about resource related to a
         Droplet requested to be destroyed.
        :paramtype resources: ~digital_ocean_api.models.AssociatedResourceStatusResources
        :keyword completed_at: A time value given in ISO8601 combined date and time format indicating
         when the requested action was completed.
        :paramtype completed_at: ~datetime.datetime
        :keyword failures: A count of the associated resources that failed to be destroyed, if any.
        :paramtype failures: int
        """
        super(AssociatedResourceStatus, self).__init__(**kwargs)
        self.droplet = droplet
        self.resources = resources
        self.completed_at = completed_at
        self.failures = failures


class AssociatedResourceStatusResources(msrest.serialization.Model):
    """An object containing additional information about resource related to a Droplet requested to be destroyed.

    :ivar floating_ips:
    :vartype floating_ips: list[~digital_ocean_api.models.DestroyedAssociatedResource]
    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.DestroyedAssociatedResource]
    :ivar volumes:
    :vartype volumes: list[~digital_ocean_api.models.DestroyedAssociatedResource]
    :ivar volume_snapshots:
    :vartype volume_snapshots: list[~digital_ocean_api.models.DestroyedAssociatedResource]
    """

    _attribute_map = {
        'floating_ips': {'key': 'floating_ips', 'type': '[DestroyedAssociatedResource]'},
        'snapshots': {'key': 'snapshots', 'type': '[DestroyedAssociatedResource]'},
        'volumes': {'key': 'volumes', 'type': '[DestroyedAssociatedResource]'},
        'volume_snapshots': {'key': 'volume_snapshots', 'type': '[DestroyedAssociatedResource]'},
    }

    def __init__(
        self,
        *,
        floating_ips: Optional[List["_models.DestroyedAssociatedResource"]] = None,
        snapshots: Optional[List["_models.DestroyedAssociatedResource"]] = None,
        volumes: Optional[List["_models.DestroyedAssociatedResource"]] = None,
        volume_snapshots: Optional[List["_models.DestroyedAssociatedResource"]] = None,
        **kwargs
    ):
        """
        :keyword floating_ips:
        :paramtype floating_ips: list[~digital_ocean_api.models.DestroyedAssociatedResource]
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.DestroyedAssociatedResource]
        :keyword volumes:
        :paramtype volumes: list[~digital_ocean_api.models.DestroyedAssociatedResource]
        :keyword volume_snapshots:
        :paramtype volume_snapshots: list[~digital_ocean_api.models.DestroyedAssociatedResource]
        """
        super(AssociatedResourceStatusResources, self).__init__(**kwargs)
        self.floating_ips = floating_ips
        self.snapshots = snapshots
        self.volumes = volumes
        self.volume_snapshots = volume_snapshots


class Backup(msrest.serialization.Model):
    """Backup.

    All required parameters must be populated in order to send to Azure.

    :ivar created_at: Required. A time value given in ISO8601 combined date and time format at
     which the backup was created.
    :vartype created_at: ~datetime.datetime
    :ivar size_gigabytes: Required. The size of the database backup in GBs.
    :vartype size_gigabytes: float
    """

    _validation = {
        'created_at': {'required': True},
        'size_gigabytes': {'required': True},
    }

    _attribute_map = {
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        created_at: datetime.datetime,
        size_gigabytes: float,
        **kwargs
    ):
        """
        :keyword created_at: Required. A time value given in ISO8601 combined date and time format at
         which the backup was created.
        :paramtype created_at: ~datetime.datetime
        :keyword size_gigabytes: Required. The size of the database backup in GBs.
        :paramtype size_gigabytes: float
        """
        super(Backup, self).__init__(**kwargs)
        self.created_at = created_at
        self.size_gigabytes = size_gigabytes


class LinkToPrevPage(msrest.serialization.Model):
    """LinkToPrevPage.

    :ivar prev: URI of the previous page of the results.
    :vartype prev: str
    """

    _attribute_map = {
        'prev': {'key': 'prev', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        prev: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword prev: URI of the previous page of the results.
        :paramtype prev: str
        """
        super(LinkToPrevPage, self).__init__(**kwargs)
        self.prev = prev


class LinkToFirstPage(msrest.serialization.Model):
    """LinkToFirstPage.

    :ivar first: URI of the first page of the results.
    :vartype first: str
    """

    _attribute_map = {
        'first': {'key': 'first', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        first: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword first: URI of the first page of the results.
        :paramtype first: str
        """
        super(LinkToFirstPage, self).__init__(**kwargs)
        self.first = first


class BackwardLinks(LinkToFirstPage, LinkToPrevPage):
    """BackwardLinks.

    :ivar prev: URI of the previous page of the results.
    :vartype prev: str
    :ivar first: URI of the first page of the results.
    :vartype first: str
    """

    _attribute_map = {
        'prev': {'key': 'prev', 'type': 'str'},
        'first': {'key': 'first', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        prev: Optional[str] = None,
        first: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword prev: URI of the previous page of the results.
        :paramtype prev: str
        :keyword first: URI of the first page of the results.
        :paramtype first: str
        """
        super(BackwardLinks, self).__init__(first=first, prev=prev, **kwargs)
        self.prev = prev
        self.first = first


class Balance(msrest.serialization.Model):
    """Balance.

    :ivar month_to_date_balance: Balance as of the ``generated_at`` time.  This value includes the
     ``account_balance`` and ``month_to_date_usage``.
    :vartype month_to_date_balance: str
    :ivar account_balance: Current balance of the customer's most recent billing activity.  Does
     not reflect ``month_to_date_usage``.
    :vartype account_balance: str
    :ivar month_to_date_usage: Amount used in the current billing period as of the ``generated_at``
     time.
    :vartype month_to_date_usage: str
    :ivar generated_at: The time at which balances were most recently generated.
    :vartype generated_at: ~datetime.datetime
    """

    _attribute_map = {
        'month_to_date_balance': {'key': 'month_to_date_balance', 'type': 'str'},
        'account_balance': {'key': 'account_balance', 'type': 'str'},
        'month_to_date_usage': {'key': 'month_to_date_usage', 'type': 'str'},
        'generated_at': {'key': 'generated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        month_to_date_balance: Optional[str] = None,
        account_balance: Optional[str] = None,
        month_to_date_usage: Optional[str] = None,
        generated_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword month_to_date_balance: Balance as of the ``generated_at`` time.  This value includes
         the ``account_balance`` and ``month_to_date_usage``.
        :paramtype month_to_date_balance: str
        :keyword account_balance: Current balance of the customer's most recent billing activity.  Does
         not reflect ``month_to_date_usage``.
        :paramtype account_balance: str
        :keyword month_to_date_usage: Amount used in the current billing period as of the
         ``generated_at`` time.
        :paramtype month_to_date_usage: str
        :keyword generated_at: The time at which balances were most recently generated.
        :paramtype generated_at: ~datetime.datetime
        """
        super(Balance, self).__init__(**kwargs)
        self.month_to_date_balance = month_to_date_balance
        self.account_balance = account_balance
        self.month_to_date_usage = month_to_date_usage
        self.generated_at = generated_at


class BillingAddress(msrest.serialization.Model):
    """BillingAddress.

    :ivar address_line1: Street address line 1.
    :vartype address_line1: str
    :ivar address_line2: Street address line 2.
    :vartype address_line2: str
    :ivar city: City.
    :vartype city: str
    :ivar region: Region.
    :vartype region: str
    :ivar postal_code: Postal code.
    :vartype postal_code: str
    :ivar country_iso2_code: Country (ISO2) code.
    :vartype country_iso2_code: str
    :ivar created_at: Timestamp billing address was created.
    :vartype created_at: str
    :ivar updated_at: Timestamp billing address was updated.
    :vartype updated_at: str
    """

    _attribute_map = {
        'address_line1': {'key': 'address_line1', 'type': 'str'},
        'address_line2': {'key': 'address_line2', 'type': 'str'},
        'city': {'key': 'city', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'postal_code': {'key': 'postal_code', 'type': 'str'},
        'country_iso2_code': {'key': 'country_iso2_code', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'str'},
        'updated_at': {'key': 'updated_at', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address_line1: Optional[str] = None,
        address_line2: Optional[str] = None,
        city: Optional[str] = None,
        region: Optional[str] = None,
        postal_code: Optional[str] = None,
        country_iso2_code: Optional[str] = None,
        created_at: Optional[str] = None,
        updated_at: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address_line1: Street address line 1.
        :paramtype address_line1: str
        :keyword address_line2: Street address line 2.
        :paramtype address_line2: str
        :keyword city: City.
        :paramtype city: str
        :keyword region: Region.
        :paramtype region: str
        :keyword postal_code: Postal code.
        :paramtype postal_code: str
        :keyword country_iso2_code: Country (ISO2) code.
        :paramtype country_iso2_code: str
        :keyword created_at: Timestamp billing address was created.
        :paramtype created_at: str
        :keyword updated_at: Timestamp billing address was updated.
        :paramtype updated_at: str
        """
        super(BillingAddress, self).__init__(**kwargs)
        self.address_line1 = address_line1
        self.address_line2 = address_line2
        self.city = city
        self.region = region
        self.postal_code = postal_code
        self.country_iso2_code = country_iso2_code
        self.created_at = created_at
        self.updated_at = updated_at


class BillingHistory(msrest.serialization.Model):
    """BillingHistory.

    :ivar description: Description of the billing history entry.
    :vartype description: str
    :ivar amount: Amount of the billing history entry.
    :vartype amount: str
    :ivar invoice_id: ID of the invoice associated with the billing history entry, if  applicable.
    :vartype invoice_id: str
    :ivar invoice_uuid: UUID of the invoice associated with the billing history entry, if
     applicable.
    :vartype invoice_uuid: str
    :ivar date: Time the billing history entry occured.
    :vartype date: ~datetime.datetime
    :ivar type: Type of billing history entry. Known values are: "ACHFailure", "Adjustment",
     "AttemptFailed", "Chargeback", "Credit", "CreditExpiration", "Invoice", "Payment", "Refund",
     "Reversal".
    :vartype type: str or ~digital_ocean_api.models.BillingHistoryType
    """

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
        'invoice_id': {'key': 'invoice_id', 'type': 'str'},
        'invoice_uuid': {'key': 'invoice_uuid', 'type': 'str'},
        'date': {'key': 'date', 'type': 'iso-8601'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        description: Optional[str] = None,
        amount: Optional[str] = None,
        invoice_id: Optional[str] = None,
        invoice_uuid: Optional[str] = None,
        date: Optional[datetime.datetime] = None,
        type: Optional[Union[str, "_models.BillingHistoryType"]] = None,
        **kwargs
    ):
        """
        :keyword description: Description of the billing history entry.
        :paramtype description: str
        :keyword amount: Amount of the billing history entry.
        :paramtype amount: str
        :keyword invoice_id: ID of the invoice associated with the billing history entry, if
         applicable.
        :paramtype invoice_id: str
        :keyword invoice_uuid: UUID of the invoice associated with the billing history entry, if
         applicable.
        :paramtype invoice_uuid: str
        :keyword date: Time the billing history entry occured.
        :paramtype date: ~datetime.datetime
        :keyword type: Type of billing history entry. Known values are: "ACHFailure", "Adjustment",
         "AttemptFailed", "Chargeback", "Credit", "CreditExpiration", "Invoice", "Payment", "Refund",
         "Reversal".
        :paramtype type: str or ~digital_ocean_api.models.BillingHistoryType
        """
        super(BillingHistory, self).__init__(**kwargs)
        self.description = description
        self.amount = amount
        self.invoice_id = invoice_id
        self.invoice_uuid = invoice_uuid
        self.date = date
        self.type = type


class Ca(msrest.serialization.Model):
    """Ca.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar certificate: Required. base64 encoding of the certificate used to secure database
     connections.
    :vartype certificate: str
    """

    _validation = {
        'certificate': {'required': True, 'readonly': True},
    }

    _attribute_map = {
        'certificate': {'key': 'certificate', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(Ca, self).__init__(**kwargs)
        self.certificate = None


class CdnEndpoint(msrest.serialization.Model):
    """CdnEndpoint.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique ID that can be used to identify and reference a CDN endpoint.
    :vartype id: str
    :ivar origin: Required. The fully qualified domain name (FQDN) for the origin server which
     provides the content for the CDN. This is currently restricted to a Space.
    :vartype origin: str
    :ivar endpoint: The fully qualified domain name (FQDN) from which the CDN-backed content is
     served.
    :vartype endpoint: str
    :ivar ttl: The amount of time the content is cached by the CDN's edge servers in seconds. TTL
     must be one of 60, 600, 3600, 86400, or 604800. Defaults to 3600 (one hour) when excluded.
     Known values are: 60, 600, 3600, 86400, 604800. Default value: "3600".
    :vartype ttl: int or ~digital_ocean_api.models.CdnEndpointTtl
    :ivar certificate_id: The ID of a DigitalOcean managed TLS certificate used for SSL when a
     custom subdomain is provided.
    :vartype certificate_id: str
    :ivar custom_domain: The fully qualified domain name (FQDN) of the custom subdomain used with
     the CDN endpoint.
    :vartype custom_domain: str
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the CDN endpoint was created.
    :vartype created_at: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'origin': {'required': True},
        'endpoint': {'readonly': True},
        'created_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'origin': {'key': 'origin', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'certificate_id': {'key': 'certificate_id', 'type': 'str'},
        'custom_domain': {'key': 'custom_domain', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        origin: str,
        ttl: Optional[Union[int, "_models.CdnEndpointTtl"]] = 3600,
        certificate_id: Optional[str] = None,
        custom_domain: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword origin: Required. The fully qualified domain name (FQDN) for the origin server which
         provides the content for the CDN. This is currently restricted to a Space.
        :paramtype origin: str
        :keyword ttl: The amount of time the content is cached by the CDN's edge servers in seconds.
         TTL must be one of 60, 600, 3600, 86400, or 604800. Defaults to 3600 (one hour) when excluded.
         Known values are: 60, 600, 3600, 86400, 604800. Default value: "3600".
        :paramtype ttl: int or ~digital_ocean_api.models.CdnEndpointTtl
        :keyword certificate_id: The ID of a DigitalOcean managed TLS certificate used for SSL when a
         custom subdomain is provided.
        :paramtype certificate_id: str
        :keyword custom_domain: The fully qualified domain name (FQDN) of the custom subdomain used
         with the CDN endpoint.
        :paramtype custom_domain: str
        """
        super(CdnEndpoint, self).__init__(**kwargs)
        self.id = None
        self.origin = origin
        self.endpoint = None
        self.ttl = ttl
        self.certificate_id = certificate_id
        self.custom_domain = custom_domain
        self.created_at = None


class Certificate(msrest.serialization.Model):
    """Certificate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A unique ID that can be used to identify and reference a certificate.
    :vartype id: str
    :ivar name: A unique human-readable name referring to a certificate.
    :vartype name: str
    :ivar not_after: A time value given in ISO8601 combined date and time format that represents
     the certificate's expiration date.
    :vartype not_after: ~datetime.datetime
    :ivar sha1_fingerprint: A unique identifier generated from the SHA-1 fingerprint of the
     certificate.
    :vartype sha1_fingerprint: str
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the certificate was created.
    :vartype created_at: ~datetime.datetime
    :ivar dns_names: An array of fully qualified domain names (FQDNs) for which the certificate was
     issued.
    :vartype dns_names: list[str]
    :ivar state: A string representing the current state of the certificate. It may be ``pending``\
     , ``verified``\ , or ``error``. Known values are: "pending", "verified", "error".
    :vartype state: str or ~digital_ocean_api.models.CertificateState
    :ivar type: A string representing the type of the certificate. The value will be ``custom`` for
     a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
     Encrypt. Known values are: "custom", "lets_encrypt".
    :vartype type: str or ~digital_ocean_api.models.CertificateType
    """

    _validation = {
        'id': {'readonly': True},
        'not_after': {'readonly': True},
        'sha1_fingerprint': {'readonly': True},
        'created_at': {'readonly': True},
        'state': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'not_after': {'key': 'not_after', 'type': 'iso-8601'},
        'sha1_fingerprint': {'key': 'sha1_fingerprint', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'dns_names': {'key': 'dns_names', 'type': '[str]'},
        'state': {'key': 'state', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        dns_names: Optional[List[str]] = None,
        type: Optional[Union[str, "_models.CertificateType"]] = None,
        **kwargs
    ):
        """
        :keyword name: A unique human-readable name referring to a certificate.
        :paramtype name: str
        :keyword dns_names: An array of fully qualified domain names (FQDNs) for which the certificate
         was issued.
        :paramtype dns_names: list[str]
        :keyword type: A string representing the type of the certificate. The value will be ``custom``
         for a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
         Encrypt. Known values are: "custom", "lets_encrypt".
        :paramtype type: str or ~digital_ocean_api.models.CertificateType
        """
        super(Certificate, self).__init__(**kwargs)
        self.id = None
        self.name = name
        self.not_after = None
        self.sha1_fingerprint = None
        self.created_at = None
        self.dns_names = dns_names
        self.state = None
        self.type = type


class CertificateCreateBase(msrest.serialization.Model):
    """CertificateCreateBase.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A unique human-readable name referring to a certificate.
    :vartype name: str
    :ivar type: A string representing the type of the certificate. The value will be ``custom`` for
     a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
     Encrypt. Known values are: "custom", "lets_encrypt".
    :vartype type: str or ~digital_ocean_api.models.CertificateCreateBaseType
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        type: Optional[Union[str, "_models.CertificateCreateBaseType"]] = None,
        **kwargs
    ):
        """
        :keyword name: Required. A unique human-readable name referring to a certificate.
        :paramtype name: str
        :keyword type: A string representing the type of the certificate. The value will be ``custom``
         for a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
         Encrypt. Known values are: "custom", "lets_encrypt".
        :paramtype type: str or ~digital_ocean_api.models.CertificateCreateBaseType
        """
        super(CertificateCreateBase, self).__init__(**kwargs)
        self.name = name
        self.type = type


class CertificateRequestCustom(CertificateCreateBase):
    """Custom Certificate Request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A unique human-readable name referring to a certificate.
    :vartype name: str
    :ivar type: A string representing the type of the certificate. The value will be ``custom`` for
     a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
     Encrypt. Known values are: "custom", "lets_encrypt".
    :vartype type: str or ~digital_ocean_api.models.CertificateCreateBaseType
    :ivar private_key: Required. The contents of a PEM-formatted private-key corresponding to the
     SSL certificate.
    :vartype private_key: str
    :ivar leaf_certificate: Required. The contents of a PEM-formatted public SSL certificate.
    :vartype leaf_certificate: str
    :ivar certificate_chain: The full PEM-formatted trust chain between the certificate authority's
     certificate and your domain's SSL certificate.
    :vartype certificate_chain: str
    """

    _validation = {
        'name': {'required': True},
        'private_key': {'required': True},
        'leaf_certificate': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'private_key': {'key': 'private_key', 'type': 'str'},
        'leaf_certificate': {'key': 'leaf_certificate', 'type': 'str'},
        'certificate_chain': {'key': 'certificate_chain', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        private_key: str,
        leaf_certificate: str,
        type: Optional[Union[str, "_models.CertificateCreateBaseType"]] = None,
        certificate_chain: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: Required. A unique human-readable name referring to a certificate.
        :paramtype name: str
        :keyword type: A string representing the type of the certificate. The value will be ``custom``
         for a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
         Encrypt. Known values are: "custom", "lets_encrypt".
        :paramtype type: str or ~digital_ocean_api.models.CertificateCreateBaseType
        :keyword private_key: Required. The contents of a PEM-formatted private-key corresponding to
         the SSL certificate.
        :paramtype private_key: str
        :keyword leaf_certificate: Required. The contents of a PEM-formatted public SSL certificate.
        :paramtype leaf_certificate: str
        :keyword certificate_chain: The full PEM-formatted trust chain between the certificate
         authority's certificate and your domain's SSL certificate.
        :paramtype certificate_chain: str
        """
        super(CertificateRequestCustom, self).__init__(name=name, type=type, **kwargs)
        self.private_key = private_key
        self.leaf_certificate = leaf_certificate
        self.certificate_chain = certificate_chain


class CertificateRequestLetsEncrypt(CertificateCreateBase):
    """Let's Encrypt Certificate Request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A unique human-readable name referring to a certificate.
    :vartype name: str
    :ivar type: A string representing the type of the certificate. The value will be ``custom`` for
     a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
     Encrypt. Known values are: "custom", "lets_encrypt".
    :vartype type: str or ~digital_ocean_api.models.CertificateCreateBaseType
    :ivar dns_names: Required. An array of fully qualified domain names (FQDNs) for which the
     certificate was issued. A certificate covering all subdomains can be issued using a wildcard
     (e.g. ``*.example.com``\ ).
    :vartype dns_names: list[str]
    """

    _validation = {
        'name': {'required': True},
        'dns_names': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'dns_names': {'key': 'dns_names', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        name: str,
        dns_names: List[str],
        type: Optional[Union[str, "_models.CertificateCreateBaseType"]] = None,
        **kwargs
    ):
        """
        :keyword name: Required. A unique human-readable name referring to a certificate.
        :paramtype name: str
        :keyword type: A string representing the type of the certificate. The value will be ``custom``
         for a user-uploaded certificate or ``lets_encrypt`` for one automatically generated with Let's
         Encrypt. Known values are: "custom", "lets_encrypt".
        :paramtype type: str or ~digital_ocean_api.models.CertificateCreateBaseType
        :keyword dns_names: Required. An array of fully qualified domain names (FQDNs) for which the
         certificate was issued. A certificate covering all subdomains can be issued using a wildcard
         (e.g. ``*.example.com``\ ).
        :paramtype dns_names: list[str]
        """
        super(CertificateRequestLetsEncrypt, self).__init__(name=name, type=type, **kwargs)
        self.dns_names = dns_names


class Cluster(msrest.serialization.Model):
    """Cluster.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique ID that can be used to identify and reference a Kubernetes cluster.
    :vartype id: str
    :ivar name: Required. A human-readable name for a Kubernetes cluster.
    :vartype name: str
    :ivar region: Required. The slug identifier for the region where the Kubernetes cluster is
     located.
    :vartype region: str
    :ivar version: Required. The slug identifier for the version of Kubernetes used for the
     cluster. If set to a minor version (e.g. "1.14"), the latest version within it will be used
     (e.g. "1.14.6-do.1"); if set to "latest", the latest published version will be used. See the
     ``/v2/kubernetes/options`` endpoint to find all currently available versions.
    :vartype version: str
    :ivar cluster_subnet: The range of IP addresses in the overlay network of the Kubernetes
     cluster in CIDR notation.
    :vartype cluster_subnet: str
    :ivar service_subnet: The range of assignable IP addresses for services running in the
     Kubernetes cluster in CIDR notation.
    :vartype service_subnet: str
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the Kubernetes cluster is
     assigned.
    :vartype vpc_uuid: str
    :ivar ipv4: The public IPv4 address of the Kubernetes master node. This will not be set if high
     availability is configured on the cluster (v1.21+).
    :vartype ipv4: str
    :ivar endpoint: The base URL of the API server on the Kubernetes master node.
    :vartype endpoint: str
    :ivar tags: A set of tags. An array of tags applied to the Kubernetes cluster. All clusters are
     automatically tagged ``k8s`` and ``k8s:$K8S_CLUSTER_ID``.
    :vartype tags: list[str]
    :ivar node_pools: Required. An object specifying the details of the worker nodes available to
     the Kubernetes cluster.
    :vartype node_pools: list[~digital_ocean_api.models.KubernetesNodePool]
    :ivar maintenance_policy: An object specifying the maintenance window policy for the Kubernetes
     cluster.
    :vartype maintenance_policy: ~digital_ocean_api.models.MaintenancePolicy
    :ivar auto_upgrade: A boolean value indicating whether the cluster will be automatically
     upgraded to new patch releases during its maintenance window.
    :vartype auto_upgrade: bool
    :ivar status: An object containing a ``state`` attribute whose value is set to a string
     indicating the current status of the cluster.
    :vartype status: ~digital_ocean_api.models.ClusterStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the Kubernetes cluster was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: A time value given in ISO8601 combined date and time format that represents
     when the Kubernetes cluster was last updated.
    :vartype updated_at: ~datetime.datetime
    :ivar surge_upgrade: A boolean value indicating whether surge upgrade is enabled/disabled for
     the cluster. Surge upgrade makes cluster upgrades fast and reliable by bringing up new nodes
     before destroying the outdated nodes.
    :vartype surge_upgrade: bool
    :ivar ha: A boolean value indicating whether the control plane is run in a highly available
     configuration in the cluster. Highly available control planes incur less downtime.
    :vartype ha: bool
    :ivar registry_enabled: A read-only boolean value indicating if a container registry is
     integrated with the cluster.
    :vartype registry_enabled: bool
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'required': True},
        'region': {'required': True},
        'version': {'required': True},
        'cluster_subnet': {'readonly': True},
        'service_subnet': {'readonly': True},
        'ipv4': {'readonly': True},
        'endpoint': {'readonly': True},
        'node_pools': {'required': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
        'registry_enabled': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'cluster_subnet': {'key': 'cluster_subnet', 'type': 'str'},
        'service_subnet': {'key': 'service_subnet', 'type': 'str'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'ipv4': {'key': 'ipv4', 'type': 'str'},
        'endpoint': {'key': 'endpoint', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'node_pools': {'key': 'node_pools', 'type': '[KubernetesNodePool]'},
        'maintenance_policy': {'key': 'maintenance_policy', 'type': 'MaintenancePolicy'},
        'auto_upgrade': {'key': 'auto_upgrade', 'type': 'bool'},
        'status': {'key': 'status', 'type': 'ClusterStatus'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
        'surge_upgrade': {'key': 'surge_upgrade', 'type': 'bool'},
        'ha': {'key': 'ha', 'type': 'bool'},
        'registry_enabled': {'key': 'registry_enabled', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: str,
        region: str,
        version: str,
        node_pools: List["_models.KubernetesNodePool"],
        vpc_uuid: Optional[str] = None,
        tags: Optional[List[str]] = None,
        maintenance_policy: Optional["_models.MaintenancePolicy"] = None,
        auto_upgrade: Optional[bool] = False,
        surge_upgrade: Optional[bool] = False,
        ha: Optional[bool] = False,
        **kwargs
    ):
        """
        :keyword name: Required. A human-readable name for a Kubernetes cluster.
        :paramtype name: str
        :keyword region: Required. The slug identifier for the region where the Kubernetes cluster is
         located.
        :paramtype region: str
        :keyword version: Required. The slug identifier for the version of Kubernetes used for the
         cluster. If set to a minor version (e.g. "1.14"), the latest version within it will be used
         (e.g. "1.14.6-do.1"); if set to "latest", the latest published version will be used. See the
         ``/v2/kubernetes/options`` endpoint to find all currently available versions.
        :paramtype version: str
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the Kubernetes cluster is
         assigned.
        :paramtype vpc_uuid: str
        :keyword tags: A set of tags. An array of tags applied to the Kubernetes cluster. All clusters
         are automatically tagged ``k8s`` and ``k8s:$K8S_CLUSTER_ID``.
        :paramtype tags: list[str]
        :keyword node_pools: Required. An object specifying the details of the worker nodes available
         to the Kubernetes cluster.
        :paramtype node_pools: list[~digital_ocean_api.models.KubernetesNodePool]
        :keyword maintenance_policy: An object specifying the maintenance window policy for the
         Kubernetes cluster.
        :paramtype maintenance_policy: ~digital_ocean_api.models.MaintenancePolicy
        :keyword auto_upgrade: A boolean value indicating whether the cluster will be automatically
         upgraded to new patch releases during its maintenance window.
        :paramtype auto_upgrade: bool
        :keyword surge_upgrade: A boolean value indicating whether surge upgrade is enabled/disabled
         for the cluster. Surge upgrade makes cluster upgrades fast and reliable by bringing up new
         nodes before destroying the outdated nodes.
        :paramtype surge_upgrade: bool
        :keyword ha: A boolean value indicating whether the control plane is run in a highly available
         configuration in the cluster. Highly available control planes incur less downtime.
        :paramtype ha: bool
        """
        super(Cluster, self).__init__(**kwargs)
        self.id = None
        self.name = name
        self.region = region
        self.version = version
        self.cluster_subnet = None
        self.service_subnet = None
        self.vpc_uuid = vpc_uuid
        self.ipv4 = None
        self.endpoint = None
        self.tags = tags
        self.node_pools = node_pools
        self.maintenance_policy = maintenance_policy
        self.auto_upgrade = auto_upgrade
        self.status = None
        self.created_at = None
        self.updated_at = None
        self.surge_upgrade = surge_upgrade
        self.ha = ha
        self.registry_enabled = None


class ClusterlintRequest(msrest.serialization.Model):
    """ClusterlintRequest.

    :ivar include_groups: An array of check groups that will be run when clusterlint executes
     checks.
    :vartype include_groups: list[str]
    :ivar include_checks: An array of checks that will be run when clusterlint executes checks.
    :vartype include_checks: list[str]
    :ivar exclude_groups: An array of check groups that will be omitted when clusterlint executes
     checks.
    :vartype exclude_groups: list[str]
    :ivar exclude_checks: An array of checks that will be run when clusterlint executes checks.
    :vartype exclude_checks: list[str]
    """

    _attribute_map = {
        'include_groups': {'key': 'include_groups', 'type': '[str]'},
        'include_checks': {'key': 'include_checks', 'type': '[str]'},
        'exclude_groups': {'key': 'exclude_groups', 'type': '[str]'},
        'exclude_checks': {'key': 'exclude_checks', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        include_groups: Optional[List[str]] = None,
        include_checks: Optional[List[str]] = None,
        exclude_groups: Optional[List[str]] = None,
        exclude_checks: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword include_groups: An array of check groups that will be run when clusterlint executes
         checks.
        :paramtype include_groups: list[str]
        :keyword include_checks: An array of checks that will be run when clusterlint executes checks.
        :paramtype include_checks: list[str]
        :keyword exclude_groups: An array of check groups that will be omitted when clusterlint
         executes checks.
        :paramtype exclude_groups: list[str]
        :keyword exclude_checks: An array of checks that will be run when clusterlint executes checks.
        :paramtype exclude_checks: list[str]
        """
        super(ClusterlintRequest, self).__init__(**kwargs)
        self.include_groups = include_groups
        self.include_checks = include_checks
        self.exclude_groups = exclude_groups
        self.exclude_checks = exclude_checks


class ClusterlintResults(msrest.serialization.Model):
    """ClusterlintResults.

    :ivar run_id: Id of the clusterlint run that can be used later to fetch the diagnostics.
    :vartype run_id: str
    :ivar requested_at: A time value given in ISO8601 combined date and time format that represents
     when the schedule clusterlint run request was made.
    :vartype requested_at: ~datetime.datetime
    :ivar completed_at: A time value given in ISO8601 combined date and time format that represents
     when the schedule clusterlint run request was completed.
    :vartype completed_at: ~datetime.datetime
    :ivar diagnostics: An array of diagnostics reporting potential problems for the given cluster.
    :vartype diagnostics: list[~digital_ocean_api.models.ClusterlintResultsDiagnosticsItem]
    """

    _attribute_map = {
        'run_id': {'key': 'run_id', 'type': 'str'},
        'requested_at': {'key': 'requested_at', 'type': 'iso-8601'},
        'completed_at': {'key': 'completed_at', 'type': 'iso-8601'},
        'diagnostics': {'key': 'diagnostics', 'type': '[ClusterlintResultsDiagnosticsItem]'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        requested_at: Optional[datetime.datetime] = None,
        completed_at: Optional[datetime.datetime] = None,
        diagnostics: Optional[List["_models.ClusterlintResultsDiagnosticsItem"]] = None,
        **kwargs
    ):
        """
        :keyword run_id: Id of the clusterlint run that can be used later to fetch the diagnostics.
        :paramtype run_id: str
        :keyword requested_at: A time value given in ISO8601 combined date and time format that
         represents when the schedule clusterlint run request was made.
        :paramtype requested_at: ~datetime.datetime
        :keyword completed_at: A time value given in ISO8601 combined date and time format that
         represents when the schedule clusterlint run request was completed.
        :paramtype completed_at: ~datetime.datetime
        :keyword diagnostics: An array of diagnostics reporting potential problems for the given
         cluster.
        :paramtype diagnostics: list[~digital_ocean_api.models.ClusterlintResultsDiagnosticsItem]
        """
        super(ClusterlintResults, self).__init__(**kwargs)
        self.run_id = run_id
        self.requested_at = requested_at
        self.completed_at = completed_at
        self.diagnostics = diagnostics


class ClusterlintResultsDiagnosticsItem(msrest.serialization.Model):
    """ClusterlintResultsDiagnosticsItem.

    :ivar check_name: The clusterlint check that resulted in the diagnostic.
    :vartype check_name: str
    :ivar severity: Can be one of error, warning or suggestion.
    :vartype severity: str
    :ivar message: Feedback about the object for users to fix.
    :vartype message: str
    :ivar object: Metadata about the Kubernetes API object the diagnostic is reported on.
    :vartype object: ~digital_ocean_api.models.ClusterlintResultsDiagnosticsItemObject
    """

    _attribute_map = {
        'check_name': {'key': 'check_name', 'type': 'str'},
        'severity': {'key': 'severity', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'object': {'key': 'object', 'type': 'ClusterlintResultsDiagnosticsItemObject'},
    }

    def __init__(
        self,
        *,
        check_name: Optional[str] = None,
        severity: Optional[str] = None,
        message: Optional[str] = None,
        object: Optional["_models.ClusterlintResultsDiagnosticsItemObject"] = None,
        **kwargs
    ):
        """
        :keyword check_name: The clusterlint check that resulted in the diagnostic.
        :paramtype check_name: str
        :keyword severity: Can be one of error, warning or suggestion.
        :paramtype severity: str
        :keyword message: Feedback about the object for users to fix.
        :paramtype message: str
        :keyword object: Metadata about the Kubernetes API object the diagnostic is reported on.
        :paramtype object: ~digital_ocean_api.models.ClusterlintResultsDiagnosticsItemObject
        """
        super(ClusterlintResultsDiagnosticsItem, self).__init__(**kwargs)
        self.check_name = check_name
        self.severity = severity
        self.message = message
        self.object = object


class ClusterlintResultsDiagnosticsItemObject(msrest.serialization.Model):
    """Metadata about the Kubernetes API object the diagnostic is reported on.

    :ivar name: Name of the object.
    :vartype name: str
    :ivar kind: The kind of Kubernetes API object.
    :vartype kind: str
    :ivar namespace: The namespace the object resides in the cluster.
    :vartype namespace: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'kind': {'key': 'kind', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        kind: Optional[str] = None,
        namespace: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: Name of the object.
        :paramtype name: str
        :keyword kind: The kind of Kubernetes API object.
        :paramtype kind: str
        :keyword namespace: The namespace the object resides in the cluster.
        :paramtype namespace: str
        """
        super(ClusterlintResultsDiagnosticsItemObject, self).__init__(**kwargs)
        self.name = name
        self.kind = kind
        self.namespace = namespace


class ClusterRegistries(msrest.serialization.Model):
    """ClusterRegistries.

    :ivar cluster_uuids: An array containing the UUIDs of Kubernetes clusters.
    :vartype cluster_uuids: list[str]
    """

    _attribute_map = {
        'cluster_uuids': {'key': 'cluster_uuids', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        cluster_uuids: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword cluster_uuids: An array containing the UUIDs of Kubernetes clusters.
        :paramtype cluster_uuids: list[str]
        """
        super(ClusterRegistries, self).__init__(**kwargs)
        self.cluster_uuids = cluster_uuids


class ClusterStatus(msrest.serialization.Model):
    """An object containing a ``state`` attribute whose value is set to a string indicating the current status of the cluster.

    :ivar state: A string indicating the current status of the cluster. Known values are:
     "running", "provisioning", "degraded", "error", "deleted", "upgrading", "deleting".
    :vartype state: str or ~digital_ocean_api.models.ClusterStatusState
    :ivar message: An optional message providing additional information about the current cluster
     state.
    :vartype message: str
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        state: Optional[Union[str, "_models.ClusterStatusState"]] = None,
        message: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword state: A string indicating the current status of the cluster. Known values are:
         "running", "provisioning", "degraded", "error", "deleted", "upgrading", "deleting".
        :paramtype state: str or ~digital_ocean_api.models.ClusterStatusState
        :keyword message: An optional message providing additional information about the current
         cluster state.
        :paramtype message: str
        """
        super(ClusterStatus, self).__init__(**kwargs)
        self.state = state
        self.message = message


class ClusterUpdate(msrest.serialization.Model):
    """ClusterUpdate.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A human-readable name for a Kubernetes cluster.
    :vartype name: str
    :ivar tags: A set of tags. An array of tags applied to the Kubernetes cluster. All clusters are
     automatically tagged ``k8s`` and ``k8s:$K8S_CLUSTER_ID``.
    :vartype tags: list[str]
    :ivar maintenance_policy: An object specifying the maintenance window policy for the Kubernetes
     cluster.
    :vartype maintenance_policy: ~digital_ocean_api.models.MaintenancePolicy
    :ivar auto_upgrade: A boolean value indicating whether the cluster will be automatically
     upgraded to new patch releases during its maintenance window.
    :vartype auto_upgrade: bool
    :ivar surge_upgrade: A boolean value indicating whether surge upgrade is enabled/disabled for
     the cluster. Surge upgrade makes cluster upgrades fast and reliable by bringing up new nodes
     before destroying the outdated nodes.
    :vartype surge_upgrade: bool
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'maintenance_policy': {'key': 'maintenance_policy', 'type': 'MaintenancePolicy'},
        'auto_upgrade': {'key': 'auto_upgrade', 'type': 'bool'},
        'surge_upgrade': {'key': 'surge_upgrade', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: str,
        tags: Optional[List[str]] = None,
        maintenance_policy: Optional["_models.MaintenancePolicy"] = None,
        auto_upgrade: Optional[bool] = False,
        surge_upgrade: Optional[bool] = False,
        **kwargs
    ):
        """
        :keyword name: Required. A human-readable name for a Kubernetes cluster.
        :paramtype name: str
        :keyword tags: A set of tags. An array of tags applied to the Kubernetes cluster. All clusters
         are automatically tagged ``k8s`` and ``k8s:$K8S_CLUSTER_ID``.
        :paramtype tags: list[str]
        :keyword maintenance_policy: An object specifying the maintenance window policy for the
         Kubernetes cluster.
        :paramtype maintenance_policy: ~digital_ocean_api.models.MaintenancePolicy
        :keyword auto_upgrade: A boolean value indicating whether the cluster will be automatically
         upgraded to new patch releases during its maintenance window.
        :paramtype auto_upgrade: bool
        :keyword surge_upgrade: A boolean value indicating whether surge upgrade is enabled/disabled
         for the cluster. Surge upgrade makes cluster upgrades fast and reliable by bringing up new
         nodes before destroying the outdated nodes.
        :paramtype surge_upgrade: bool
        """
        super(ClusterUpdate, self).__init__(**kwargs)
        self.name = name
        self.tags = tags
        self.maintenance_policy = maintenance_policy
        self.auto_upgrade = auto_upgrade
        self.surge_upgrade = surge_upgrade


class Components10939PsResponsesVolumeContentApplicationJsonSchema(msrest.serialization.Model):
    """Components10939PsResponsesVolumeContentApplicationJsonSchema.

    :ivar volume:
    :vartype volume: ~digital_ocean_api.models.VolumeFull
    """

    _attribute_map = {
        'volume': {'key': 'volume', 'type': 'VolumeFull'},
    }

    def __init__(
        self,
        *,
        volume: Optional["_models.VolumeFull"] = None,
        **kwargs
    ):
        """
        :keyword volume:
        :paramtype volume: ~digital_ocean_api.models.VolumeFull
        """
        super(Components10939PsResponsesVolumeContentApplicationJsonSchema, self).__init__(**kwargs)
        self.volume = volume


class ComponentsRan85FResponsesAllDropletBackupsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsRan85FResponsesAllDropletBackupsContentApplicationJsonSchemaAllof0.

    :ivar backups:
    :vartype backups: list[~digital_ocean_api.models.DropletSnapshot]
    """

    _attribute_map = {
        'backups': {'key': 'backups', 'type': '[DropletSnapshot]'},
    }

    def __init__(
        self,
        *,
        backups: Optional[List["_models.DropletSnapshot"]] = None,
        **kwargs
    ):
        """
        :keyword backups:
        :paramtype backups: list[~digital_ocean_api.models.DropletSnapshot]
        """
        super(ComponentsRan85FResponsesAllDropletBackupsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.backups = backups


class Components10IqkodResponsesAllDropletBackupsContentApplicationJsonSchema(Pagination, Meta, ComponentsRan85FResponsesAllDropletBackupsContentApplicationJsonSchemaAllof0):
    """Components10IqkodResponsesAllDropletBackupsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar backups:
    :vartype backups: list[~digital_ocean_api.models.DropletSnapshot]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'backups': {'key': 'backups', 'type': '[DropletSnapshot]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        backups: Optional[List["_models.DropletSnapshot"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword backups:
        :paramtype backups: list[~digital_ocean_api.models.DropletSnapshot]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components10IqkodResponsesAllDropletBackupsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, backups=backups, **kwargs)
        self.backups = backups
        self.meta = meta
        self.links = links


class Components1P7VxhlResponsesRepositoryTagsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1P7VxhlResponsesRepositoryTagsContentApplicationJsonSchemaAllof0.

    :ivar tags: A set of tags.
    :vartype tags: list[~digital_ocean_api.models.RepositoryTag]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '[RepositoryTag]'},
    }

    def __init__(
        self,
        *,
        tags: Optional[List["_models.RepositoryTag"]] = None,
        **kwargs
    ):
        """
        :keyword tags: A set of tags.
        :paramtype tags: list[~digital_ocean_api.models.RepositoryTag]
        """
        super(Components1P7VxhlResponsesRepositoryTagsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.tags = tags


class Components10JgxsbResponsesRepositoryTagsContentApplicationJsonSchema(Pagination, Meta, Components1P7VxhlResponsesRepositoryTagsContentApplicationJsonSchemaAllof0):
    """Components10JgxsbResponsesRepositoryTagsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar tags: A set of tags.
    :vartype tags: list[~digital_ocean_api.models.RepositoryTag]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '[RepositoryTag]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        tags: Optional[List["_models.RepositoryTag"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword tags: A set of tags.
        :paramtype tags: list[~digital_ocean_api.models.RepositoryTag]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components10JgxsbResponsesRepositoryTagsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, tags=tags, **kwargs)
        self.tags = tags
        self.meta = meta
        self.links = links


class Components10LqvkkResponsesDropletCreateContentApplicationJsonSchemaOneof1PropertiesLinks(msrest.serialization.Model):
    """Components10LqvkkResponsesDropletCreateContentApplicationJsonSchemaOneof1PropertiesLinks.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.ActionLink]
    """

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[ActionLink]'},
    }

    def __init__(
        self,
        *,
        actions: Optional[List["_models.ActionLink"]] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.ActionLink]
        """
        super(Components10LqvkkResponsesDropletCreateContentApplicationJsonSchemaOneof1PropertiesLinks, self).__init__(**kwargs)
        self.actions = actions


class Components19J8EteResponsesAllTagsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components19J8EteResponsesAllTagsContentApplicationJsonSchemaAllof0.

    :ivar tags: A set of tags.
    :vartype tags: list[~digital_ocean_api.models.Tag]
    """

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '[Tag]'},
    }

    def __init__(
        self,
        *,
        tags: Optional[List["_models.Tag"]] = None,
        **kwargs
    ):
        """
        :keyword tags: A set of tags.
        :paramtype tags: list[~digital_ocean_api.models.Tag]
        """
        super(Components19J8EteResponsesAllTagsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.tags = tags


class Components10PbhpsResponsesAllTagsContentApplicationJsonSchema(Pagination, Meta, Components19J8EteResponsesAllTagsContentApplicationJsonSchemaAllof0):
    """Components10PbhpsResponsesAllTagsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar tags: A set of tags.
    :vartype tags: list[~digital_ocean_api.models.Tag]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': '[Tag]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        tags: Optional[List["_models.Tag"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword tags: A set of tags.
        :paramtype tags: list[~digital_ocean_api.models.Tag]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components10PbhpsResponsesAllTagsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, tags=tags, **kwargs)
        self.tags = tags
        self.meta = meta
        self.links = links


class Components1StqgosResponsesAllDomainRecordsResponseContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1StqgosResponsesAllDomainRecordsResponseContentApplicationJsonSchemaAllof0.

    :ivar domain_records:
    :vartype domain_records: list[~digital_ocean_api.models.DomainRecord]
    """

    _attribute_map = {
        'domain_records': {'key': 'domain_records', 'type': '[DomainRecord]'},
    }

    def __init__(
        self,
        *,
        domain_records: Optional[List["_models.DomainRecord"]] = None,
        **kwargs
    ):
        """
        :keyword domain_records:
        :paramtype domain_records: list[~digital_ocean_api.models.DomainRecord]
        """
        super(Components1StqgosResponsesAllDomainRecordsResponseContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.domain_records = domain_records


class Components118KethResponsesAllDomainRecordsResponseContentApplicationJsonSchema(Pagination, Meta, Components1StqgosResponsesAllDomainRecordsResponseContentApplicationJsonSchemaAllof0):
    """Components118KethResponsesAllDomainRecordsResponseContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar domain_records:
    :vartype domain_records: list[~digital_ocean_api.models.DomainRecord]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'domain_records': {'key': 'domain_records', 'type': '[DomainRecord]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        domain_records: Optional[List["_models.DomainRecord"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword domain_records:
        :paramtype domain_records: list[~digital_ocean_api.models.DomainRecord]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components118KethResponsesAllDomainRecordsResponseContentApplicationJsonSchema, self).__init__(links=links, meta=meta, domain_records=domain_records, **kwargs)
        self.domain_records = domain_records
        self.meta = meta
        self.links = links


class Components1E5Uoh1ResponsesNeighborDropletsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1E5Uoh1ResponsesNeighborDropletsContentApplicationJsonSchemaAllof0.

    :ivar droplets:
    :vartype droplets: list[~digital_ocean_api.models.Droplet]
    """

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': '[Droplet]'},
    }

    def __init__(
        self,
        *,
        droplets: Optional[List["_models.Droplet"]] = None,
        **kwargs
    ):
        """
        :keyword droplets:
        :paramtype droplets: list[~digital_ocean_api.models.Droplet]
        """
        super(Components1E5Uoh1ResponsesNeighborDropletsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.droplets = droplets


class Components11M9D34ResponsesNeighborDropletsContentApplicationJsonSchema(Components1E5Uoh1ResponsesNeighborDropletsContentApplicationJsonSchemaAllof0):
    """Components11M9D34ResponsesNeighborDropletsContentApplicationJsonSchema.

    :ivar droplets:
    :vartype droplets: list[~digital_ocean_api.models.Droplet]
    """

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': '[Droplet]'},
    }

    def __init__(
        self,
        *,
        droplets: Optional[List["_models.Droplet"]] = None,
        **kwargs
    ):
        """
        :keyword droplets:
        :paramtype droplets: list[~digital_ocean_api.models.Droplet]
        """
        super(Components11M9D34ResponsesNeighborDropletsContentApplicationJsonSchema, self).__init__(droplets=droplets, **kwargs)


class Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema(msrest.serialization.Model):
    """Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema.

    :ivar vpc:
    :vartype vpc: ~digital_ocean_api.models.Vpc
    """

    _attribute_map = {
        'vpc': {'key': 'vpc', 'type': 'Vpc'},
    }

    def __init__(
        self,
        *,
        vpc: Optional["_models.Vpc"] = None,
        **kwargs
    ):
        """
        :keyword vpc:
        :paramtype vpc: ~digital_ocean_api.models.Vpc
        """
        super(Components11RtrfgResponsesExistingVpcContentApplicationJsonSchema, self).__init__(**kwargs)
        self.vpc = vpc


class ComponentsVpcoyeResponsesRepositoryManifestsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsVpcoyeResponsesRepositoryManifestsContentApplicationJsonSchemaAllof0.

    :ivar manifests:
    :vartype manifests: list[~digital_ocean_api.models.RepositoryManifest]
    """

    _attribute_map = {
        'manifests': {'key': 'manifests', 'type': '[RepositoryManifest]'},
    }

    def __init__(
        self,
        *,
        manifests: Optional[List["_models.RepositoryManifest"]] = None,
        **kwargs
    ):
        """
        :keyword manifests:
        :paramtype manifests: list[~digital_ocean_api.models.RepositoryManifest]
        """
        super(ComponentsVpcoyeResponsesRepositoryManifestsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.manifests = manifests


class Components12Agh0TResponsesRepositoryManifestsContentApplicationJsonSchema(Pagination, Meta, ComponentsVpcoyeResponsesRepositoryManifestsContentApplicationJsonSchemaAllof0):
    """Components12Agh0TResponsesRepositoryManifestsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar manifests:
    :vartype manifests: list[~digital_ocean_api.models.RepositoryManifest]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'manifests': {'key': 'manifests', 'type': '[RepositoryManifest]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        manifests: Optional[List["_models.RepositoryManifest"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword manifests:
        :paramtype manifests: list[~digital_ocean_api.models.RepositoryManifest]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components12Agh0TResponsesRepositoryManifestsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, manifests=manifests, **kwargs)
        self.manifests = manifests
        self.meta = meta
        self.links = links


class Components1Mgw0OqResponsesAllVpcsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Mgw0OqResponsesAllVpcsContentApplicationJsonSchemaAllof0.

    :ivar vpcs:
    :vartype vpcs: list[~digital_ocean_api.models.Vpc]
    """

    _attribute_map = {
        'vpcs': {'key': 'vpcs', 'type': '[Vpc]'},
    }

    def __init__(
        self,
        *,
        vpcs: Optional[List["_models.Vpc"]] = None,
        **kwargs
    ):
        """
        :keyword vpcs:
        :paramtype vpcs: list[~digital_ocean_api.models.Vpc]
        """
        super(Components1Mgw0OqResponsesAllVpcsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.vpcs = vpcs


class Components12Bgq7WResponsesAllVpcsContentApplicationJsonSchema(Pagination, Meta, Components1Mgw0OqResponsesAllVpcsContentApplicationJsonSchemaAllof0):
    """Components12Bgq7WResponsesAllVpcsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar vpcs:
    :vartype vpcs: list[~digital_ocean_api.models.Vpc]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'vpcs': {'key': 'vpcs', 'type': '[Vpc]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        vpcs: Optional[List["_models.Vpc"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword vpcs:
        :paramtype vpcs: list[~digital_ocean_api.models.Vpc]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components12Bgq7WResponsesAllVpcsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, vpcs=vpcs, **kwargs)
        self.vpcs = vpcs
        self.meta = meta
        self.links = links


class Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema(msrest.serialization.Model):
    """Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema.

    :ivar snapshot:
    :vartype snapshot: ~digital_ocean_api.models.Snapshot
    """

    _attribute_map = {
        'snapshot': {'key': 'snapshot', 'type': 'Snapshot'},
    }

    def __init__(
        self,
        *,
        snapshot: Optional["_models.Snapshot"] = None,
        **kwargs
    ):
        """
        :keyword snapshot:
        :paramtype snapshot: ~digital_ocean_api.models.Snapshot
        """
        super(Components12Eybj8ResponsesVolumeSnapshotContentApplicationJsonSchema, self).__init__(**kwargs)
        self.snapshot = snapshot


class Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema(msrest.serialization.Model):
    """Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema.

    :ivar domain:
    :vartype domain: ~digital_ocean_api.models.Domain
    """

    _attribute_map = {
        'domain': {'key': 'domain', 'type': 'Domain'},
    }

    def __init__(
        self,
        *,
        domain: Optional["_models.Domain"] = None,
        **kwargs
    ):
        """
        :keyword domain:
        :paramtype domain: ~digital_ocean_api.models.Domain
        """
        super(Components12H0Ks2ResponsesCreateDomainResponseContentApplicationJsonSchema, self).__init__(**kwargs)
        self.domain = domain


class Components12Klsz5ResponsesNewTagContentApplicationJsonSchema(msrest.serialization.Model):
    """Components12Klsz5ResponsesNewTagContentApplicationJsonSchema.

    :ivar tag: A tag is a label that can be applied to a resource (currently Droplets, Images,
     Volumes, Volume Snapshots, and Database clusters) in order to better organize or facilitate the
     lookups and actions on it.
     Tags have two attributes: a user defined ``name`` attribute and an embedded ``resources``
     attribute with information about resources that have been tagged.
    :vartype tag: ~digital_ocean_api.models.Tag
    """

    _attribute_map = {
        'tag': {'key': 'tag', 'type': 'Tag'},
    }

    def __init__(
        self,
        *,
        tag: Optional["_models.Tag"] = None,
        **kwargs
    ):
        """
        :keyword tag: A tag is a label that can be applied to a resource (currently Droplets, Images,
         Volumes, Volume Snapshots, and Database clusters) in order to better organize or facilitate the
         lookups and actions on it.
         Tags have two attributes: a user defined ``name`` attribute and an embedded ``resources``
         attribute with information about resources that have been tagged.
        :paramtype tag: ~digital_ocean_api.models.Tag
        """
        super(Components12Klsz5ResponsesNewTagContentApplicationJsonSchema, self).__init__(**kwargs)
        self.tag = tag


class Components12R29VResponsesExistingDomainContentApplicationJsonSchema(msrest.serialization.Model):
    """Components12R29VResponsesExistingDomainContentApplicationJsonSchema.

    :ivar domain:
    :vartype domain: ~digital_ocean_api.models.Domain
    """

    _attribute_map = {
        'domain': {'key': 'domain', 'type': 'Domain'},
    }

    def __init__(
        self,
        *,
        domain: Optional["_models.Domain"] = None,
        **kwargs
    ):
        """
        :keyword domain:
        :paramtype domain: ~digital_ocean_api.models.Domain
        """
        super(Components12R29VResponsesExistingDomainContentApplicationJsonSchema, self).__init__(**kwargs)
        self.domain = domain


class Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema(msrest.serialization.Model):
    """Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema.

    :ivar domain_record:
    :vartype domain_record: ~digital_ocean_api.models.DomainRecord
    """

    _attribute_map = {
        'domain_record': {'key': 'domain_record', 'type': 'DomainRecord'},
    }

    def __init__(
        self,
        *,
        domain_record: Optional["_models.DomainRecord"] = None,
        **kwargs
    ):
        """
        :keyword domain_record:
        :paramtype domain_record: ~digital_ocean_api.models.DomainRecord
        """
        super(Components12RmuqrResponsesCreatedDomainRecordContentApplicationJsonSchema, self).__init__(**kwargs)
        self.domain_record = domain_record


class Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema(msrest.serialization.Model):
    """Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar database: Required.
    :vartype database: ~digital_ocean_api.models.DatabaseCluster
    """

    _validation = {
        'database': {'required': True},
    }

    _attribute_map = {
        'database': {'key': 'database', 'type': 'DatabaseCluster'},
    }

    def __init__(
        self,
        *,
        database: "_models.DatabaseCluster",
        **kwargs
    ):
        """
        :keyword database: Required.
        :paramtype database: ~digital_ocean_api.models.DatabaseCluster
        """
        super(Components15CinloResponsesDatabaseClusterContentApplicationJsonSchema, self).__init__(**kwargs)
        self.database = database


class Components15UghnxSchemasFirewallRulesPropertiesInboundRulesItemsAllof1(msrest.serialization.Model):
    """Components15UghnxSchemasFirewallRulesPropertiesInboundRulesItemsAllof1.

    All required parameters must be populated in order to send to Azure.

    :ivar sources: Required.
    :vartype sources: ~digital_ocean_api.models.FirewallRulesInboundRulesAllOfProperties
    """

    _validation = {
        'sources': {'required': True},
    }

    _attribute_map = {
        'sources': {'key': 'sources', 'type': 'FirewallRulesInboundRulesAllOfProperties'},
    }

    def __init__(
        self,
        *,
        sources: "_models.FirewallRulesInboundRulesAllOfProperties",
        **kwargs
    ):
        """
        :keyword sources: Required.
        :paramtype sources: ~digital_ocean_api.models.FirewallRulesInboundRulesAllOfProperties
        """
        super(Components15UghnxSchemasFirewallRulesPropertiesInboundRulesItemsAllof1, self).__init__(**kwargs)
        self.sources = sources


class ComponentsKa40RcResponsesInvoiceContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsKa40RcResponsesInvoiceContentApplicationJsonSchemaAllof0.

    :ivar invoice_items:
    :vartype invoice_items: list[~digital_ocean_api.models.InvoiceItem]
    """

    _attribute_map = {
        'invoice_items': {'key': 'invoice_items', 'type': '[InvoiceItem]'},
    }

    def __init__(
        self,
        *,
        invoice_items: Optional[List["_models.InvoiceItem"]] = None,
        **kwargs
    ):
        """
        :keyword invoice_items:
        :paramtype invoice_items: list[~digital_ocean_api.models.InvoiceItem]
        """
        super(ComponentsKa40RcResponsesInvoiceContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.invoice_items = invoice_items


class Components1691Gb0ResponsesInvoiceContentApplicationJsonSchema(Pagination, Meta, ComponentsKa40RcResponsesInvoiceContentApplicationJsonSchemaAllof0):
    """Components1691Gb0ResponsesInvoiceContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar invoice_items:
    :vartype invoice_items: list[~digital_ocean_api.models.InvoiceItem]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'invoice_items': {'key': 'invoice_items', 'type': '[InvoiceItem]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        invoice_items: Optional[List["_models.InvoiceItem"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword invoice_items:
        :paramtype invoice_items: list[~digital_ocean_api.models.InvoiceItem]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1691Gb0ResponsesInvoiceContentApplicationJsonSchema, self).__init__(links=links, meta=meta, invoice_items=invoice_items, **kwargs)
        self.invoice_items = invoice_items
        self.meta = meta
        self.links = links


class Components171RlqzResponsesInvoicesContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components171RlqzResponsesInvoicesContentApplicationJsonSchemaAllof0.

    :ivar invoices:
    :vartype invoices: list[~digital_ocean_api.models.InvoicePreview]
    :ivar invoice_preview: The invoice preview.
    :vartype invoice_preview: ~digital_ocean_api.models.InvoicePreview
    """

    _attribute_map = {
        'invoices': {'key': 'invoices', 'type': '[InvoicePreview]'},
        'invoice_preview': {'key': 'invoice_preview', 'type': 'InvoicePreview'},
    }

    def __init__(
        self,
        *,
        invoices: Optional[List["_models.InvoicePreview"]] = None,
        invoice_preview: Optional["_models.InvoicePreview"] = None,
        **kwargs
    ):
        """
        :keyword invoices:
        :paramtype invoices: list[~digital_ocean_api.models.InvoicePreview]
        :keyword invoice_preview: The invoice preview.
        :paramtype invoice_preview: ~digital_ocean_api.models.InvoicePreview
        """
        super(Components171RlqzResponsesInvoicesContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.invoices = invoices
        self.invoice_preview = invoice_preview


class Components190HxlaResponsesExistingSnapshotContentApplicationJsonSchema(msrest.serialization.Model):
    """Components190HxlaResponsesExistingSnapshotContentApplicationJsonSchema.

    :ivar snapshot:
    :vartype snapshot: ~digital_ocean_api.models.Snapshot
    """

    _attribute_map = {
        'snapshot': {'key': 'snapshot', 'type': 'Snapshot'},
    }

    def __init__(
        self,
        *,
        snapshot: Optional["_models.Snapshot"] = None,
        **kwargs
    ):
        """
        :keyword snapshot:
        :paramtype snapshot: ~digital_ocean_api.models.Snapshot
        """
        super(Components190HxlaResponsesExistingSnapshotContentApplicationJsonSchema, self).__init__(**kwargs)
        self.snapshot = snapshot


class Components195IbpyResponsesExistingKeyContentApplicationJsonSchema(msrest.serialization.Model):
    """Components195IbpyResponsesExistingKeyContentApplicationJsonSchema.

    :ivar ssh_key:
    :vartype ssh_key: ~digital_ocean_api.models.SshKey
    """

    _attribute_map = {
        'ssh_key': {'key': 'ssh_key', 'type': 'SshKey'},
    }

    def __init__(
        self,
        *,
        ssh_key: Optional["_models.SshKey"] = None,
        **kwargs
    ):
        """
        :keyword ssh_key:
        :paramtype ssh_key: ~digital_ocean_api.models.SshKey
        """
        super(Components195IbpyResponsesExistingKeyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.ssh_key = ssh_key


class Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema(msrest.serialization.Model):
    """Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema.

    :ivar replica:
    :vartype replica: ~digital_ocean_api.models.DatabaseReplica
    """

    _attribute_map = {
        'replica': {'key': 'replica', 'type': 'DatabaseReplica'},
    }

    def __init__(
        self,
        *,
        replica: Optional["_models.DatabaseReplica"] = None,
        **kwargs
    ):
        """
        :keyword replica:
        :paramtype replica: ~digital_ocean_api.models.DatabaseReplica
        """
        super(Components19Fq60GResponsesDatabaseReplicaContentApplicationJsonSchema, self).__init__(**kwargs)
        self.replica = replica


class Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema(msrest.serialization.Model):
    """Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema.

    :ivar load_balancer:
    :vartype load_balancer: ~digital_ocean_api.models.LoadBalancer
    """

    _attribute_map = {
        'load_balancer': {'key': 'load_balancer', 'type': 'LoadBalancer'},
    }

    def __init__(
        self,
        *,
        load_balancer: Optional["_models.LoadBalancer"] = None,
        **kwargs
    ):
        """
        :keyword load_balancer:
        :paramtype load_balancer: ~digital_ocean_api.models.LoadBalancer
        """
        super(Components19UpsdbResponsesLoadBalancerCreateContentApplicationJsonSchema, self).__init__(**kwargs)
        self.load_balancer = load_balancer


class Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema(msrest.serialization.Model):
    """Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema.

    :ivar registry:
    :vartype registry: ~digital_ocean_api.models.Registry
    """

    _attribute_map = {
        'registry': {'key': 'registry', 'type': 'Registry'},
    }

    def __init__(
        self,
        *,
        registry: Optional["_models.Registry"] = None,
        **kwargs
    ):
        """
        :keyword registry:
        :paramtype registry: ~digital_ocean_api.models.Registry
        """
        super(Components19XzcfnResponsesRegistryInfoContentApplicationJsonSchema, self).__init__(**kwargs)
        self.registry = registry


class ComponentsOh4Ku4ResponsesAllRepositoriesContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsOh4Ku4ResponsesAllRepositoriesContentApplicationJsonSchemaAllof0.

    :ivar repositories:
    :vartype repositories: list[~digital_ocean_api.models.Repository]
    """

    _attribute_map = {
        'repositories': {'key': 'repositories', 'type': '[Repository]'},
    }

    def __init__(
        self,
        *,
        repositories: Optional[List["_models.Repository"]] = None,
        **kwargs
    ):
        """
        :keyword repositories:
        :paramtype repositories: list[~digital_ocean_api.models.Repository]
        """
        super(ComponentsOh4Ku4ResponsesAllRepositoriesContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.repositories = repositories


class Components1Ariq5GResponsesAllRepositoriesContentApplicationJsonSchema(Pagination, Meta, ComponentsOh4Ku4ResponsesAllRepositoriesContentApplicationJsonSchemaAllof0):
    """Components1Ariq5GResponsesAllRepositoriesContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar repositories:
    :vartype repositories: list[~digital_ocean_api.models.Repository]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'repositories': {'key': 'repositories', 'type': '[Repository]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        repositories: Optional[List["_models.Repository"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword repositories:
        :paramtype repositories: list[~digital_ocean_api.models.Repository]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1Ariq5GResponsesAllRepositoriesContentApplicationJsonSchema, self).__init__(links=links, meta=meta, repositories=repositories, **kwargs)
        self.repositories = repositories
        self.meta = meta
        self.links = links


class Components1Dkf1JdResponsesAvailableUpgradesContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Dkf1JdResponsesAvailableUpgradesContentApplicationJsonSchema.

    :ivar available_upgrade_versions:
    :vartype available_upgrade_versions: list[~digital_ocean_api.models.KubernetesVersion]
    """

    _attribute_map = {
        'available_upgrade_versions': {'key': 'available_upgrade_versions', 'type': '[KubernetesVersion]'},
    }

    def __init__(
        self,
        *,
        available_upgrade_versions: Optional[List["_models.KubernetesVersion"]] = None,
        **kwargs
    ):
        """
        :keyword available_upgrade_versions:
        :paramtype available_upgrade_versions: list[~digital_ocean_api.models.KubernetesVersion]
        """
        super(Components1Dkf1JdResponsesAvailableUpgradesContentApplicationJsonSchema, self).__init__(**kwargs)
        self.available_upgrade_versions = available_upgrade_versions


class Components1Dwt4B3ResponsesAllSizesContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Dwt4B3ResponsesAllSizesContentApplicationJsonSchemaAllof0.

    All required parameters must be populated in order to send to Azure.

    :ivar sizes: Required.
    :vartype sizes: list[~digital_ocean_api.models.Size]
    """

    _validation = {
        'sizes': {'required': True},
    }

    _attribute_map = {
        'sizes': {'key': 'sizes', 'type': '[Size]'},
    }

    def __init__(
        self,
        *,
        sizes: List["_models.Size"],
        **kwargs
    ):
        """
        :keyword sizes: Required.
        :paramtype sizes: list[~digital_ocean_api.models.Size]
        """
        super(Components1Dwt4B3ResponsesAllSizesContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.sizes = sizes


class Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema.

    :ivar image:
    :vartype image: ~digital_ocean_api.models.Image
    """

    _attribute_map = {
        'image': {'key': 'image', 'type': 'Image'},
    }

    def __init__(
        self,
        *,
        image: Optional["_models.Image"] = None,
        **kwargs
    ):
        """
        :keyword image:
        :paramtype image: ~digital_ocean_api.models.Image
        """
        super(Components1Ef5H32ResponsesNewCustomImageContentApplicationJsonSchema, self).__init__(**kwargs)
        self.image = image


class Components1Exa74MResponsesAssociatedResourcesListContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Exa74MResponsesAssociatedResourcesListContentApplicationJsonSchemaAllof0.

    :ivar floating_ips:
    :vartype floating_ips: list[~digital_ocean_api.models.AssociatedResource]
    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.AssociatedResource]
    :ivar volumes:
    :vartype volumes: list[~digital_ocean_api.models.AssociatedResource]
    :ivar volume_snapshots:
    :vartype volume_snapshots: list[~digital_ocean_api.models.AssociatedResource]
    """

    _attribute_map = {
        'floating_ips': {'key': 'floating_ips', 'type': '[AssociatedResource]'},
        'snapshots': {'key': 'snapshots', 'type': '[AssociatedResource]'},
        'volumes': {'key': 'volumes', 'type': '[AssociatedResource]'},
        'volume_snapshots': {'key': 'volume_snapshots', 'type': '[AssociatedResource]'},
    }

    def __init__(
        self,
        *,
        floating_ips: Optional[List["_models.AssociatedResource"]] = None,
        snapshots: Optional[List["_models.AssociatedResource"]] = None,
        volumes: Optional[List["_models.AssociatedResource"]] = None,
        volume_snapshots: Optional[List["_models.AssociatedResource"]] = None,
        **kwargs
    ):
        """
        :keyword floating_ips:
        :paramtype floating_ips: list[~digital_ocean_api.models.AssociatedResource]
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.AssociatedResource]
        :keyword volumes:
        :paramtype volumes: list[~digital_ocean_api.models.AssociatedResource]
        :keyword volume_snapshots:
        :paramtype volume_snapshots: list[~digital_ocean_api.models.AssociatedResource]
        """
        super(Components1Exa74MResponsesAssociatedResourcesListContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.floating_ips = floating_ips
        self.snapshots = snapshots
        self.volumes = volumes
        self.volume_snapshots = volume_snapshots


class Components1Fz6HvkResponsesExistingDropletContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Fz6HvkResponsesExistingDropletContentApplicationJsonSchema.

    :ivar droplet:
    :vartype droplet: ~digital_ocean_api.models.Droplet
    """

    _attribute_map = {
        'droplet': {'key': 'droplet', 'type': 'Droplet'},
    }

    def __init__(
        self,
        *,
        droplet: Optional["_models.Droplet"] = None,
        **kwargs
    ):
        """
        :keyword droplet:
        :paramtype droplet: ~digital_ocean_api.models.Droplet
        """
        super(Components1Fz6HvkResponsesExistingDropletContentApplicationJsonSchema, self).__init__(**kwargs)
        self.droplet = droplet


class Components1Oqmse8ResponsesAllSnapshotsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Oqmse8ResponsesAllSnapshotsContentApplicationJsonSchemaAllof0.

    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.Snapshot]
    """

    _attribute_map = {
        'snapshots': {'key': 'snapshots', 'type': '[Snapshot]'},
    }

    def __init__(
        self,
        *,
        snapshots: Optional[List["_models.Snapshot"]] = None,
        **kwargs
    ):
        """
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.Snapshot]
        """
        super(Components1Oqmse8ResponsesAllSnapshotsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.snapshots = snapshots


class Components1Gpw7QmResponsesAllSnapshotsContentApplicationJsonSchema(Pagination, Meta, Components1Oqmse8ResponsesAllSnapshotsContentApplicationJsonSchemaAllof0):
    """Components1Gpw7QmResponsesAllSnapshotsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.Snapshot]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'snapshots': {'key': 'snapshots', 'type': '[Snapshot]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        snapshots: Optional[List["_models.Snapshot"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.Snapshot]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1Gpw7QmResponsesAllSnapshotsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, snapshots=snapshots, **kwargs)
        self.snapshots = snapshots
        self.meta = meta
        self.links = links


class Components1Gyiz9ResponsesNodePoolUpdateContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Gyiz9ResponsesNodePoolUpdateContentApplicationJsonSchema.

    :ivar node_pool:
    :vartype node_pool: ~digital_ocean_api.models.KubernetesNodePool
    """

    _attribute_map = {
        'node_pool': {'key': 'node_pool', 'type': 'KubernetesNodePool'},
    }

    def __init__(
        self,
        *,
        node_pool: Optional["_models.KubernetesNodePool"] = None,
        **kwargs
    ):
        """
        :keyword node_pool:
        :paramtype node_pool: ~digital_ocean_api.models.KubernetesNodePool
        """
        super(Components1Gyiz9ResponsesNodePoolUpdateContentApplicationJsonSchema, self).__init__(**kwargs)
        self.node_pool = node_pool


class Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema.

    :ivar ssh_key:
    :vartype ssh_key: ~digital_ocean_api.models.SshKey
    """

    _attribute_map = {
        'ssh_key': {'key': 'ssh_key', 'type': 'SshKey'},
    }

    def __init__(
        self,
        *,
        ssh_key: Optional["_models.SshKey"] = None,
        **kwargs
    ):
        """
        :keyword ssh_key:
        :paramtype ssh_key: ~digital_ocean_api.models.SshKey
        """
        super(Components1HarxvuResponsesKeyCreatedContentApplicationJsonSchema, self).__init__(**kwargs)
        self.ssh_key = ssh_key


class Components1Hqp2PyResponsesAllRepositoriesV2ContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Hqp2PyResponsesAllRepositoriesV2ContentApplicationJsonSchemaAllof0.

    :ivar repositories:
    :vartype repositories: list[~digital_ocean_api.models.RepositoryV2]
    """

    _attribute_map = {
        'repositories': {'key': 'repositories', 'type': '[RepositoryV2]'},
    }

    def __init__(
        self,
        *,
        repositories: Optional[List["_models.RepositoryV2"]] = None,
        **kwargs
    ):
        """
        :keyword repositories:
        :paramtype repositories: list[~digital_ocean_api.models.RepositoryV2]
        """
        super(Components1Hqp2PyResponsesAllRepositoriesV2ContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.repositories = repositories


class Components1Iix62EResponsesAllKeysContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Iix62EResponsesAllKeysContentApplicationJsonSchemaAllof0.

    :ivar ssh_keys:
    :vartype ssh_keys: list[~digital_ocean_api.models.SshKey]
    """

    _attribute_map = {
        'ssh_keys': {'key': 'ssh_keys', 'type': '[SshKey]'},
    }

    def __init__(
        self,
        *,
        ssh_keys: Optional[List["_models.SshKey"]] = None,
        **kwargs
    ):
        """
        :keyword ssh_keys:
        :paramtype ssh_keys: list[~digital_ocean_api.models.SshKey]
        """
        super(Components1Iix62EResponsesAllKeysContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.ssh_keys = ssh_keys


class ComponentsL46Y0QResponsesAllKernelsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsL46Y0QResponsesAllKernelsContentApplicationJsonSchemaAllof0.

    :ivar kernels:
    :vartype kernels: list[~digital_ocean_api.models.Kernel]
    """

    _attribute_map = {
        'kernels': {'key': 'kernels', 'type': '[Kernel]'},
    }

    def __init__(
        self,
        *,
        kernels: Optional[List["_models.Kernel"]] = None,
        **kwargs
    ):
        """
        :keyword kernels:
        :paramtype kernels: list[~digital_ocean_api.models.Kernel]
        """
        super(ComponentsL46Y0QResponsesAllKernelsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.kernels = kernels


class Components1Ijqzy9ResponsesAllKernelsContentApplicationJsonSchema(Pagination, Meta, ComponentsL46Y0QResponsesAllKernelsContentApplicationJsonSchemaAllof0):
    """Components1Ijqzy9ResponsesAllKernelsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar kernels:
    :vartype kernels: list[~digital_ocean_api.models.Kernel]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'kernels': {'key': 'kernels', 'type': '[Kernel]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        kernels: Optional[List["_models.Kernel"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword kernels:
        :paramtype kernels: list[~digital_ocean_api.models.Kernel]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1Ijqzy9ResponsesAllKernelsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, kernels=kernels, **kwargs)
        self.kernels = kernels
        self.meta = meta
        self.links = links


class Components1IjwlbpResponsesGetImageActionsResponseContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1IjwlbpResponsesGetImageActionsResponseContentApplicationJsonSchemaAllof0.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.Action]
    """

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[Action]'},
    }

    def __init__(
        self,
        *,
        actions: Optional[List["_models.Action"]] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.Action]
        """
        super(Components1IjwlbpResponsesGetImageActionsResponseContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.actions = actions


class Components1IxwwnaResponsesProjectsListContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1IxwwnaResponsesProjectsListContentApplicationJsonSchemaAllof0.

    :ivar projects:
    :vartype projects: list[~digital_ocean_api.models.Project]
    """

    _attribute_map = {
        'projects': {'key': 'projects', 'type': '[Project]'},
    }

    def __init__(
        self,
        *,
        projects: Optional[List["_models.Project"]] = None,
        **kwargs
    ):
        """
        :keyword projects:
        :paramtype projects: list[~digital_ocean_api.models.Project]
        """
        super(Components1IxwwnaResponsesProjectsListContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.projects = projects


class Components1Jlkn4DSchemasTagPropertiesResourcesAllof1(msrest.serialization.Model):
    """Components1Jlkn4DSchemasTagPropertiesResourcesAllof1.

    :ivar droplets: Tagged Resource Statistics include metadata regarding the resource type that
     has been tagged.
    :vartype droplets: ~digital_ocean_api.models.TagMetadata
    :ivar imgages: Tagged Resource Statistics include metadata regarding the resource type that has
     been tagged.
    :vartype imgages: ~digital_ocean_api.models.TagMetadata
    :ivar volumes: Tagged Resource Statistics include metadata regarding the resource type that has
     been tagged.
    :vartype volumes: ~digital_ocean_api.models.TagMetadata
    :ivar volume_snapshots: Tagged Resource Statistics include metadata regarding the resource type
     that has been tagged.
    :vartype volume_snapshots: ~digital_ocean_api.models.TagMetadata
    :ivar databases: Tagged Resource Statistics include metadata regarding the resource type that
     has been tagged.
    :vartype databases: ~digital_ocean_api.models.TagMetadata
    """

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': 'TagMetadata'},
        'imgages': {'key': 'imgages', 'type': 'TagMetadata'},
        'volumes': {'key': 'volumes', 'type': 'TagMetadata'},
        'volume_snapshots': {'key': 'volume_snapshots', 'type': 'TagMetadata'},
        'databases': {'key': 'databases', 'type': 'TagMetadata'},
    }

    def __init__(
        self,
        *,
        droplets: Optional["_models.TagMetadata"] = None,
        imgages: Optional["_models.TagMetadata"] = None,
        volumes: Optional["_models.TagMetadata"] = None,
        volume_snapshots: Optional["_models.TagMetadata"] = None,
        databases: Optional["_models.TagMetadata"] = None,
        **kwargs
    ):
        """
        :keyword droplets: Tagged Resource Statistics include metadata regarding the resource type that
         has been tagged.
        :paramtype droplets: ~digital_ocean_api.models.TagMetadata
        :keyword imgages: Tagged Resource Statistics include metadata regarding the resource type that
         has been tagged.
        :paramtype imgages: ~digital_ocean_api.models.TagMetadata
        :keyword volumes: Tagged Resource Statistics include metadata regarding the resource type that
         has been tagged.
        :paramtype volumes: ~digital_ocean_api.models.TagMetadata
        :keyword volume_snapshots: Tagged Resource Statistics include metadata regarding the resource
         type that has been tagged.
        :paramtype volume_snapshots: ~digital_ocean_api.models.TagMetadata
        :keyword databases: Tagged Resource Statistics include metadata regarding the resource type
         that has been tagged.
        :paramtype databases: ~digital_ocean_api.models.TagMetadata
        """
        super(Components1Jlkn4DSchemasTagPropertiesResourcesAllof1, self).__init__(**kwargs)
        self.droplets = droplets
        self.imgages = imgages
        self.volumes = volumes
        self.volume_snapshots = volume_snapshots
        self.databases = databases


class Components63Q9DzResponsesAllActionsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components63Q9DzResponsesAllActionsContentApplicationJsonSchemaAllof0.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.Action]
    """

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[Action]'},
    }

    def __init__(
        self,
        *,
        actions: Optional[List["_models.Action"]] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.Action]
        """
        super(Components63Q9DzResponsesAllActionsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.actions = actions


class Components1L7Rji4ResponsesAllActionsContentApplicationJsonSchema(Pagination, Meta, Components63Q9DzResponsesAllActionsContentApplicationJsonSchemaAllof0):
    """Components1L7Rji4ResponsesAllActionsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.Action]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[Action]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        actions: Optional[List["_models.Action"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.Action]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1L7Rji4ResponsesAllActionsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, actions=actions, **kwargs)
        self.actions = actions
        self.meta = meta
        self.links = links


class Components1Le3PgsResponsesAllCertificatesContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Le3PgsResponsesAllCertificatesContentApplicationJsonSchemaAllof0.

    :ivar certificates:
    :vartype certificates: list[~digital_ocean_api.models.Certificate]
    """

    _attribute_map = {
        'certificates': {'key': 'certificates', 'type': '[Certificate]'},
    }

    def __init__(
        self,
        *,
        certificates: Optional[List["_models.Certificate"]] = None,
        **kwargs
    ):
        """
        :keyword certificates:
        :paramtype certificates: list[~digital_ocean_api.models.Certificate]
        """
        super(Components1Le3PgsResponsesAllCertificatesContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.certificates = certificates


class Components1MkvgnzResponsesVolumeActionContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1MkvgnzResponsesVolumeActionContentApplicationJsonSchema.

    :ivar action:
    :vartype action: ~digital_ocean_api.models.VolumeAction
    """

    _attribute_map = {
        'action': {'key': 'action', 'type': 'VolumeAction'},
    }

    def __init__(
        self,
        *,
        action: Optional["_models.VolumeAction"] = None,
        **kwargs
    ):
        """
        :keyword action:
        :paramtype action: ~digital_ocean_api.models.VolumeAction
        """
        super(Components1MkvgnzResponsesVolumeActionContentApplicationJsonSchema, self).__init__(**kwargs)
        self.action = action


class Components1MywxwzResponsesAllLoadBalancersContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1MywxwzResponsesAllLoadBalancersContentApplicationJsonSchemaAllof0.

    :ivar load_balancers:
    :vartype load_balancers: list[~digital_ocean_api.models.LoadBalancer]
    """

    _attribute_map = {
        'load_balancers': {'key': 'load_balancers', 'type': '[LoadBalancer]'},
    }

    def __init__(
        self,
        *,
        load_balancers: Optional[List["_models.LoadBalancer"]] = None,
        **kwargs
    ):
        """
        :keyword load_balancers:
        :paramtype load_balancers: list[~digital_ocean_api.models.LoadBalancer]
        """
        super(Components1MywxwzResponsesAllLoadBalancersContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.load_balancers = load_balancers


class ComponentsXghsoiResponsesAllCdnEndpointsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsXghsoiResponsesAllCdnEndpointsContentApplicationJsonSchemaAllof0.

    :ivar endpoints:
    :vartype endpoints: list[~digital_ocean_api.models.CdnEndpoint]
    """

    _attribute_map = {
        'endpoints': {'key': 'endpoints', 'type': '[CdnEndpoint]'},
    }

    def __init__(
        self,
        *,
        endpoints: Optional[List["_models.CdnEndpoint"]] = None,
        **kwargs
    ):
        """
        :keyword endpoints:
        :paramtype endpoints: list[~digital_ocean_api.models.CdnEndpoint]
        """
        super(ComponentsXghsoiResponsesAllCdnEndpointsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.endpoints = endpoints


class Components1Odkfm1ResponsesAllCdnEndpointsContentApplicationJsonSchema(Pagination, Meta, ComponentsXghsoiResponsesAllCdnEndpointsContentApplicationJsonSchemaAllof0):
    """Components1Odkfm1ResponsesAllCdnEndpointsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar endpoints:
    :vartype endpoints: list[~digital_ocean_api.models.CdnEndpoint]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'endpoints': {'key': 'endpoints', 'type': '[CdnEndpoint]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        endpoints: Optional[List["_models.CdnEndpoint"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword endpoints:
        :paramtype endpoints: list[~digital_ocean_api.models.CdnEndpoint]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1Odkfm1ResponsesAllCdnEndpointsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, endpoints=endpoints, **kwargs)
        self.endpoints = endpoints
        self.meta = meta
        self.links = links


class Components1OgskmqResponsesDatabaseBackupsContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1OgskmqResponsesDatabaseBackupsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar backups: Required.
    :vartype backups: list[~digital_ocean_api.models.Backup]
    """

    _validation = {
        'backups': {'required': True},
    }

    _attribute_map = {
        'backups': {'key': 'backups', 'type': '[Backup]'},
    }

    def __init__(
        self,
        *,
        backups: List["_models.Backup"],
        **kwargs
    ):
        """
        :keyword backups: Required.
        :paramtype backups: list[~digital_ocean_api.models.Backup]
        """
        super(Components1OgskmqResponsesDatabaseBackupsContentApplicationJsonSchema, self).__init__(**kwargs)
        self.backups = backups


class Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema.

    :ivar firewall:
    :vartype firewall: ~digital_ocean_api.models.Firewall
    """

    _attribute_map = {
        'firewall': {'key': 'firewall', 'type': 'Firewall'},
    }

    def __init__(
        self,
        *,
        firewall: Optional["_models.Firewall"] = None,
        **kwargs
    ):
        """
        :keyword firewall:
        :paramtype firewall: ~digital_ocean_api.models.Firewall
        """
        super(Components1Ppd4D8ResponsesCreateFirewallResponseContentApplicationJsonSchema, self).__init__(**kwargs)
        self.firewall = firewall


class Components1Pws2FuResponsesFloatingIpContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Pws2FuResponsesFloatingIpContentApplicationJsonSchema.

    :ivar floating_ip:
    :vartype floating_ip: ~digital_ocean_api.models.FloatingIp
    """

    _attribute_map = {
        'floating_ip': {'key': 'floating_ip', 'type': 'FloatingIp'},
    }

    def __init__(
        self,
        *,
        floating_ip: Optional["_models.FloatingIp"] = None,
        **kwargs
    ):
        """
        :keyword floating_ip:
        :paramtype floating_ip: ~digital_ocean_api.models.FloatingIp
        """
        super(Components1Pws2FuResponsesFloatingIpContentApplicationJsonSchema, self).__init__(**kwargs)
        self.floating_ip = floating_ip


class Components1Pxj82UResponsesAllRegionsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Pxj82UResponsesAllRegionsContentApplicationJsonSchemaAllof0.

    All required parameters must be populated in order to send to Azure.

    :ivar regions: Required.
    :vartype regions: list[~digital_ocean_api.models.Region]
    """

    _validation = {
        'regions': {'required': True},
    }

    _attribute_map = {
        'regions': {'key': 'regions', 'type': '[Region]'},
    }

    def __init__(
        self,
        *,
        regions: List["_models.Region"],
        **kwargs
    ):
        """
        :keyword regions: Required.
        :paramtype regions: list[~digital_ocean_api.models.Region]
        """
        super(Components1Pxj82UResponsesAllRegionsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.regions = regions


class Components1Q4BgpwResponsesInvoicesContentApplicationJsonSchema(Pagination, Meta, Components171RlqzResponsesInvoicesContentApplicationJsonSchemaAllof0):
    """Components1Q4BgpwResponsesInvoicesContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar invoices:
    :vartype invoices: list[~digital_ocean_api.models.InvoicePreview]
    :ivar invoice_preview: The invoice preview.
    :vartype invoice_preview: ~digital_ocean_api.models.InvoicePreview
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'invoices': {'key': 'invoices', 'type': '[InvoicePreview]'},
        'invoice_preview': {'key': 'invoice_preview', 'type': 'InvoicePreview'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        invoices: Optional[List["_models.InvoicePreview"]] = None,
        invoice_preview: Optional["_models.InvoicePreview"] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword invoices:
        :paramtype invoices: list[~digital_ocean_api.models.InvoicePreview]
        :keyword invoice_preview: The invoice preview.
        :paramtype invoice_preview: ~digital_ocean_api.models.InvoicePreview
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1Q4BgpwResponsesInvoicesContentApplicationJsonSchema, self).__init__(links=links, meta=meta, invoices=invoices, invoice_preview=invoice_preview, **kwargs)
        self.invoices = invoices
        self.invoice_preview = invoice_preview
        self.meta = meta
        self.links = links


class Components1Roprh1ResponsesDatabaseConfigContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Roprh1ResponsesDatabaseConfigContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar config: Required.
    :vartype config: any
    """

    _validation = {
        'config': {'required': True},
    }

    _attribute_map = {
        'config': {'key': 'config', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        config: Any,
        **kwargs
    ):
        """
        :keyword config: Required.
        :paramtype config: any
        """
        super(Components1Roprh1ResponsesDatabaseConfigContentApplicationJsonSchema, self).__init__(**kwargs)
        self.config = config


class Components1RzambuResponsesAccountContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1RzambuResponsesAccountContentApplicationJsonSchema.

    :ivar account:
    :vartype account: ~digital_ocean_api.models.Account
    """

    _attribute_map = {
        'account': {'key': 'account', 'type': 'Account'},
    }

    def __init__(
        self,
        *,
        account: Optional["_models.Account"] = None,
        **kwargs
    ):
        """
        :keyword account:
        :paramtype account: ~digital_ocean_api.models.Account
        """
        super(Components1RzambuResponsesAccountContentApplicationJsonSchema, self).__init__(**kwargs)
        self.account = account


class Components1Rzg8D5ResponsesExistingNodePoolContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Rzg8D5ResponsesExistingNodePoolContentApplicationJsonSchema.

    :ivar node_pool:
    :vartype node_pool: ~digital_ocean_api.models.KubernetesNodePool
    """

    _attribute_map = {
        'node_pool': {'key': 'node_pool', 'type': 'KubernetesNodePool'},
    }

    def __init__(
        self,
        *,
        node_pool: Optional["_models.KubernetesNodePool"] = None,
        **kwargs
    ):
        """
        :keyword node_pool:
        :paramtype node_pool: ~digital_ocean_api.models.KubernetesNodePool
        """
        super(Components1Rzg8D5ResponsesExistingNodePoolContentApplicationJsonSchema, self).__init__(**kwargs)
        self.node_pool = node_pool


class Components1Sa8LwhResponsesBillingHistoryContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components1Sa8LwhResponsesBillingHistoryContentApplicationJsonSchemaAllof0.

    All required parameters must be populated in order to send to Azure.

    :ivar billing_history: Required.
    :vartype billing_history: list[~digital_ocean_api.models.BillingHistory]
    """

    _validation = {
        'billing_history': {'required': True},
    }

    _attribute_map = {
        'billing_history': {'key': 'billing_history', 'type': '[BillingHistory]'},
    }

    def __init__(
        self,
        *,
        billing_history: List["_models.BillingHistory"],
        **kwargs
    ):
        """
        :keyword billing_history: Required.
        :paramtype billing_history: list[~digital_ocean_api.models.BillingHistory]
        """
        super(Components1Sa8LwhResponsesBillingHistoryContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.billing_history = billing_history


class Components1UmkrblResponsesProjectsListContentApplicationJsonSchema(Pagination, Meta, Components1IxwwnaResponsesProjectsListContentApplicationJsonSchemaAllof0):
    """Components1UmkrblResponsesProjectsListContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar projects:
    :vartype projects: list[~digital_ocean_api.models.Project]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'projects': {'key': 'projects', 'type': '[Project]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        projects: Optional[List["_models.Project"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword projects:
        :paramtype projects: list[~digital_ocean_api.models.Project]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1UmkrblResponsesProjectsListContentApplicationJsonSchema, self).__init__(links=links, meta=meta, projects=projects, **kwargs)
        self.projects = projects
        self.meta = meta
        self.links = links


class Components1Uwgn6WResponsesPutFirewallResponseContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Uwgn6WResponsesPutFirewallResponseContentApplicationJsonSchema.

    :ivar firewall:
    :vartype firewall: ~digital_ocean_api.models.Firewall
    """

    _attribute_map = {
        'firewall': {'key': 'firewall', 'type': 'Firewall'},
    }

    def __init__(
        self,
        *,
        firewall: Optional["_models.Firewall"] = None,
        **kwargs
    ):
        """
        :keyword firewall:
        :paramtype firewall: ~digital_ocean_api.models.Firewall
        """
        super(Components1Uwgn6WResponsesPutFirewallResponseContentApplicationJsonSchema, self).__init__(**kwargs)
        self.firewall = firewall


class Components1Vf55PaResponsesExistingImageContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Vf55PaResponsesExistingImageContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar image: Required.
    :vartype image: ~digital_ocean_api.models.Image
    """

    _validation = {
        'image': {'required': True},
    }

    _attribute_map = {
        'image': {'key': 'image', 'type': 'Image'},
    }

    def __init__(
        self,
        *,
        image: "_models.Image",
        **kwargs
    ):
        """
        :keyword image: Required.
        :paramtype image: ~digital_ocean_api.models.Image
        """
        super(Components1Vf55PaResponsesExistingImageContentApplicationJsonSchema, self).__init__(**kwargs)
        self.image = image


class SubscriptionTierExtended(msrest.serialization.Model):
    """SubscriptionTierExtended.

    :ivar eligible: A boolean indicating whether your account it eligible to use a certain
     subscription tier.
    :vartype eligible: bool
    :ivar eligibility_reasons: If your account is not eligible to use a certain subscription tier,
     this will include a list of reasons that prevent you from using the tier.
    :vartype eligibility_reasons: list[str or
     ~digital_ocean_api.models.SubscriptionTierExtendedEligibilityReasonsItem]
    """

    _attribute_map = {
        'eligible': {'key': 'eligible', 'type': 'bool'},
        'eligibility_reasons': {'key': 'eligibility_reasons', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        eligible: Optional[bool] = None,
        eligibility_reasons: Optional[List[Union[str, "_models.SubscriptionTierExtendedEligibilityReasonsItem"]]] = None,
        **kwargs
    ):
        """
        :keyword eligible: A boolean indicating whether your account it eligible to use a certain
         subscription tier.
        :paramtype eligible: bool
        :keyword eligibility_reasons: If your account is not eligible to use a certain subscription
         tier, this will include a list of reasons that prevent you from using the tier.
        :paramtype eligibility_reasons: list[str or
         ~digital_ocean_api.models.SubscriptionTierExtendedEligibilityReasonsItem]
        """
        super(SubscriptionTierExtended, self).__init__(**kwargs)
        self.eligible = eligible
        self.eligibility_reasons = eligibility_reasons


class SubscriptionTierBase(msrest.serialization.Model):
    """SubscriptionTierBase.

    :ivar name: The name of the subscription tier.
    :vartype name: str
    :ivar slug: The slug identifier of the subscription tier.
    :vartype slug: str
    :ivar included_repositories: The number of repositories included in the subscription tier.
     ``0`` indicates that the subscription tier includes unlimited repositories.
    :vartype included_repositories: int
    :ivar included_storage_bytes: The amount of storage included in the subscription tier in bytes.
    :vartype included_storage_bytes: int
    :ivar allow_storage_overage: A boolean indicating whether the subscription tier supports
     additional storage above what is included in the base plan at an additional cost per GiB used.
    :vartype allow_storage_overage: bool
    :ivar included_bandwidth_bytes: The amount of outbound data transfer included in the
     subscription tier in bytes.
    :vartype included_bandwidth_bytes: int
    :ivar monthly_price_in_cents: The monthly cost of the subscription tier in cents.
    :vartype monthly_price_in_cents: int
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'included_repositories': {'key': 'included_repositories', 'type': 'int'},
        'included_storage_bytes': {'key': 'included_storage_bytes', 'type': 'int'},
        'allow_storage_overage': {'key': 'allow_storage_overage', 'type': 'bool'},
        'included_bandwidth_bytes': {'key': 'included_bandwidth_bytes', 'type': 'int'},
        'monthly_price_in_cents': {'key': 'monthly_price_in_cents', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        slug: Optional[str] = None,
        included_repositories: Optional[int] = None,
        included_storage_bytes: Optional[int] = None,
        allow_storage_overage: Optional[bool] = None,
        included_bandwidth_bytes: Optional[int] = None,
        monthly_price_in_cents: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword name: The name of the subscription tier.
        :paramtype name: str
        :keyword slug: The slug identifier of the subscription tier.
        :paramtype slug: str
        :keyword included_repositories: The number of repositories included in the subscription tier.
         ``0`` indicates that the subscription tier includes unlimited repositories.
        :paramtype included_repositories: int
        :keyword included_storage_bytes: The amount of storage included in the subscription tier in
         bytes.
        :paramtype included_storage_bytes: int
        :keyword allow_storage_overage: A boolean indicating whether the subscription tier supports
         additional storage above what is included in the base plan at an additional cost per GiB used.
        :paramtype allow_storage_overage: bool
        :keyword included_bandwidth_bytes: The amount of outbound data transfer included in the
         subscription tier in bytes.
        :paramtype included_bandwidth_bytes: int
        :keyword monthly_price_in_cents: The monthly cost of the subscription tier in cents.
        :paramtype monthly_price_in_cents: int
        """
        super(SubscriptionTierBase, self).__init__(**kwargs)
        self.name = name
        self.slug = slug
        self.included_repositories = included_repositories
        self.included_storage_bytes = included_storage_bytes
        self.allow_storage_overage = allow_storage_overage
        self.included_bandwidth_bytes = included_bandwidth_bytes
        self.monthly_price_in_cents = monthly_price_in_cents


class Components1Vh7GehResponsesRegistryOptionsResponseContentApplicationJsonSchemaPropertiesOptionsPropertiesSubscriptionTiersItems(SubscriptionTierBase, SubscriptionTierExtended):
    """Components1Vh7GehResponsesRegistryOptionsResponseContentApplicationJsonSchemaPropertiesOptionsPropertiesSubscriptionTiersItems.

    :ivar eligible: A boolean indicating whether your account it eligible to use a certain
     subscription tier.
    :vartype eligible: bool
    :ivar eligibility_reasons: If your account is not eligible to use a certain subscription tier,
     this will include a list of reasons that prevent you from using the tier.
    :vartype eligibility_reasons: list[str or
     ~digital_ocean_api.models.SubscriptionTierExtendedEligibilityReasonsItem]
    :ivar name: The name of the subscription tier.
    :vartype name: str
    :ivar slug: The slug identifier of the subscription tier.
    :vartype slug: str
    :ivar included_repositories: The number of repositories included in the subscription tier.
     ``0`` indicates that the subscription tier includes unlimited repositories.
    :vartype included_repositories: int
    :ivar included_storage_bytes: The amount of storage included in the subscription tier in bytes.
    :vartype included_storage_bytes: int
    :ivar allow_storage_overage: A boolean indicating whether the subscription tier supports
     additional storage above what is included in the base plan at an additional cost per GiB used.
    :vartype allow_storage_overage: bool
    :ivar included_bandwidth_bytes: The amount of outbound data transfer included in the
     subscription tier in bytes.
    :vartype included_bandwidth_bytes: int
    :ivar monthly_price_in_cents: The monthly cost of the subscription tier in cents.
    :vartype monthly_price_in_cents: int
    """

    _attribute_map = {
        'eligible': {'key': 'eligible', 'type': 'bool'},
        'eligibility_reasons': {'key': 'eligibility_reasons', 'type': '[str]'},
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'included_repositories': {'key': 'included_repositories', 'type': 'int'},
        'included_storage_bytes': {'key': 'included_storage_bytes', 'type': 'int'},
        'allow_storage_overage': {'key': 'allow_storage_overage', 'type': 'bool'},
        'included_bandwidth_bytes': {'key': 'included_bandwidth_bytes', 'type': 'int'},
        'monthly_price_in_cents': {'key': 'monthly_price_in_cents', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        eligible: Optional[bool] = None,
        eligibility_reasons: Optional[List[Union[str, "_models.SubscriptionTierExtendedEligibilityReasonsItem"]]] = None,
        name: Optional[str] = None,
        slug: Optional[str] = None,
        included_repositories: Optional[int] = None,
        included_storage_bytes: Optional[int] = None,
        allow_storage_overage: Optional[bool] = None,
        included_bandwidth_bytes: Optional[int] = None,
        monthly_price_in_cents: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword eligible: A boolean indicating whether your account it eligible to use a certain
         subscription tier.
        :paramtype eligible: bool
        :keyword eligibility_reasons: If your account is not eligible to use a certain subscription
         tier, this will include a list of reasons that prevent you from using the tier.
        :paramtype eligibility_reasons: list[str or
         ~digital_ocean_api.models.SubscriptionTierExtendedEligibilityReasonsItem]
        :keyword name: The name of the subscription tier.
        :paramtype name: str
        :keyword slug: The slug identifier of the subscription tier.
        :paramtype slug: str
        :keyword included_repositories: The number of repositories included in the subscription tier.
         ``0`` indicates that the subscription tier includes unlimited repositories.
        :paramtype included_repositories: int
        :keyword included_storage_bytes: The amount of storage included in the subscription tier in
         bytes.
        :paramtype included_storage_bytes: int
        :keyword allow_storage_overage: A boolean indicating whether the subscription tier supports
         additional storage above what is included in the base plan at an additional cost per GiB used.
        :paramtype allow_storage_overage: bool
        :keyword included_bandwidth_bytes: The amount of outbound data transfer included in the
         subscription tier in bytes.
        :paramtype included_bandwidth_bytes: int
        :keyword monthly_price_in_cents: The monthly cost of the subscription tier in cents.
        :paramtype monthly_price_in_cents: int
        """
        super(Components1Vh7GehResponsesRegistryOptionsResponseContentApplicationJsonSchemaPropertiesOptionsPropertiesSubscriptionTiersItems, self).__init__(name=name, slug=slug, included_repositories=included_repositories, included_storage_bytes=included_storage_bytes, allow_storage_overage=allow_storage_overage, included_bandwidth_bytes=included_bandwidth_bytes, monthly_price_in_cents=monthly_price_in_cents, eligible=eligible, eligibility_reasons=eligibility_reasons, **kwargs)
        self.eligible = eligible
        self.eligibility_reasons = eligibility_reasons
        self.name = name
        self.slug = slug
        self.included_repositories = included_repositories
        self.included_storage_bytes = included_storage_bytes
        self.allow_storage_overage = allow_storage_overage
        self.included_bandwidth_bytes = included_bandwidth_bytes
        self.monthly_price_in_cents = monthly_price_in_cents


class Components1WaekvrResponsesUpdatedImageContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1WaekvrResponsesUpdatedImageContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar image: Required.
    :vartype image: ~digital_ocean_api.models.Image
    """

    _validation = {
        'image': {'required': True},
    }

    _attribute_map = {
        'image': {'key': 'image', 'type': 'Image'},
    }

    def __init__(
        self,
        *,
        image: "_models.Image",
        **kwargs
    ):
        """
        :keyword image: Required.
        :paramtype image: ~digital_ocean_api.models.Image
        """
        super(Components1WaekvrResponsesUpdatedImageContentApplicationJsonSchema, self).__init__(**kwargs)
        self.image = image


class Components1WdhcpfResponsesDomainRecordContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1WdhcpfResponsesDomainRecordContentApplicationJsonSchema.

    :ivar domain_record:
    :vartype domain_record: ~digital_ocean_api.models.DomainRecord
    """

    _attribute_map = {
        'domain_record': {'key': 'domain_record', 'type': 'DomainRecord'},
    }

    def __init__(
        self,
        *,
        domain_record: Optional["_models.DomainRecord"] = None,
        **kwargs
    ):
        """
        :keyword domain_record:
        :paramtype domain_record: ~digital_ocean_api.models.DomainRecord
        """
        super(Components1WdhcpfResponsesDomainRecordContentApplicationJsonSchema, self).__init__(**kwargs)
        self.domain_record = domain_record


class Components1Wk333ZResponsesUsersContentApplicationJsonSchema(msrest.serialization.Model):
    """Components1Wk333ZResponsesUsersContentApplicationJsonSchema.

    :ivar users:
    :vartype users: list[~digital_ocean_api.models.DatabaseUser]
    """

    _attribute_map = {
        'users': {'key': 'users', 'type': '[DatabaseUser]'},
    }

    def __init__(
        self,
        *,
        users: Optional[List["_models.DatabaseUser"]] = None,
        **kwargs
    ):
        """
        :keyword users:
        :paramtype users: list[~digital_ocean_api.models.DatabaseUser]
        """
        super(Components1Wk333ZResponsesUsersContentApplicationJsonSchema, self).__init__(**kwargs)
        self.users = users


class Components4Ss6AcResponsesFloatingIpListContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components4Ss6AcResponsesFloatingIpListContentApplicationJsonSchemaAllof0.

    :ivar floating_ips:
    :vartype floating_ips: list[~digital_ocean_api.models.FloatingIp]
    """

    _attribute_map = {
        'floating_ips': {'key': 'floating_ips', 'type': '[FloatingIp]'},
    }

    def __init__(
        self,
        *,
        floating_ips: Optional[List["_models.FloatingIp"]] = None,
        **kwargs
    ):
        """
        :keyword floating_ips:
        :paramtype floating_ips: list[~digital_ocean_api.models.FloatingIp]
        """
        super(Components4Ss6AcResponsesFloatingIpListContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.floating_ips = floating_ips


class Components1Ytaq4GResponsesFloatingIpListContentApplicationJsonSchema(Pagination, Meta, Components4Ss6AcResponsesFloatingIpListContentApplicationJsonSchemaAllof0):
    """Components1Ytaq4GResponsesFloatingIpListContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar floating_ips:
    :vartype floating_ips: list[~digital_ocean_api.models.FloatingIp]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'floating_ips': {'key': 'floating_ips', 'type': '[FloatingIp]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        floating_ips: Optional[List["_models.FloatingIp"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword floating_ips:
        :paramtype floating_ips: list[~digital_ocean_api.models.FloatingIp]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components1Ytaq4GResponsesFloatingIpListContentApplicationJsonSchema, self).__init__(links=links, meta=meta, floating_ips=floating_ips, **kwargs)
        self.floating_ips = floating_ips
        self.meta = meta
        self.links = links


class Components2S56XuResponsesAllVolumesContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components2S56XuResponsesAllVolumesContentApplicationJsonSchemaAllof0.

    All required parameters must be populated in order to send to Azure.

    :ivar volumes: Required. Array of volumes.
    :vartype volumes: list[~digital_ocean_api.models.VolumeFull]
    """

    _validation = {
        'volumes': {'required': True},
    }

    _attribute_map = {
        'volumes': {'key': 'volumes', 'type': '[VolumeFull]'},
    }

    def __init__(
        self,
        *,
        volumes: List["_models.VolumeFull"],
        **kwargs
    ):
        """
        :keyword volumes: Required. Array of volumes.
        :paramtype volumes: list[~digital_ocean_api.models.VolumeFull]
        """
        super(Components2S56XuResponsesAllVolumesContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.volumes = volumes


class ComponentsKgjf4JResponsesResourcesListContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsKgjf4JResponsesResourcesListContentApplicationJsonSchemaAllof0.

    :ivar resources:
    :vartype resources: list[~digital_ocean_api.models.Resource]
    """

    _attribute_map = {
        'resources': {'key': 'resources', 'type': '[Resource]'},
    }

    def __init__(
        self,
        *,
        resources: Optional[List["_models.Resource"]] = None,
        **kwargs
    ):
        """
        :keyword resources:
        :paramtype resources: list[~digital_ocean_api.models.Resource]
        """
        super(ComponentsKgjf4JResponsesResourcesListContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.resources = resources


class Components387DfsResponsesResourcesListContentApplicationJsonSchema(Pagination, Meta, ComponentsKgjf4JResponsesResourcesListContentApplicationJsonSchemaAllof0):
    """Components387DfsResponsesResourcesListContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar resources:
    :vartype resources: list[~digital_ocean_api.models.Resource]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'resources': {'key': 'resources', 'type': '[Resource]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        resources: Optional[List["_models.Resource"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword resources:
        :paramtype resources: list[~digital_ocean_api.models.Resource]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components387DfsResponsesResourcesListContentApplicationJsonSchema, self).__init__(links=links, meta=meta, resources=resources, **kwargs)
        self.resources = resources
        self.meta = meta
        self.links = links


class Components39Hr3IResponsesAllVolumeActionsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """Components39Hr3IResponsesAllVolumeActionsContentApplicationJsonSchemaAllof0.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.VolumeAction]
    """

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[VolumeAction]'},
    }

    def __init__(
        self,
        *,
        actions: Optional[List["_models.VolumeAction"]] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.VolumeAction]
        """
        super(Components39Hr3IResponsesAllVolumeActionsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.actions = actions


class Components468A3JResponsesAllRepositoriesV2ContentApplicationJsonSchema(Pagination, Meta, Components1Hqp2PyResponsesAllRepositoriesV2ContentApplicationJsonSchemaAllof0):
    """Components468A3JResponsesAllRepositoriesV2ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar repositories:
    :vartype repositories: list[~digital_ocean_api.models.RepositoryV2]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'repositories': {'key': 'repositories', 'type': '[RepositoryV2]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        repositories: Optional[List["_models.RepositoryV2"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword repositories:
        :paramtype repositories: list[~digital_ocean_api.models.RepositoryV2]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components468A3JResponsesAllRepositoriesV2ContentApplicationJsonSchema, self).__init__(links=links, meta=meta, repositories=repositories, **kwargs)
        self.repositories = repositories
        self.meta = meta
        self.links = links


class Components4Cm61PResponsesAllCertificatesContentApplicationJsonSchema(Pagination, Meta, Components1Le3PgsResponsesAllCertificatesContentApplicationJsonSchemaAllof0):
    """Components4Cm61PResponsesAllCertificatesContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar certificates:
    :vartype certificates: list[~digital_ocean_api.models.Certificate]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'certificates': {'key': 'certificates', 'type': '[Certificate]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        certificates: Optional[List["_models.Certificate"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword certificates:
        :paramtype certificates: list[~digital_ocean_api.models.Certificate]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components4Cm61PResponsesAllCertificatesContentApplicationJsonSchema, self).__init__(links=links, meta=meta, certificates=certificates, **kwargs)
        self.certificates = certificates
        self.meta = meta
        self.links = links


class Components6YrwmlResponsesDefaultProjectContentApplicationJsonSchema(msrest.serialization.Model):
    """Components6YrwmlResponsesDefaultProjectContentApplicationJsonSchema.

    :ivar project:
    :vartype project: ~digital_ocean_api.models.Project
    """

    _attribute_map = {
        'project': {'key': 'project', 'type': 'Project'},
    }

    def __init__(
        self,
        *,
        project: Optional["_models.Project"] = None,
        **kwargs
    ):
        """
        :keyword project:
        :paramtype project: ~digital_ocean_api.models.Project
        """
        super(Components6YrwmlResponsesDefaultProjectContentApplicationJsonSchema, self).__init__(**kwargs)
        self.project = project


class Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema(msrest.serialization.Model):
    """Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema.

    :ivar project:
    :vartype project: ~digital_ocean_api.models.Project
    """

    _attribute_map = {
        'project': {'key': 'project', 'type': 'Project'},
    }

    def __init__(
        self,
        *,
        project: Optional["_models.Project"] = None,
        **kwargs
    ):
        """
        :keyword project:
        :paramtype project: ~digital_ocean_api.models.Project
        """
        super(Components7Bz540ResponsesExistingProjectContentApplicationJsonSchema, self).__init__(**kwargs)
        self.project = project


class Components7K4Gv0ResponsesDatabaseClustersContentApplicationJsonSchema(msrest.serialization.Model):
    """Components7K4Gv0ResponsesDatabaseClustersContentApplicationJsonSchema.

    :ivar databases:
    :vartype databases: list[~digital_ocean_api.models.DatabaseCluster]
    """

    _attribute_map = {
        'databases': {'key': 'databases', 'type': '[DatabaseCluster]'},
    }

    def __init__(
        self,
        *,
        databases: Optional[List["_models.DatabaseCluster"]] = None,
        **kwargs
    ):
        """
        :keyword databases:
        :paramtype databases: list[~digital_ocean_api.models.DatabaseCluster]
        """
        super(Components7K4Gv0ResponsesDatabaseClustersContentApplicationJsonSchema, self).__init__(**kwargs)
        self.databases = databases


class Components84Lqo1ResponsesDatabasesContentApplicationJsonSchema(msrest.serialization.Model):
    """Components84Lqo1ResponsesDatabasesContentApplicationJsonSchema.

    :ivar dbs:
    :vartype dbs: list[~digital_ocean_api.models.Database]
    """

    _attribute_map = {
        'dbs': {'key': 'dbs', 'type': '[Database]'},
    }

    def __init__(
        self,
        *,
        dbs: Optional[List["_models.Database"]] = None,
        **kwargs
    ):
        """
        :keyword dbs:
        :paramtype dbs: list[~digital_ocean_api.models.Database]
        """
        super(Components84Lqo1ResponsesDatabasesContentApplicationJsonSchema, self).__init__(**kwargs)
        self.dbs = dbs


class Components8Tvwi3ResponsesConnectionPoolContentApplicationJsonSchema(msrest.serialization.Model):
    """Components8Tvwi3ResponsesConnectionPoolContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar pool: Required.
    :vartype pool: ~digital_ocean_api.models.ConnectionPool
    """

    _validation = {
        'pool': {'required': True},
    }

    _attribute_map = {
        'pool': {'key': 'pool', 'type': 'ConnectionPool'},
    }

    def __init__(
        self,
        *,
        pool: "_models.ConnectionPool",
        **kwargs
    ):
        """
        :keyword pool: Required.
        :paramtype pool: ~digital_ocean_api.models.ConnectionPool
        """
        super(Components8Tvwi3ResponsesConnectionPoolContentApplicationJsonSchema, self).__init__(**kwargs)
        self.pool = pool


class ComponentsB4R8U3ResponsesVpcMembersContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsB4R8U3ResponsesVpcMembersContentApplicationJsonSchemaAllof0.

    :ivar members:
    :vartype members: list[~digital_ocean_api.models.VpcMember]
    """

    _attribute_map = {
        'members': {'key': 'members', 'type': '[VpcMember]'},
    }

    def __init__(
        self,
        *,
        members: Optional[List["_models.VpcMember"]] = None,
        **kwargs
    ):
        """
        :keyword members:
        :paramtype members: list[~digital_ocean_api.models.VpcMember]
        """
        super(ComponentsB4R8U3ResponsesVpcMembersContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.members = members


class Components9Eqy7JResponsesVpcMembersContentApplicationJsonSchema(Pagination, Meta, ComponentsB4R8U3ResponsesVpcMembersContentApplicationJsonSchemaAllof0):
    """Components9Eqy7JResponsesVpcMembersContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar members:
    :vartype members: list[~digital_ocean_api.models.VpcMember]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'members': {'key': 'members', 'type': '[VpcMember]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        members: Optional[List["_models.VpcMember"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword members:
        :paramtype members: list[~digital_ocean_api.models.VpcMember]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components9Eqy7JResponsesVpcMembersContentApplicationJsonSchema, self).__init__(links=links, meta=meta, members=members, **kwargs)
        self.members = members
        self.meta = meta
        self.links = links


class ComponentsYfiiqgResponsesAllFirewallsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsYfiiqgResponsesAllFirewallsContentApplicationJsonSchemaAllof0.

    :ivar firewalls:
    :vartype firewalls: list[~digital_ocean_api.models.Firewall]
    """

    _attribute_map = {
        'firewalls': {'key': 'firewalls', 'type': '[Firewall]'},
    }

    def __init__(
        self,
        *,
        firewalls: Optional[List["_models.Firewall"]] = None,
        **kwargs
    ):
        """
        :keyword firewalls:
        :paramtype firewalls: list[~digital_ocean_api.models.Firewall]
        """
        super(ComponentsYfiiqgResponsesAllFirewallsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.firewalls = firewalls


class Components9Q18FmResponsesAllFirewallsContentApplicationJsonSchema(Pagination, Meta, ComponentsYfiiqgResponsesAllFirewallsContentApplicationJsonSchemaAllof0):
    """Components9Q18FmResponsesAllFirewallsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar firewalls:
    :vartype firewalls: list[~digital_ocean_api.models.Firewall]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'firewalls': {'key': 'firewalls', 'type': '[Firewall]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        firewalls: Optional[List["_models.Firewall"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword firewalls:
        :paramtype firewalls: list[~digital_ocean_api.models.Firewall]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(Components9Q18FmResponsesAllFirewallsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, firewalls=firewalls, **kwargs)
        self.firewalls = firewalls
        self.meta = meta
        self.links = links


class ComponentsMf1I3YResponsesAllDropletSnapshotsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsMf1I3YResponsesAllDropletSnapshotsContentApplicationJsonSchemaAllof0.

    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.DropletSnapshot]
    """

    _attribute_map = {
        'snapshots': {'key': 'snapshots', 'type': '[DropletSnapshot]'},
    }

    def __init__(
        self,
        *,
        snapshots: Optional[List["_models.DropletSnapshot"]] = None,
        **kwargs
    ):
        """
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.DropletSnapshot]
        """
        super(ComponentsMf1I3YResponsesAllDropletSnapshotsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.snapshots = snapshots


class ComponentsAa1O1RResponsesAllDropletSnapshotsContentApplicationJsonSchema(Pagination, Meta, ComponentsMf1I3YResponsesAllDropletSnapshotsContentApplicationJsonSchemaAllof0):
    """ComponentsAa1O1RResponsesAllDropletSnapshotsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.DropletSnapshot]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'snapshots': {'key': 'snapshots', 'type': '[DropletSnapshot]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        snapshots: Optional[List["_models.DropletSnapshot"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.DropletSnapshot]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsAa1O1RResponsesAllDropletSnapshotsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, snapshots=snapshots, **kwargs)
        self.snapshots = snapshots
        self.meta = meta
        self.links = links


class ComponentsAb9K5AResponsesListFirewallsResponseContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsAb9K5AResponsesListFirewallsResponseContentApplicationJsonSchemaAllof0.

    :ivar firewalls:
    :vartype firewalls: list[~digital_ocean_api.models.Firewall]
    """

    _attribute_map = {
        'firewalls': {'key': 'firewalls', 'type': '[Firewall]'},
    }

    def __init__(
        self,
        *,
        firewalls: Optional[List["_models.Firewall"]] = None,
        **kwargs
    ):
        """
        :keyword firewalls:
        :paramtype firewalls: list[~digital_ocean_api.models.Firewall]
        """
        super(ComponentsAb9K5AResponsesListFirewallsResponseContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.firewalls = firewalls


class ComponentsAplp5ResponsesAllDropletsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsAplp5ResponsesAllDropletsContentApplicationJsonSchemaAllof0.

    :ivar droplets:
    :vartype droplets: list[~digital_ocean_api.models.Droplet]
    """

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': '[Droplet]'},
    }

    def __init__(
        self,
        *,
        droplets: Optional[List["_models.Droplet"]] = None,
        **kwargs
    ):
        """
        :keyword droplets:
        :paramtype droplets: list[~digital_ocean_api.models.Droplet]
        """
        super(ComponentsAplp5ResponsesAllDropletsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.droplets = droplets


class ComponentsB1SfojResponsesDatabaseContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsB1SfojResponsesDatabaseContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar db: Required.
    :vartype db: ~digital_ocean_api.models.Database
    """

    _validation = {
        'db': {'required': True},
    }

    _attribute_map = {
        'db': {'key': 'db', 'type': 'Database'},
    }

    def __init__(
        self,
        *,
        db: "_models.Database",
        **kwargs
    ):
        """
        :keyword db: Required.
        :paramtype db: ~digital_ocean_api.models.Database
        """
        super(ComponentsB1SfojResponsesDatabaseContentApplicationJsonSchema, self).__init__(**kwargs)
        self.db = db


class ComponentsO23W2TResponsesAllImagesContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsO23W2TResponsesAllImagesContentApplicationJsonSchemaAllof0.

    All required parameters must be populated in order to send to Azure.

    :ivar images: Required.
    :vartype images: list[~digital_ocean_api.models.Image]
    """

    _validation = {
        'images': {'required': True},
    }

    _attribute_map = {
        'images': {'key': 'images', 'type': '[Image]'},
    }

    def __init__(
        self,
        *,
        images: List["_models.Image"],
        **kwargs
    ):
        """
        :keyword images: Required.
        :paramtype images: list[~digital_ocean_api.models.Image]
        """
        super(ComponentsO23W2TResponsesAllImagesContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.images = images


class ComponentsC9IahpResponsesAllImagesContentApplicationJsonSchema(Pagination, Meta, ComponentsO23W2TResponsesAllImagesContentApplicationJsonSchemaAllof0):
    """ComponentsC9IahpResponsesAllImagesContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar images: Required.
    :vartype images: list[~digital_ocean_api.models.Image]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'images': {'required': True},
        'meta': {'required': True},
    }

    _attribute_map = {
        'images': {'key': 'images', 'type': '[Image]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        images: List["_models.Image"],
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword images: Required.
        :paramtype images: list[~digital_ocean_api.models.Image]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsC9IahpResponsesAllImagesContentApplicationJsonSchema, self).__init__(links=links, meta=meta, images=images, **kwargs)
        self.images = images
        self.meta = meta
        self.links = links


class ComponentsChk4KxResponsesBillingHistoryContentApplicationJsonSchema(Pagination, Meta, Components1Sa8LwhResponsesBillingHistoryContentApplicationJsonSchemaAllof0):
    """ComponentsChk4KxResponsesBillingHistoryContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar billing_history: Required.
    :vartype billing_history: list[~digital_ocean_api.models.BillingHistory]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'billing_history': {'required': True},
        'meta': {'required': True},
    }

    _attribute_map = {
        'billing_history': {'key': 'billing_history', 'type': '[BillingHistory]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        billing_history: List["_models.BillingHistory"],
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword billing_history: Required.
        :paramtype billing_history: list[~digital_ocean_api.models.BillingHistory]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsChk4KxResponsesBillingHistoryContentApplicationJsonSchema, self).__init__(links=links, meta=meta, billing_history=billing_history, **kwargs)
        self.billing_history = billing_history
        self.meta = meta
        self.links = links


class ComponentsCmdw3WResponses1ClickCreateContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsCmdw3WResponses1ClickCreateContentApplicationJsonSchema.

    :ivar message: A message about the result of the request.
    :vartype message: str
    """

    _attribute_map = {
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        message: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword message: A message about the result of the request.
        :paramtype message: str
        """
        super(ComponentsCmdw3WResponses1ClickCreateContentApplicationJsonSchema, self).__init__(**kwargs)
        self.message = message


class ComponentsFuqdq5ResponsesAssignedResourcesListContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsFuqdq5ResponsesAssignedResourcesListContentApplicationJsonSchema.

    :ivar resources:
    :vartype resources: list[~digital_ocean_api.models.Resource]
    """

    _attribute_map = {
        'resources': {'key': 'resources', 'type': '[Resource]'},
    }

    def __init__(
        self,
        *,
        resources: Optional[List["_models.Resource"]] = None,
        **kwargs
    ):
        """
        :keyword resources:
        :paramtype resources: list[~digital_ocean_api.models.Resource]
        """
        super(ComponentsFuqdq5ResponsesAssignedResourcesListContentApplicationJsonSchema, self).__init__(**kwargs)
        self.resources = resources


class ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema.

    :ivar floating_ip:
    :vartype floating_ip: ~digital_ocean_api.models.FloatingIp
    :ivar links:
    :vartype links: ~digital_ocean_api.models.FloatingIpCreatedApplicationJsonProperties
    """

    _attribute_map = {
        'floating_ip': {'key': 'floating_ip', 'type': 'FloatingIp'},
        'links': {'key': 'links', 'type': 'FloatingIpCreatedApplicationJsonProperties'},
    }

    def __init__(
        self,
        *,
        floating_ip: Optional["_models.FloatingIp"] = None,
        links: Optional["_models.FloatingIpCreatedApplicationJsonProperties"] = None,
        **kwargs
    ):
        """
        :keyword floating_ip:
        :paramtype floating_ip: ~digital_ocean_api.models.FloatingIp
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.FloatingIpCreatedApplicationJsonProperties
        """
        super(ComponentsFwoxchResponsesFloatingIpCreatedContentApplicationJsonSchema, self).__init__(**kwargs)
        self.floating_ip = floating_ip
        self.links = links


class ComponentsG9R3Y8ResponsesAll1ClicksContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsG9R3Y8ResponsesAll1ClicksContentApplicationJsonSchema.

    :ivar one_clicks:
    :vartype one_clicks: list[~digital_ocean_api.models.OneClick]
    """

    _attribute_map = {
        'one_clicks': {'key': '1_clicks', 'type': '[OneClick]'},
    }

    def __init__(
        self,
        *,
        one_clicks: Optional[List["_models.OneClick"]] = None,
        **kwargs
    ):
        """
        :keyword one_clicks:
        :paramtype one_clicks: list[~digital_ocean_api.models.OneClick]
        """
        super(ComponentsG9R3Y8ResponsesAll1ClicksContentApplicationJsonSchema, self).__init__(**kwargs)
        self.one_clicks = one_clicks


class ComponentsH2S4NkResponsesExistingClusterContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsH2S4NkResponsesExistingClusterContentApplicationJsonSchema.

    :ivar kubernetes_cluster:
    :vartype kubernetes_cluster: ~digital_ocean_api.models.Cluster
    """

    _attribute_map = {
        'kubernetes_cluster': {'key': 'kubernetes_cluster', 'type': 'Cluster'},
    }

    def __init__(
        self,
        *,
        kubernetes_cluster: Optional["_models.Cluster"] = None,
        **kwargs
    ):
        """
        :keyword kubernetes_cluster:
        :paramtype kubernetes_cluster: ~digital_ocean_api.models.Cluster
        """
        super(ComponentsH2S4NkResponsesExistingClusterContentApplicationJsonSchema, self).__init__(**kwargs)
        self.kubernetes_cluster = kubernetes_cluster


class ComponentsH7SbeiResponsesUserContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsH7SbeiResponsesUserContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar user: Required.
    :vartype user: ~digital_ocean_api.models.DatabaseUser
    """

    _validation = {
        'user': {'required': True},
    }

    _attribute_map = {
        'user': {'key': 'user', 'type': 'DatabaseUser'},
    }

    def __init__(
        self,
        *,
        user: "_models.DatabaseUser",
        **kwargs
    ):
        """
        :keyword user: Required.
        :paramtype user: ~digital_ocean_api.models.DatabaseUser
        """
        super(ComponentsH7SbeiResponsesUserContentApplicationJsonSchema, self).__init__(**kwargs)
        self.user = user


class ComponentsHjzmbwResponsesExistingCertificateContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsHjzmbwResponsesExistingCertificateContentApplicationJsonSchema.

    :ivar certificate:
    :vartype certificate: ~digital_ocean_api.models.Certificate
    """

    _attribute_map = {
        'certificate': {'key': 'certificate', 'type': 'Certificate'},
    }

    def __init__(
        self,
        *,
        certificate: Optional["_models.Certificate"] = None,
        **kwargs
    ):
        """
        :keyword certificate:
        :paramtype certificate: ~digital_ocean_api.models.Certificate
        """
        super(ComponentsHjzmbwResponsesExistingCertificateContentApplicationJsonSchema, self).__init__(**kwargs)
        self.certificate = certificate


class ComponentsXsqptcResponsesAllDomainsResponseContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsXsqptcResponsesAllDomainsResponseContentApplicationJsonSchemaAllof0.

    All required parameters must be populated in order to send to Azure.

    :ivar domains: Required. Array of volumes.
    :vartype domains: list[~digital_ocean_api.models.Domain]
    """

    _validation = {
        'domains': {'required': True},
    }

    _attribute_map = {
        'domains': {'key': 'domains', 'type': '[Domain]'},
    }

    def __init__(
        self,
        *,
        domains: List["_models.Domain"],
        **kwargs
    ):
        """
        :keyword domains: Required. Array of volumes.
        :paramtype domains: list[~digital_ocean_api.models.Domain]
        """
        super(ComponentsXsqptcResponsesAllDomainsResponseContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.domains = domains


class ComponentsImganuResponsesAllDomainsResponseContentApplicationJsonSchema(Pagination, Meta, ComponentsXsqptcResponsesAllDomainsResponseContentApplicationJsonSchemaAllof0):
    """ComponentsImganuResponsesAllDomainsResponseContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar domains: Required. Array of volumes.
    :vartype domains: list[~digital_ocean_api.models.Domain]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'domains': {'required': True},
        'meta': {'required': True},
    }

    _attribute_map = {
        'domains': {'key': 'domains', 'type': '[Domain]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        domains: List["_models.Domain"],
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword domains: Required. Array of volumes.
        :paramtype domains: list[~digital_ocean_api.models.Domain]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsImganuResponsesAllDomainsResponseContentApplicationJsonSchema, self).__init__(links=links, meta=meta, domains=domains, **kwargs)
        self.domains = domains
        self.meta = meta
        self.links = links


class ComponentsJ8Bg3XResponsesExistingActionContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsJ8Bg3XResponsesExistingActionContentApplicationJsonSchema.

    :ivar action:
    :vartype action: ~digital_ocean_api.models.Action
    """

    _attribute_map = {
        'action': {'key': 'action', 'type': 'Action'},
    }

    def __init__(
        self,
        *,
        action: Optional["_models.Action"] = None,
        **kwargs
    ):
        """
        :keyword action:
        :paramtype action: ~digital_ocean_api.models.Action
        """
        super(ComponentsJ8Bg3XResponsesExistingActionContentApplicationJsonSchema, self).__init__(**kwargs)
        self.action = action


class ComponentsJhlieaResponsesAllRegionsContentApplicationJsonSchema(Pagination, Meta, Components1Pxj82UResponsesAllRegionsContentApplicationJsonSchemaAllof0):
    """ComponentsJhlieaResponsesAllRegionsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar regions: Required.
    :vartype regions: list[~digital_ocean_api.models.Region]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'regions': {'required': True},
        'meta': {'required': True},
    }

    _attribute_map = {
        'regions': {'key': 'regions', 'type': '[Region]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        regions: List["_models.Region"],
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword regions: Required.
        :paramtype regions: list[~digital_ocean_api.models.Region]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsJhlieaResponsesAllRegionsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, regions=regions, **kwargs)
        self.regions = regions
        self.meta = meta
        self.links = links


class ComponentsKlrpziResponsesAllVolumeActionsContentApplicationJsonSchema(Pagination, Meta, Components39Hr3IResponsesAllVolumeActionsContentApplicationJsonSchemaAllof0):
    """ComponentsKlrpziResponsesAllVolumeActionsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.VolumeAction]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[VolumeAction]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        actions: Optional[List["_models.VolumeAction"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.VolumeAction]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsKlrpziResponsesAllVolumeActionsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, actions=actions, **kwargs)
        self.actions = actions
        self.meta = meta
        self.links = links


class ComponentsO2Ak40ResponsesAllClustersContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsO2Ak40ResponsesAllClustersContentApplicationJsonSchemaAllof0.

    :ivar kubernetes_clusters:
    :vartype kubernetes_clusters: list[~digital_ocean_api.models.Cluster]
    """

    _attribute_map = {
        'kubernetes_clusters': {'key': 'kubernetes_clusters', 'type': '[Cluster]'},
    }

    def __init__(
        self,
        *,
        kubernetes_clusters: Optional[List["_models.Cluster"]] = None,
        **kwargs
    ):
        """
        :keyword kubernetes_clusters:
        :paramtype kubernetes_clusters: list[~digital_ocean_api.models.Cluster]
        """
        super(ComponentsO2Ak40ResponsesAllClustersContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.kubernetes_clusters = kubernetes_clusters


class ComponentsMgkfwfResponsesAllClustersContentApplicationJsonSchema(Pagination, Meta, ComponentsO2Ak40ResponsesAllClustersContentApplicationJsonSchemaAllof0):
    """ComponentsMgkfwfResponsesAllClustersContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar kubernetes_clusters:
    :vartype kubernetes_clusters: list[~digital_ocean_api.models.Cluster]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'kubernetes_clusters': {'key': 'kubernetes_clusters', 'type': '[Cluster]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        kubernetes_clusters: Optional[List["_models.Cluster"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword kubernetes_clusters:
        :paramtype kubernetes_clusters: list[~digital_ocean_api.models.Cluster]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsMgkfwfResponsesAllClustersContentApplicationJsonSchema, self).__init__(links=links, meta=meta, kubernetes_clusters=kubernetes_clusters, **kwargs)
        self.kubernetes_clusters = kubernetes_clusters
        self.meta = meta
        self.links = links


class ComponentsMr31FwResponsesCaContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsMr31FwResponsesCaContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar ca: Required.
    :vartype ca: ~digital_ocean_api.models.Ca
    """

    _validation = {
        'ca': {'required': True},
    }

    _attribute_map = {
        'ca': {'key': 'ca', 'type': 'Ca'},
    }

    def __init__(
        self,
        *,
        ca: "_models.Ca",
        **kwargs
    ):
        """
        :keyword ca: Required.
        :paramtype ca: ~digital_ocean_api.models.Ca
        """
        super(ComponentsMr31FwResponsesCaContentApplicationJsonSchema, self).__init__(**kwargs)
        self.ca = ca


class ComponentsMufb2AResponsesAllDropletsContentApplicationJsonSchema(Pagination, Meta, ComponentsAplp5ResponsesAllDropletsContentApplicationJsonSchemaAllof0):
    """ComponentsMufb2AResponsesAllDropletsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar droplets:
    :vartype droplets: list[~digital_ocean_api.models.Droplet]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': '[Droplet]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        droplets: Optional[List["_models.Droplet"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword droplets:
        :paramtype droplets: list[~digital_ocean_api.models.Droplet]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsMufb2AResponsesAllDropletsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, droplets=droplets, **kwargs)
        self.droplets = droplets
        self.meta = meta
        self.links = links


class ComponentsN31IopResponsesUpdatedClusterContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsN31IopResponsesUpdatedClusterContentApplicationJsonSchema.

    :ivar kubernetes_cluster:
    :vartype kubernetes_cluster: ~digital_ocean_api.models.Cluster
    """

    _attribute_map = {
        'kubernetes_cluster': {'key': 'kubernetes_cluster', 'type': 'Cluster'},
    }

    def __init__(
        self,
        *,
        kubernetes_cluster: Optional["_models.Cluster"] = None,
        **kwargs
    ):
        """
        :keyword kubernetes_cluster:
        :paramtype kubernetes_cluster: ~digital_ocean_api.models.Cluster
        """
        super(ComponentsN31IopResponsesUpdatedClusterContentApplicationJsonSchema, self).__init__(**kwargs)
        self.kubernetes_cluster = kubernetes_cluster


class ComponentsN4Czx7ResponsesAllNodePoolsContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsN4Czx7ResponsesAllNodePoolsContentApplicationJsonSchema.

    :ivar node_pools:
    :vartype node_pools: list[~digital_ocean_api.models.KubernetesNodePool]
    """

    _attribute_map = {
        'node_pools': {'key': 'node_pools', 'type': '[KubernetesNodePool]'},
    }

    def __init__(
        self,
        *,
        node_pools: Optional[List["_models.KubernetesNodePool"]] = None,
        **kwargs
    ):
        """
        :keyword node_pools:
        :paramtype node_pools: list[~digital_ocean_api.models.KubernetesNodePool]
        """
        super(ComponentsN4Czx7ResponsesAllNodePoolsContentApplicationJsonSchema, self).__init__(**kwargs)
        self.node_pools = node_pools


class ComponentsNbth3FResponsesExistingTagContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsNbth3FResponsesExistingTagContentApplicationJsonSchema.

    :ivar tag: A tag is a label that can be applied to a resource (currently Droplets, Images,
     Volumes, Volume Snapshots, and Database clusters) in order to better organize or facilitate the
     lookups and actions on it.
     Tags have two attributes: a user defined ``name`` attribute and an embedded ``resources``
     attribute with information about resources that have been tagged.
    :vartype tag: ~digital_ocean_api.models.Tag
    """

    _attribute_map = {
        'tag': {'key': 'tag', 'type': 'Tag'},
    }

    def __init__(
        self,
        *,
        tag: Optional["_models.Tag"] = None,
        **kwargs
    ):
        """
        :keyword tag: A tag is a label that can be applied to a resource (currently Droplets, Images,
         Volumes, Volume Snapshots, and Database clusters) in order to better organize or facilitate the
         lookups and actions on it.
         Tags have two attributes: a user defined ``name`` attribute and an embedded ``resources``
         attribute with information about resources that have been tagged.
        :paramtype tag: ~digital_ocean_api.models.Tag
        """
        super(ComponentsNbth3FResponsesExistingTagContentApplicationJsonSchema, self).__init__(**kwargs)
        self.tag = tag


class ComponentsNhzig9ResponsesGetImageActionsResponseContentApplicationJsonSchema(Pagination, Meta, Components1IjwlbpResponsesGetImageActionsResponseContentApplicationJsonSchemaAllof0):
    """ComponentsNhzig9ResponsesGetImageActionsResponseContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.Action]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[Action]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        actions: Optional[List["_models.Action"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.Action]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsNhzig9ResponsesGetImageActionsResponseContentApplicationJsonSchema, self).__init__(links=links, meta=meta, actions=actions, **kwargs)
        self.actions = actions
        self.meta = meta
        self.links = links


class ComponentsNrd4ZlResponsesUpdatedLoadBalancerContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsNrd4ZlResponsesUpdatedLoadBalancerContentApplicationJsonSchema.

    :ivar load_balancer:
    :vartype load_balancer: ~digital_ocean_api.models.LoadBalancer
    """

    _attribute_map = {
        'load_balancer': {'key': 'load_balancer', 'type': 'LoadBalancer'},
    }

    def __init__(
        self,
        *,
        load_balancer: Optional["_models.LoadBalancer"] = None,
        **kwargs
    ):
        """
        :keyword load_balancer:
        :paramtype load_balancer: ~digital_ocean_api.models.LoadBalancer
        """
        super(ComponentsNrd4ZlResponsesUpdatedLoadBalancerContentApplicationJsonSchema, self).__init__(**kwargs)
        self.load_balancer = load_balancer


class ComponentsO4VmziResponsesClusterlintRunContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsO4VmziResponsesClusterlintRunContentApplicationJsonSchema.

    :ivar run_id: ID of the clusterlint run that can be used later to fetch the diagnostics.
    :vartype run_id: str
    """

    _attribute_map = {
        'run_id': {'key': 'run_id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        run_id: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword run_id: ID of the clusterlint run that can be used later to fetch the diagnostics.
        :paramtype run_id: str
        """
        super(ComponentsO4VmziResponsesClusterlintRunContentApplicationJsonSchema, self).__init__(**kwargs)
        self.run_id = run_id


class ComponentsO60Td8ResponsesAllVolumesContentApplicationJsonSchema(Pagination, Meta, Components2S56XuResponsesAllVolumesContentApplicationJsonSchemaAllof0):
    """ComponentsO60Td8ResponsesAllVolumesContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar volumes: Required. Array of volumes.
    :vartype volumes: list[~digital_ocean_api.models.VolumeFull]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'volumes': {'required': True},
        'meta': {'required': True},
    }

    _attribute_map = {
        'volumes': {'key': 'volumes', 'type': '[VolumeFull]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        volumes: List["_models.VolumeFull"],
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword volumes: Required. Array of volumes.
        :paramtype volumes: list[~digital_ocean_api.models.VolumeFull]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsO60Td8ResponsesAllVolumesContentApplicationJsonSchema, self).__init__(links=links, meta=meta, volumes=volumes, **kwargs)
        self.volumes = volumes
        self.meta = meta
        self.links = links


class ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema.

    :ivar certificate:
    :vartype certificate: ~digital_ocean_api.models.Certificate
    """

    _attribute_map = {
        'certificate': {'key': 'certificate', 'type': 'Certificate'},
    }

    def __init__(
        self,
        *,
        certificate: Optional["_models.Certificate"] = None,
        **kwargs
    ):
        """
        :keyword certificate:
        :paramtype certificate: ~digital_ocean_api.models.Certificate
        """
        super(ComponentsOispf1ResponsesNewCertificateContentApplicationJsonSchema, self).__init__(**kwargs)
        self.certificate = certificate


class ComponentsQapjoxResponsesNodePoolCreateContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsQapjoxResponsesNodePoolCreateContentApplicationJsonSchema.

    :ivar node_pool:
    :vartype node_pool: ~digital_ocean_api.models.KubernetesNodePool
    """

    _attribute_map = {
        'node_pool': {'key': 'node_pool', 'type': 'KubernetesNodePool'},
    }

    def __init__(
        self,
        *,
        node_pool: Optional["_models.KubernetesNodePool"] = None,
        **kwargs
    ):
        """
        :keyword node_pool:
        :paramtype node_pool: ~digital_ocean_api.models.KubernetesNodePool
        """
        super(ComponentsQapjoxResponsesNodePoolCreateContentApplicationJsonSchema, self).__init__(**kwargs)
        self.node_pool = node_pool


class ComponentsQb55LsResponsesFirewallRulesContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsQb55LsResponsesFirewallRulesContentApplicationJsonSchema.

    :ivar rules:
    :vartype rules: list[~digital_ocean_api.models.FirewallRule]
    """

    _attribute_map = {
        'rules': {'key': 'rules', 'type': '[FirewallRule]'},
    }

    def __init__(
        self,
        *,
        rules: Optional[List["_models.FirewallRule"]] = None,
        **kwargs
    ):
        """
        :keyword rules:
        :paramtype rules: list[~digital_ocean_api.models.FirewallRule]
        """
        super(ComponentsQb55LsResponsesFirewallRulesContentApplicationJsonSchema, self).__init__(**kwargs)
        self.rules = rules


class ComponentsRt1AiuResponsesVolumeSnapshotsContentApplicationJsonSchemaAllof0(msrest.serialization.Model):
    """ComponentsRt1AiuResponsesVolumeSnapshotsContentApplicationJsonSchemaAllof0.

    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.Snapshot]
    """

    _attribute_map = {
        'snapshots': {'key': 'snapshots', 'type': '[Snapshot]'},
    }

    def __init__(
        self,
        *,
        snapshots: Optional[List["_models.Snapshot"]] = None,
        **kwargs
    ):
        """
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.Snapshot]
        """
        super(ComponentsRt1AiuResponsesVolumeSnapshotsContentApplicationJsonSchemaAllof0, self).__init__(**kwargs)
        self.snapshots = snapshots


class ComponentsSf8Ag1ResponsesRegistryOptionsResponseContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsSf8Ag1ResponsesRegistryOptionsResponseContentApplicationJsonSchema.

    :ivar options:
    :vartype options: ~digital_ocean_api.models.RegistryOptionsResponseApplicationJsonProperties
    """

    _attribute_map = {
        'options': {'key': 'options', 'type': 'RegistryOptionsResponseApplicationJsonProperties'},
    }

    def __init__(
        self,
        *,
        options: Optional["_models.RegistryOptionsResponseApplicationJsonProperties"] = None,
        **kwargs
    ):
        """
        :keyword options:
        :paramtype options: ~digital_ocean_api.models.RegistryOptionsResponseApplicationJsonProperties
        """
        super(ComponentsSf8Ag1ResponsesRegistryOptionsResponseContentApplicationJsonSchema, self).__init__(**kwargs)
        self.options = options


class ComponentsTjrufhResponsesVolumeSnapshotsContentApplicationJsonSchema(Pagination, Meta, ComponentsRt1AiuResponsesVolumeSnapshotsContentApplicationJsonSchemaAllof0):
    """ComponentsTjrufhResponsesVolumeSnapshotsContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.Snapshot]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'snapshots': {'key': 'snapshots', 'type': '[Snapshot]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        snapshots: Optional[List["_models.Snapshot"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.Snapshot]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsTjrufhResponsesVolumeSnapshotsContentApplicationJsonSchema, self).__init__(links=links, meta=meta, snapshots=snapshots, **kwargs)
        self.snapshots = snapshots
        self.meta = meta
        self.links = links


class ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema.

    :ivar kubernetes_cluster:
    :vartype kubernetes_cluster: ~digital_ocean_api.models.Cluster
    """

    _attribute_map = {
        'kubernetes_cluster': {'key': 'kubernetes_cluster', 'type': 'Cluster'},
    }

    def __init__(
        self,
        *,
        kubernetes_cluster: Optional["_models.Cluster"] = None,
        **kwargs
    ):
        """
        :keyword kubernetes_cluster:
        :paramtype kubernetes_cluster: ~digital_ocean_api.models.Cluster
        """
        super(ComponentsTzd5NlResponsesClusterCreateContentApplicationJsonSchema, self).__init__(**kwargs)
        self.kubernetes_cluster = kubernetes_cluster


class ComponentsUqzsw5ResponsesAllKeysContentApplicationJsonSchema(Components1Iix62EResponsesAllKeysContentApplicationJsonSchemaAllof0, Pagination, Meta):
    """ComponentsUqzsw5ResponsesAllKeysContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    :ivar ssh_keys:
    :vartype ssh_keys: list[~digital_ocean_api.models.SshKey]
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
        'ssh_keys': {'key': 'ssh_keys', 'type': '[SshKey]'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        ssh_keys: Optional[List["_models.SshKey"]] = None,
        **kwargs
    ):
        """
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        :keyword ssh_keys:
        :paramtype ssh_keys: list[~digital_ocean_api.models.SshKey]
        """
        super(ComponentsUqzsw5ResponsesAllKeysContentApplicationJsonSchema, self).__init__(ssh_keys=ssh_keys, links=links, meta=meta, **kwargs)
        self.meta = meta
        self.links = links
        self.ssh_keys = ssh_keys


class ComponentsUxeeyiResponsesGetFirewallResponseContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsUxeeyiResponsesGetFirewallResponseContentApplicationJsonSchema.

    :ivar firewall:
    :vartype firewall: ~digital_ocean_api.models.Firewall
    """

    _attribute_map = {
        'firewall': {'key': 'firewall', 'type': 'Firewall'},
    }

    def __init__(
        self,
        *,
        firewall: Optional["_models.Firewall"] = None,
        **kwargs
    ):
        """
        :keyword firewall:
        :paramtype firewall: ~digital_ocean_api.models.Firewall
        """
        super(ComponentsUxeeyiResponsesGetFirewallResponseContentApplicationJsonSchema, self).__init__(**kwargs)
        self.firewall = firewall


class ComponentsV728JgResponsesGarbageCollectionContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsV728JgResponsesGarbageCollectionContentApplicationJsonSchema.

    :ivar garbage_collection:
    :vartype garbage_collection: ~digital_ocean_api.models.GarbageCollection
    """

    _attribute_map = {
        'garbage_collection': {'key': 'garbage_collection', 'type': 'GarbageCollection'},
    }

    def __init__(
        self,
        *,
        garbage_collection: Optional["_models.GarbageCollection"] = None,
        **kwargs
    ):
        """
        :keyword garbage_collection:
        :paramtype garbage_collection: ~digital_ocean_api.models.GarbageCollection
        """
        super(ComponentsV728JgResponsesGarbageCollectionContentApplicationJsonSchema, self).__init__(**kwargs)
        self.garbage_collection = garbage_collection


class ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema.

    :ivar endpoint:
    :vartype endpoint: ~digital_ocean_api.models.CdnEndpoint
    """

    _attribute_map = {
        'endpoint': {'key': 'endpoint', 'type': 'CdnEndpoint'},
    }

    def __init__(
        self,
        *,
        endpoint: Optional["_models.CdnEndpoint"] = None,
        **kwargs
    ):
        """
        :keyword endpoint:
        :paramtype endpoint: ~digital_ocean_api.models.CdnEndpoint
        """
        super(ComponentsVd6C9CResponsesExistingEndpointContentApplicationJsonSchema, self).__init__(**kwargs)
        self.endpoint = endpoint


class ComponentsW0B5NrResponsesDatabaseReplicasContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsW0B5NrResponsesDatabaseReplicasContentApplicationJsonSchema.

    :ivar replicas:
    :vartype replicas: list[~digital_ocean_api.models.DatabaseReplica]
    """

    _attribute_map = {
        'replicas': {'key': 'replicas', 'type': '[DatabaseReplica]'},
    }

    def __init__(
        self,
        *,
        replicas: Optional[List["_models.DatabaseReplica"]] = None,
        **kwargs
    ):
        """
        :keyword replicas:
        :paramtype replicas: list[~digital_ocean_api.models.DatabaseReplica]
        """
        super(ComponentsW0B5NrResponsesDatabaseReplicasContentApplicationJsonSchema, self).__init__(**kwargs)
        self.replicas = replicas


class ComponentsW0Qp6KResponsesExistingLoadBalancerContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsW0Qp6KResponsesExistingLoadBalancerContentApplicationJsonSchema.

    :ivar load_balancer:
    :vartype load_balancer: ~digital_ocean_api.models.LoadBalancer
    """

    _attribute_map = {
        'load_balancer': {'key': 'load_balancer', 'type': 'LoadBalancer'},
    }

    def __init__(
        self,
        *,
        load_balancer: Optional["_models.LoadBalancer"] = None,
        **kwargs
    ):
        """
        :keyword load_balancer:
        :paramtype load_balancer: ~digital_ocean_api.models.LoadBalancer
        """
        super(ComponentsW0Qp6KResponsesExistingLoadBalancerContentApplicationJsonSchema, self).__init__(**kwargs)
        self.load_balancer = load_balancer


class ComponentsWmf624ResponsesGarbageCollectionsContentApplicationJsonSchema(msrest.serialization.Model):
    """ComponentsWmf624ResponsesGarbageCollectionsContentApplicationJsonSchema.

    :ivar garbage_collections:
    :vartype garbage_collections: list[~digital_ocean_api.models.GarbageCollection]
    """

    _attribute_map = {
        'garbage_collections': {'key': 'garbage_collections', 'type': '[GarbageCollection]'},
    }

    def __init__(
        self,
        *,
        garbage_collections: Optional[List["_models.GarbageCollection"]] = None,
        **kwargs
    ):
        """
        :keyword garbage_collections:
        :paramtype garbage_collections: list[~digital_ocean_api.models.GarbageCollection]
        """
        super(ComponentsWmf624ResponsesGarbageCollectionsContentApplicationJsonSchema, self).__init__(**kwargs)
        self.garbage_collections = garbage_collections


class ComponentsWqokeaResponsesAssociatedResourcesListContentApplicationJsonSchema(Components1Exa74MResponsesAssociatedResourcesListContentApplicationJsonSchemaAllof0):
    """ComponentsWqokeaResponsesAssociatedResourcesListContentApplicationJsonSchema.

    :ivar floating_ips:
    :vartype floating_ips: list[~digital_ocean_api.models.AssociatedResource]
    :ivar snapshots:
    :vartype snapshots: list[~digital_ocean_api.models.AssociatedResource]
    :ivar volumes:
    :vartype volumes: list[~digital_ocean_api.models.AssociatedResource]
    :ivar volume_snapshots:
    :vartype volume_snapshots: list[~digital_ocean_api.models.AssociatedResource]
    """

    _attribute_map = {
        'floating_ips': {'key': 'floating_ips', 'type': '[AssociatedResource]'},
        'snapshots': {'key': 'snapshots', 'type': '[AssociatedResource]'},
        'volumes': {'key': 'volumes', 'type': '[AssociatedResource]'},
        'volume_snapshots': {'key': 'volume_snapshots', 'type': '[AssociatedResource]'},
    }

    def __init__(
        self,
        *,
        floating_ips: Optional[List["_models.AssociatedResource"]] = None,
        snapshots: Optional[List["_models.AssociatedResource"]] = None,
        volumes: Optional[List["_models.AssociatedResource"]] = None,
        volume_snapshots: Optional[List["_models.AssociatedResource"]] = None,
        **kwargs
    ):
        """
        :keyword floating_ips:
        :paramtype floating_ips: list[~digital_ocean_api.models.AssociatedResource]
        :keyword snapshots:
        :paramtype snapshots: list[~digital_ocean_api.models.AssociatedResource]
        :keyword volumes:
        :paramtype volumes: list[~digital_ocean_api.models.AssociatedResource]
        :keyword volume_snapshots:
        :paramtype volume_snapshots: list[~digital_ocean_api.models.AssociatedResource]
        """
        super(ComponentsWqokeaResponsesAssociatedResourcesListContentApplicationJsonSchema, self).__init__(floating_ips=floating_ips, snapshots=snapshots, volumes=volumes, volume_snapshots=volume_snapshots, **kwargs)


class ComponentsY49W2GResponsesListFirewallsResponseContentApplicationJsonSchema(Pagination, Meta, ComponentsAb9K5AResponsesListFirewallsResponseContentApplicationJsonSchemaAllof0):
    """ComponentsY49W2GResponsesListFirewallsResponseContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar firewalls:
    :vartype firewalls: list[~digital_ocean_api.models.Firewall]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'firewalls': {'key': 'firewalls', 'type': '[Firewall]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        firewalls: Optional[List["_models.Firewall"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword firewalls:
        :paramtype firewalls: list[~digital_ocean_api.models.Firewall]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsY49W2GResponsesListFirewallsResponseContentApplicationJsonSchema, self).__init__(links=links, meta=meta, firewalls=firewalls, **kwargs)
        self.firewalls = firewalls
        self.meta = meta
        self.links = links


class ComponentsY6JpvjResponsesAllSizesContentApplicationJsonSchema(Pagination, Meta, Components1Dwt4B3ResponsesAllSizesContentApplicationJsonSchemaAllof0):
    """ComponentsY6JpvjResponsesAllSizesContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar sizes: Required.
    :vartype sizes: list[~digital_ocean_api.models.Size]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'sizes': {'required': True},
        'meta': {'required': True},
    }

    _attribute_map = {
        'sizes': {'key': 'sizes', 'type': '[Size]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        sizes: List["_models.Size"],
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword sizes: Required.
        :paramtype sizes: list[~digital_ocean_api.models.Size]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsY6JpvjResponsesAllSizesContentApplicationJsonSchema, self).__init__(links=links, meta=meta, sizes=sizes, **kwargs)
        self.sizes = sizes
        self.meta = meta
        self.links = links


class ListAlertPolicy(msrest.serialization.Model):
    """ListAlertPolicy.

    All required parameters must be populated in order to send to Azure.

    :ivar policies: Required.
    :vartype policies: list[~digital_ocean_api.models.AlertPolicy]
    """

    _validation = {
        'policies': {'required': True},
    }

    _attribute_map = {
        'policies': {'key': 'policies', 'type': '[AlertPolicy]'},
    }

    def __init__(
        self,
        *,
        policies: List["_models.AlertPolicy"],
        **kwargs
    ):
        """
        :keyword policies: Required.
        :paramtype policies: list[~digital_ocean_api.models.AlertPolicy]
        """
        super(ListAlertPolicy, self).__init__(**kwargs)
        self.policies = policies


class ComponentsZagm7OResponsesListAlertPolicyResponseContentApplicationJsonSchema(Pagination, Meta, ListAlertPolicy):
    """ComponentsZagm7OResponsesListAlertPolicyResponseContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar policies: Required.
    :vartype policies: list[~digital_ocean_api.models.AlertPolicy]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'policies': {'required': True},
        'meta': {'required': True},
    }

    _attribute_map = {
        'policies': {'key': 'policies', 'type': '[AlertPolicy]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        policies: List["_models.AlertPolicy"],
        meta: "_models.MetaMeta",
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword policies: Required.
        :paramtype policies: list[~digital_ocean_api.models.AlertPolicy]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsZagm7OResponsesListAlertPolicyResponseContentApplicationJsonSchema, self).__init__(links=links, meta=meta, policies=policies, **kwargs)
        self.policies = policies
        self.meta = meta
        self.links = links


class ComponentsZea7QwSchemasFirewallRulesPropertiesOutboundRulesItemsAllof1(msrest.serialization.Model):
    """ComponentsZea7QwSchemasFirewallRulesPropertiesOutboundRulesItemsAllof1.

    All required parameters must be populated in order to send to Azure.

    :ivar destinations: Required.
    :vartype destinations: ~digital_ocean_api.models.FirewallRulesOutboundRulesAllOfProperties
    """

    _validation = {
        'destinations': {'required': True},
    }

    _attribute_map = {
        'destinations': {'key': 'destinations', 'type': 'FirewallRulesOutboundRulesAllOfProperties'},
    }

    def __init__(
        self,
        *,
        destinations: "_models.FirewallRulesOutboundRulesAllOfProperties",
        **kwargs
    ):
        """
        :keyword destinations: Required.
        :paramtype destinations: ~digital_ocean_api.models.FirewallRulesOutboundRulesAllOfProperties
        """
        super(ComponentsZea7QwSchemasFirewallRulesPropertiesOutboundRulesItemsAllof1, self).__init__(**kwargs)
        self.destinations = destinations


class ComponentsZl28R5ResponsesAllLoadBalancersContentApplicationJsonSchema(Pagination, Meta, Components1MywxwzResponsesAllLoadBalancersContentApplicationJsonSchemaAllof0):
    """ComponentsZl28R5ResponsesAllLoadBalancersContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar load_balancers:
    :vartype load_balancers: list[~digital_ocean_api.models.LoadBalancer]
    :ivar meta: Required. Information about the response itself.
    :vartype meta: ~digital_ocean_api.models.MetaMeta
    :ivar links:
    :vartype links: ~digital_ocean_api.models.PageLinks
    """

    _validation = {
        'meta': {'required': True},
    }

    _attribute_map = {
        'load_balancers': {'key': 'load_balancers', 'type': '[LoadBalancer]'},
        'meta': {'key': 'meta', 'type': 'MetaMeta'},
        'links': {'key': 'links', 'type': 'PageLinks'},
    }

    def __init__(
        self,
        *,
        meta: "_models.MetaMeta",
        load_balancers: Optional[List["_models.LoadBalancer"]] = None,
        links: Optional["_models.PageLinks"] = None,
        **kwargs
    ):
        """
        :keyword load_balancers:
        :paramtype load_balancers: list[~digital_ocean_api.models.LoadBalancer]
        :keyword meta: Required. Information about the response itself.
        :paramtype meta: ~digital_ocean_api.models.MetaMeta
        :keyword links:
        :paramtype links: ~digital_ocean_api.models.PageLinks
        """
        super(ComponentsZl28R5ResponsesAllLoadBalancersContentApplicationJsonSchema, self).__init__(links=links, meta=meta, load_balancers=load_balancers, **kwargs)
        self.load_balancers = load_balancers
        self.meta = meta
        self.links = links


class ConnectionPool(msrest.serialization.Model):
    """ConnectionPool.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A unique name for the connection pool. Must be between 3 and 60
     characters.
    :vartype name: str
    :ivar mode: Required. The PGBouncer transaction mode for the connection pool. The allowed
     values are session, transaction, and statement.
    :vartype mode: str
    :ivar size: Required. The desired size of the PGBouncer connection pool. The maximum allowed
     size is determined by the size of the cluster's primary node. 25 backend server connections are
     allowed for every 1GB of RAM. Three are reserved for maintenance. For example, a primary node
     with 1 GB of RAM allows for a maximum of 22 backend server connections while one with 4 GB
     would allow for 97. Note that these are shared across all connection pools in a cluster.
    :vartype size: int
    :ivar db: Required. The database for use with the connection pool.
    :vartype db: str
    :ivar user: Required. The name of the user for use with the connection pool.
    :vartype user: str
    :ivar connection:
    :vartype connection: ~digital_ocean_api.models.ConnectionPoolConnection
    :ivar private_connection:
    :vartype private_connection: ~digital_ocean_api.models.ConnectionPoolPrivateConnection
    """

    _validation = {
        'name': {'required': True},
        'mode': {'required': True},
        'size': {'required': True},
        'db': {'required': True},
        'user': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'mode': {'key': 'mode', 'type': 'str'},
        'size': {'key': 'size', 'type': 'int'},
        'db': {'key': 'db', 'type': 'str'},
        'user': {'key': 'user', 'type': 'str'},
        'connection': {'key': 'connection', 'type': 'ConnectionPoolConnection'},
        'private_connection': {'key': 'private_connection', 'type': 'ConnectionPoolPrivateConnection'},
    }

    def __init__(
        self,
        *,
        name: str,
        mode: str,
        size: int,
        db: str,
        user: str,
        connection: Optional["_models.ConnectionPoolConnection"] = None,
        private_connection: Optional["_models.ConnectionPoolPrivateConnection"] = None,
        **kwargs
    ):
        """
        :keyword name: Required. A unique name for the connection pool. Must be between 3 and 60
         characters.
        :paramtype name: str
        :keyword mode: Required. The PGBouncer transaction mode for the connection pool. The allowed
         values are session, transaction, and statement.
        :paramtype mode: str
        :keyword size: Required. The desired size of the PGBouncer connection pool. The maximum allowed
         size is determined by the size of the cluster's primary node. 25 backend server connections are
         allowed for every 1GB of RAM. Three are reserved for maintenance. For example, a primary node
         with 1 GB of RAM allows for a maximum of 22 backend server connections while one with 4 GB
         would allow for 97. Note that these are shared across all connection pools in a cluster.
        :paramtype size: int
        :keyword db: Required. The database for use with the connection pool.
        :paramtype db: str
        :keyword user: Required. The name of the user for use with the connection pool.
        :paramtype user: str
        :keyword connection:
        :paramtype connection: ~digital_ocean_api.models.ConnectionPoolConnection
        :keyword private_connection:
        :paramtype private_connection: ~digital_ocean_api.models.ConnectionPoolPrivateConnection
        """
        super(ConnectionPool, self).__init__(**kwargs)
        self.name = name
        self.mode = mode
        self.size = size
        self.db = db
        self.user = user
        self.connection = connection
        self.private_connection = private_connection


class DatabaseConnection(msrest.serialization.Model):
    """DatabaseConnection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(DatabaseConnection, self).__init__(**kwargs)
        self.uri = None
        self.database = None
        self.host = None
        self.port = None
        self.user = None
        self.password = None
        self.ssl = None


class ConnectionPoolConnection(DatabaseConnection):
    """ConnectionPoolConnection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ConnectionPoolConnection, self).__init__(**kwargs)


class ConnectionPoolPrivateConnection(DatabaseConnection):
    """ConnectionPoolPrivateConnection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ConnectionPoolPrivateConnection, self).__init__(**kwargs)


class ConnectionPools(msrest.serialization.Model):
    """ConnectionPools.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar pools: An array of connection pool objects.
    :vartype pools: list[~digital_ocean_api.models.ConnectionPool]
    """

    _validation = {
        'pools': {'readonly': True},
    }

    _attribute_map = {
        'pools': {'key': 'pools', 'type': '[ConnectionPool]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ConnectionPools, self).__init__(**kwargs)
        self.pools = None


class Credentials(msrest.serialization.Model):
    """Credentials.

    :ivar server: The URL used to access the cluster API server.
    :vartype server: str
    :ivar certificate_authority_data: A base64 encoding of bytes representing the certificate
     authority data for accessing the cluster.
    :vartype certificate_authority_data: bytearray
    :ivar client_certificate_data: A base64 encoding of bytes representing the x509 client
     certificate data for access the cluster. This is only returned for clusters
     without support for token-based authentication.
    
     Newly created Kubernetes clusters do not return credentials using
     certificate-based authentication. For additional information,
     `see here
     <https://www.digitalocean.com/docs/kubernetes/how-to/connect-to-cluster/#authenticate>`_.
    :vartype client_certificate_data: bytearray
    :ivar client_key_data: A base64 encoding of bytes representing the x509 client key
     data for access the cluster. This is only returned for clusters without
     support for token-based authentication.
    
     Newly created Kubernetes clusters do not return credentials using
     certificate-based authentication. For additional information,
     `see here
     <https://www.digitalocean.com/docs/kubernetes/how-to/connect-to-cluster/#authenticate>`_.
    :vartype client_key_data: bytearray
    :ivar token: An access token used to authenticate with the cluster. This is only returned for
     clusters with support for token-based authentication.
    :vartype token: str
    :ivar expires_at: A time value given in ISO8601 combined date and time format that represents
     when the access token expires.
    :vartype expires_at: ~datetime.datetime
    """

    _attribute_map = {
        'server': {'key': 'server', 'type': 'str'},
        'certificate_authority_data': {'key': 'certificate_authority_data', 'type': 'bytearray'},
        'client_certificate_data': {'key': 'client_certificate_data', 'type': 'bytearray'},
        'client_key_data': {'key': 'client_key_data', 'type': 'bytearray'},
        'token': {'key': 'token', 'type': 'str'},
        'expires_at': {'key': 'expires_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        server: Optional[str] = None,
        certificate_authority_data: Optional[bytearray] = None,
        client_certificate_data: Optional[bytearray] = None,
        client_key_data: Optional[bytearray] = None,
        token: Optional[str] = None,
        expires_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword server: The URL used to access the cluster API server.
        :paramtype server: str
        :keyword certificate_authority_data: A base64 encoding of bytes representing the certificate
         authority data for accessing the cluster.
        :paramtype certificate_authority_data: bytearray
        :keyword client_certificate_data: A base64 encoding of bytes representing the x509 client
         certificate data for access the cluster. This is only returned for clusters
         without support for token-based authentication.
        
         Newly created Kubernetes clusters do not return credentials using
         certificate-based authentication. For additional information,
         `see here
         <https://www.digitalocean.com/docs/kubernetes/how-to/connect-to-cluster/#authenticate>`_.
        :paramtype client_certificate_data: bytearray
        :keyword client_key_data: A base64 encoding of bytes representing the x509 client key
         data for access the cluster. This is only returned for clusters without
         support for token-based authentication.
        
         Newly created Kubernetes clusters do not return credentials using
         certificate-based authentication. For additional information,
         `see here
         <https://www.digitalocean.com/docs/kubernetes/how-to/connect-to-cluster/#authenticate>`_.
        :paramtype client_key_data: bytearray
        :keyword token: An access token used to authenticate with the cluster. This is only returned
         for clusters with support for token-based authentication.
        :paramtype token: str
        :keyword expires_at: A time value given in ISO8601 combined date and time format that
         represents when the access token expires.
        :paramtype expires_at: ~datetime.datetime
        """
        super(Credentials, self).__init__(**kwargs)
        self.server = server
        self.certificate_authority_data = certificate_authority_data
        self.client_certificate_data = client_certificate_data
        self.client_key_data = client_key_data
        self.token = token
        self.expires_at = expires_at


class Database(msrest.serialization.Model):
    """Database.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the database.
    :vartype name: str
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the database.
        :paramtype name: str
        """
        super(Database, self).__init__(**kwargs)
        self.name = name


class DatabaseBackup(msrest.serialization.Model):
    """DatabaseBackup.

    All required parameters must be populated in order to send to Azure.

    :ivar database_name: Required. The name of an existing database cluster from which the backup
     will be restored.
    :vartype database_name: str
    :ivar backup_created_at: The timestamp of an existing database cluster backup in ISO8601
     combined date and time format. The most recent backup will be used if excluded.
    :vartype backup_created_at: ~datetime.datetime
    """

    _validation = {
        'database_name': {'required': True},
    }

    _attribute_map = {
        'database_name': {'key': 'database_name', 'type': 'str'},
        'backup_created_at': {'key': 'backup_created_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        database_name: str,
        backup_created_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword database_name: Required. The name of an existing database cluster from which the
         backup will be restored.
        :paramtype database_name: str
        :keyword backup_created_at: The timestamp of an existing database cluster backup in ISO8601
         combined date and time format. The most recent backup will be used if excluded.
        :paramtype backup_created_at: ~datetime.datetime
        """
        super(DatabaseBackup, self).__init__(**kwargs)
        self.database_name = database_name
        self.backup_created_at = backup_created_at


class DatabaseCluster(msrest.serialization.Model):
    """DatabaseCluster.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique ID that can be used to identify and reference a database cluster.
    :vartype id: str
    :ivar name: Required. A unique, human-readable name referring to a database cluster.
    :vartype name: str
    :ivar engine: Required. A slug representing the database engine used for the cluster. The
     possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb"
     for MongoDB. Known values are: "pg", "mysql", "redis", "mongodb".
    :vartype engine: str or ~digital_ocean_api.models.DatabaseClusterEngine
    :ivar version: A string representing the version of the database engine in use for the cluster.
    :vartype version: str
    :ivar num_nodes: Required. The number of nodes in the database cluster.
    :vartype num_nodes: int
    :ivar size: Required. The slug identifier representing the size of the nodes in the database
     cluster.
    :vartype size: str
    :ivar region: Required. The slug identifier for the region where the database cluster is
     located.
    :vartype region: str
    :ivar status: A string representing the current status of the database cluster. Known values
     are: "creating", "online", "resizing", "migrating", "forking".
    :vartype status: str or ~digital_ocean_api.models.DatabaseClusterStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the database cluster was created.
    :vartype created_at: ~datetime.datetime
    :ivar private_network_uuid: A string specifying the UUID of the VPC to which the database
     cluster will be assigned. If excluded, the cluster when creating a new database cluster, it
     will be assigned to your account's default VPC for the region.
    :vartype private_network_uuid: str
    :ivar tags: A set of tags. An array of tags that have been applied to the database cluster.
    :vartype tags: list[str]
    :ivar db_names: An array of strings containing the names of databases created in the database
     cluster.
    :vartype db_names: list[str]
    :ivar connection:
    :vartype connection: ~digital_ocean_api.models.DatabaseClusterConnection
    :ivar private_connection:
    :vartype private_connection: ~digital_ocean_api.models.DatabaseClusterPrivateConnection
    :ivar users:
    :vartype users: list[~digital_ocean_api.models.DatabaseUser]
    :ivar maintenance_window:
    :vartype maintenance_window: ~digital_ocean_api.models.DatabaseClusterMaintenanceWindow
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'required': True},
        'engine': {'required': True},
        'num_nodes': {'required': True},
        'size': {'required': True},
        'region': {'required': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'private_network_uuid': {'pattern': r'^$|[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}'},
        'db_names': {'readonly': True},
        'users': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'engine': {'key': 'engine', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'num_nodes': {'key': 'num_nodes', 'type': 'int'},
        'size': {'key': 'size', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'private_network_uuid': {'key': 'private_network_uuid', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'db_names': {'key': 'db_names', 'type': '[str]'},
        'connection': {'key': 'connection', 'type': 'DatabaseClusterConnection'},
        'private_connection': {'key': 'private_connection', 'type': 'DatabaseClusterPrivateConnection'},
        'users': {'key': 'users', 'type': '[DatabaseUser]'},
        'maintenance_window': {'key': 'maintenance_window', 'type': 'DatabaseClusterMaintenanceWindow'},
    }

    def __init__(
        self,
        *,
        name: str,
        engine: Union[str, "_models.DatabaseClusterEngine"],
        num_nodes: int,
        size: str,
        region: str,
        version: Optional[str] = None,
        private_network_uuid: Optional[str] = None,
        tags: Optional[List[str]] = None,
        connection: Optional["_models.DatabaseClusterConnection"] = None,
        private_connection: Optional["_models.DatabaseClusterPrivateConnection"] = None,
        maintenance_window: Optional["_models.DatabaseClusterMaintenanceWindow"] = None,
        **kwargs
    ):
        """
        :keyword name: Required. A unique, human-readable name referring to a database cluster.
        :paramtype name: str
        :keyword engine: Required. A slug representing the database engine used for the cluster. The
         possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb"
         for MongoDB. Known values are: "pg", "mysql", "redis", "mongodb".
        :paramtype engine: str or ~digital_ocean_api.models.DatabaseClusterEngine
        :keyword version: A string representing the version of the database engine in use for the
         cluster.
        :paramtype version: str
        :keyword num_nodes: Required. The number of nodes in the database cluster.
        :paramtype num_nodes: int
        :keyword size: Required. The slug identifier representing the size of the nodes in the database
         cluster.
        :paramtype size: str
        :keyword region: Required. The slug identifier for the region where the database cluster is
         located.
        :paramtype region: str
        :keyword private_network_uuid: A string specifying the UUID of the VPC to which the database
         cluster will be assigned. If excluded, the cluster when creating a new database cluster, it
         will be assigned to your account's default VPC for the region.
        :paramtype private_network_uuid: str
        :keyword tags: A set of tags. An array of tags that have been applied to the database cluster.
        :paramtype tags: list[str]
        :keyword connection:
        :paramtype connection: ~digital_ocean_api.models.DatabaseClusterConnection
        :keyword private_connection:
        :paramtype private_connection: ~digital_ocean_api.models.DatabaseClusterPrivateConnection
        :keyword maintenance_window:
        :paramtype maintenance_window: ~digital_ocean_api.models.DatabaseClusterMaintenanceWindow
        """
        super(DatabaseCluster, self).__init__(**kwargs)
        self.id = None
        self.name = name
        self.engine = engine
        self.version = version
        self.num_nodes = num_nodes
        self.size = size
        self.region = region
        self.status = None
        self.created_at = None
        self.private_network_uuid = private_network_uuid
        self.tags = tags
        self.db_names = None
        self.connection = connection
        self.private_connection = private_connection
        self.users = None
        self.maintenance_window = maintenance_window


class DatabaseClusterConnection(DatabaseConnection):
    """DatabaseClusterConnection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(DatabaseClusterConnection, self).__init__(**kwargs)


class DatabaseMaintenanceWindow(msrest.serialization.Model):
    """DatabaseMaintenanceWindow.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar day: Required. The day of the week on which to apply maintenance updates.
    :vartype day: str
    :ivar hour: Required. The hour in UTC at which maintenance updates will be applied in 24 hour
     format.
    :vartype hour: str
    :ivar pending: A boolean value indicating whether any maintenance is scheduled to be performed
     in the next window.
    :vartype pending: bool
    :ivar description: A list of strings, each containing information about a pending maintenance
     update.
    :vartype description: list[str]
    """

    _validation = {
        'day': {'required': True},
        'hour': {'required': True},
        'pending': {'readonly': True},
        'description': {'readonly': True},
    }

    _attribute_map = {
        'day': {'key': 'day', 'type': 'str'},
        'hour': {'key': 'hour', 'type': 'str'},
        'pending': {'key': 'pending', 'type': 'bool'},
        'description': {'key': 'description', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        day: str,
        hour: str,
        **kwargs
    ):
        """
        :keyword day: Required. The day of the week on which to apply maintenance updates.
        :paramtype day: str
        :keyword hour: Required. The hour in UTC at which maintenance updates will be applied in 24
         hour format.
        :paramtype hour: str
        """
        super(DatabaseMaintenanceWindow, self).__init__(**kwargs)
        self.day = day
        self.hour = hour
        self.pending = None
        self.description = None


class DatabaseClusterMaintenanceWindow(DatabaseMaintenanceWindow):
    """DatabaseClusterMaintenanceWindow.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar day: Required. The day of the week on which to apply maintenance updates.
    :vartype day: str
    :ivar hour: Required. The hour in UTC at which maintenance updates will be applied in 24 hour
     format.
    :vartype hour: str
    :ivar pending: A boolean value indicating whether any maintenance is scheduled to be performed
     in the next window.
    :vartype pending: bool
    :ivar description: A list of strings, each containing information about a pending maintenance
     update.
    :vartype description: list[str]
    """

    _validation = {
        'day': {'required': True},
        'hour': {'required': True},
        'pending': {'readonly': True},
        'description': {'readonly': True},
    }

    _attribute_map = {
        'day': {'key': 'day', 'type': 'str'},
        'hour': {'key': 'hour', 'type': 'str'},
        'pending': {'key': 'pending', 'type': 'bool'},
        'description': {'key': 'description', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        day: str,
        hour: str,
        **kwargs
    ):
        """
        :keyword day: Required. The day of the week on which to apply maintenance updates.
        :paramtype day: str
        :keyword hour: Required. The hour in UTC at which maintenance updates will be applied in 24
         hour format.
        :paramtype hour: str
        """
        super(DatabaseClusterMaintenanceWindow, self).__init__(day=day, hour=hour, **kwargs)


class DatabaseClusterPrivateConnection(DatabaseConnection):
    """DatabaseClusterPrivateConnection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(DatabaseClusterPrivateConnection, self).__init__(**kwargs)


class DatabaseClusterResize(msrest.serialization.Model):
    """DatabaseClusterResize.

    All required parameters must be populated in order to send to Azure.

    :ivar size: Required. A slug identifier representing desired the size of the nodes in the
     database cluster.
    :vartype size: str
    :ivar num_nodes: Required. The number of nodes in the database cluster. Valid values are are
     1-3. In addition to the primary node, up to two standby nodes may be added for highly available
     configurations.
    :vartype num_nodes: int
    """

    _validation = {
        'size': {'required': True},
        'num_nodes': {'required': True},
    }

    _attribute_map = {
        'size': {'key': 'size', 'type': 'str'},
        'num_nodes': {'key': 'num_nodes', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        size: str,
        num_nodes: int,
        **kwargs
    ):
        """
        :keyword size: Required. A slug identifier representing desired the size of the nodes in the
         database cluster.
        :paramtype size: str
        :keyword num_nodes: Required. The number of nodes in the database cluster. Valid values are are
         1-3. In addition to the primary node, up to two standby nodes may be added for highly available
         configurations.
        :paramtype num_nodes: int
        """
        super(DatabaseClusterResize, self).__init__(**kwargs)
        self.size = size
        self.num_nodes = num_nodes


class DatabaseConfig(msrest.serialization.Model):
    """DatabaseConfig.

    :ivar config:
    :vartype config: any
    """

    _attribute_map = {
        'config': {'key': 'config', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        config: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword config:
        :paramtype config: any
        """
        super(DatabaseConfig, self).__init__(**kwargs)
        self.config = config


class DatabaseReplica(msrest.serialization.Model):
    """DatabaseReplica.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name to give the read-only replicating.
    :vartype name: str
    :ivar region: A slug identifier for the region where the read-only replica will be located. If
     excluded, the replica will be placed in the same region as the cluster.
    :vartype region: str
    :ivar size: A slug identifier representing the size of the node for the read-only replica. The
     size of the replica must be at least as large as the node size for the database cluster from
     which it is replicating.
    :vartype size: str
    :ivar status: A string representing the current status of the database cluster. Known values
     are: "creating", "online", "resizing", "migrating", "forking".
    :vartype status: str or ~digital_ocean_api.models.DatabaseReplicaStatus
    :ivar tags: A set of tags. A flat array of tag names as strings to apply to the read-only
     replica after it is created. Tag names can either be existing or new tags.
    :vartype tags: list[str]
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the database cluster was created.
    :vartype created_at: ~datetime.datetime
    :ivar private_network_uuid: A string specifying the UUID of the VPC to which the read-only
     replica will be assigned. If excluded, the replica will be assigned to your account's default
     VPC for the region.
    :vartype private_network_uuid: str
    :ivar connection:
    :vartype connection: ~digital_ocean_api.models.DatabaseReplicaConnection
    :ivar private_connection:
    :vartype private_connection: ~digital_ocean_api.models.DatabaseReplicaPrivateConnection
    """

    _validation = {
        'name': {'required': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'size': {'key': 'size', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'private_network_uuid': {'key': 'private_network_uuid', 'type': 'str'},
        'connection': {'key': 'connection', 'type': 'DatabaseReplicaConnection'},
        'private_connection': {'key': 'private_connection', 'type': 'DatabaseReplicaPrivateConnection'},
    }

    def __init__(
        self,
        *,
        name: str,
        region: Optional[str] = None,
        size: Optional[str] = None,
        tags: Optional[List[str]] = None,
        private_network_uuid: Optional[str] = None,
        connection: Optional["_models.DatabaseReplicaConnection"] = None,
        private_connection: Optional["_models.DatabaseReplicaPrivateConnection"] = None,
        **kwargs
    ):
        """
        :keyword name: Required. The name to give the read-only replicating.
        :paramtype name: str
        :keyword region: A slug identifier for the region where the read-only replica will be located.
         If excluded, the replica will be placed in the same region as the cluster.
        :paramtype region: str
        :keyword size: A slug identifier representing the size of the node for the read-only replica.
         The size of the replica must be at least as large as the node size for the database cluster
         from which it is replicating.
        :paramtype size: str
        :keyword tags: A set of tags. A flat array of tag names as strings to apply to the read-only
         replica after it is created. Tag names can either be existing or new tags.
        :paramtype tags: list[str]
        :keyword private_network_uuid: A string specifying the UUID of the VPC to which the read-only
         replica will be assigned. If excluded, the replica will be assigned to your account's default
         VPC for the region.
        :paramtype private_network_uuid: str
        :keyword connection:
        :paramtype connection: ~digital_ocean_api.models.DatabaseReplicaConnection
        :keyword private_connection:
        :paramtype private_connection: ~digital_ocean_api.models.DatabaseReplicaPrivateConnection
        """
        super(DatabaseReplica, self).__init__(**kwargs)
        self.name = name
        self.region = region
        self.size = size
        self.status = None
        self.tags = tags
        self.created_at = None
        self.private_network_uuid = private_network_uuid
        self.connection = connection
        self.private_connection = private_connection


class DatabaseReplicaConnection(DatabaseConnection):
    """DatabaseReplicaConnection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(DatabaseReplicaConnection, self).__init__(**kwargs)


class DatabaseReplicaPrivateConnection(DatabaseConnection):
    """DatabaseReplicaPrivateConnection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(DatabaseReplicaPrivateConnection, self).__init__(**kwargs)


class DatabaseUser(msrest.serialization.Model):
    """DatabaseUser.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of a database user.
    :vartype name: str
    :ivar role: A string representing the database user's role. The value will be either
     "primary" or "normal". Known values are: "primary", "normal".
    :vartype role: str or ~digital_ocean_api.models.DatabaseUserRole
    :ivar password: A randomly generated password for the database user.
    :vartype password: str
    :ivar mysql_settings:
    :vartype mysql_settings: ~digital_ocean_api.models.MysqlSettings
    """

    _validation = {
        'name': {'required': True},
        'role': {'readonly': True},
        'password': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'role': {'key': 'role', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'mysql_settings': {'key': 'mysql_settings', 'type': 'MysqlSettings'},
    }

    def __init__(
        self,
        *,
        name: str,
        mysql_settings: Optional["_models.MysqlSettings"] = None,
        **kwargs
    ):
        """
        :keyword name: Required. The name of a database user.
        :paramtype name: str
        :keyword mysql_settings:
        :paramtype mysql_settings: ~digital_ocean_api.models.MysqlSettings
        """
        super(DatabaseUser, self).__init__(**kwargs)
        self.name = name
        self.role = None
        self.password = None
        self.mysql_settings = mysql_settings


class DestroyAssociatedKubernetesResources(msrest.serialization.Model):
    """An object containing the IDs of resources to be destroyed along with their associated with a Kubernetes cluster.

    :ivar load_balancers: A list of IDs for associated load balancers to destroy along with the
     cluster.
    :vartype load_balancers: list[str]
    :ivar volumes: A list of IDs for associated volumes to destroy along with the cluster.
    :vartype volumes: list[str]
    :ivar volume_snapshots: A list of IDs for associated volume snapshots to destroy along with the
     cluster.
    :vartype volume_snapshots: list[str]
    """

    _attribute_map = {
        'load_balancers': {'key': 'load_balancers', 'type': '[str]'},
        'volumes': {'key': 'volumes', 'type': '[str]'},
        'volume_snapshots': {'key': 'volume_snapshots', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        load_balancers: Optional[List[str]] = None,
        volumes: Optional[List[str]] = None,
        volume_snapshots: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword load_balancers: A list of IDs for associated load balancers to destroy along with the
         cluster.
        :paramtype load_balancers: list[str]
        :keyword volumes: A list of IDs for associated volumes to destroy along with the cluster.
        :paramtype volumes: list[str]
        :keyword volume_snapshots: A list of IDs for associated volume snapshots to destroy along with
         the cluster.
        :paramtype volume_snapshots: list[str]
        """
        super(DestroyAssociatedKubernetesResources, self).__init__(**kwargs)
        self.load_balancers = load_balancers
        self.volumes = volumes
        self.volume_snapshots = volume_snapshots


class DestroyedAssociatedResource(msrest.serialization.Model):
    """An object containing information about a resource scheduled for deletion.

    :ivar id: The unique identifier for the resource scheduled for deletion.
    :vartype id: str
    :ivar name: The name of the resource scheduled for deletion.
    :vartype name: str
    :ivar destroyed_at: A time value given in ISO8601 combined date and time format indicating when
     the resource was destroyed if the request was successful.
    :vartype destroyed_at: ~datetime.datetime
    :ivar error_message: A string indicating that the resource was not successfully destroyed and
     providing additional information.
    :vartype error_message: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'destroyed_at': {'key': 'destroyed_at', 'type': 'iso-8601'},
        'error_message': {'key': 'error_message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        destroyed_at: Optional[datetime.datetime] = None,
        error_message: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: The unique identifier for the resource scheduled for deletion.
        :paramtype id: str
        :keyword name: The name of the resource scheduled for deletion.
        :paramtype name: str
        :keyword destroyed_at: A time value given in ISO8601 combined date and time format indicating
         when the resource was destroyed if the request was successful.
        :paramtype destroyed_at: ~datetime.datetime
        :keyword error_message: A string indicating that the resource was not successfully destroyed
         and providing additional information.
        :paramtype error_message: str
        """
        super(DestroyedAssociatedResource, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.destroyed_at = destroyed_at
        self.error_message = error_message


class DockerCredentials(msrest.serialization.Model):
    """DockerCredentials.

    :ivar auths:
    :vartype auths: ~digital_ocean_api.models.DockerCredentialsAuths
    """

    _attribute_map = {
        'auths': {'key': 'auths', 'type': 'DockerCredentialsAuths'},
    }

    def __init__(
        self,
        *,
        auths: Optional["_models.DockerCredentialsAuths"] = None,
        **kwargs
    ):
        """
        :keyword auths:
        :paramtype auths: ~digital_ocean_api.models.DockerCredentialsAuths
        """
        super(DockerCredentials, self).__init__(**kwargs)
        self.auths = auths


class DockerCredentialsAuths(msrest.serialization.Model):
    """DockerCredentialsAuths.

    :ivar registry_digitalocean_com:
    :vartype registry_digitalocean_com:
     ~digital_ocean_api.models.DockerCredentialsAuthsRegistryDigitaloceanCom
    """

    _attribute_map = {
        'registry_digitalocean_com': {'key': 'registry\\.digitalocean\\.com', 'type': 'DockerCredentialsAuthsRegistryDigitaloceanCom'},
    }

    def __init__(
        self,
        *,
        registry_digitalocean_com: Optional["_models.DockerCredentialsAuthsRegistryDigitaloceanCom"] = None,
        **kwargs
    ):
        """
        :keyword registry_digitalocean_com:
        :paramtype registry_digitalocean_com:
         ~digital_ocean_api.models.DockerCredentialsAuthsRegistryDigitaloceanCom
        """
        super(DockerCredentialsAuths, self).__init__(**kwargs)
        self.registry_digitalocean_com = registry_digitalocean_com


class DockerCredentialsAuthsRegistryDigitaloceanCom(msrest.serialization.Model):
    """DockerCredentialsAuthsRegistryDigitaloceanCom.

    :ivar auth: A base64 encoded string containing credentials for the container registry.
    :vartype auth: str
    """

    _attribute_map = {
        'auth': {'key': 'auth', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        auth: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword auth: A base64 encoded string containing credentials for the container registry.
        :paramtype auth: str
        """
        super(DockerCredentialsAuthsRegistryDigitaloceanCom, self).__init__(**kwargs)
        self.auth = auth


class Domain(msrest.serialization.Model):
    """Domain.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The name of the domain itself. This should follow the standard domain format of
     domain.TLD. For instance, ``example.com`` is a valid domain name.
    :vartype name: str
    :ivar ip_address: This optional attribute may contain an IP address. When provided, an A record
     will be automatically created pointing to the apex domain.
    :vartype ip_address: str
    :ivar ttl: This value is the time to live for the records on this domain, in seconds. This
     defines the time frame that clients can cache queried information before a refresh should be
     requested.
    :vartype ttl: int
    :ivar zone_file: This attribute contains the complete contents of the zone file for the
     selected domain. Individual domain record resources should be used to get more granular control
     over records. However, this attribute can also be used to get information about the SOA record,
     which is created automatically and is not accessible as an individual record resource.
    :vartype zone_file: str
    """

    _validation = {
        'ttl': {'readonly': True},
        'zone_file': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'ip_address': {'key': 'ip_address', 'type': 'str'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'zone_file': {'key': 'zone_file', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        ip_address: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of the domain itself. This should follow the standard domain format of
         domain.TLD. For instance, ``example.com`` is a valid domain name.
        :paramtype name: str
        :keyword ip_address: This optional attribute may contain an IP address. When provided, an A
         record will be automatically created pointing to the apex domain.
        :paramtype ip_address: str
        """
        super(Domain, self).__init__(**kwargs)
        self.name = name
        self.ip_address = ip_address
        self.ttl = None
        self.zone_file = None


class DomainRecord(msrest.serialization.Model):
    """DomainRecord.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecord, self).__init__(**kwargs)
        self.id = None
        self.type = type
        self.name = name
        self.data = data
        self.priority = priority
        self.port = port
        self.ttl = ttl
        self.weight = weight
        self.flags = flags
        self.tag = tag


class DomainRecordA(DomainRecord):
    """DomainRecordA.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordA, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordAaaa(DomainRecord):
    """DomainRecordAaaa.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordAaaa, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordCaa(DomainRecord):
    """DomainRecordCaa.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordCaa, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordCname(DomainRecord):
    """DomainRecordCname.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordCname, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordMx(DomainRecord):
    """DomainRecordMx.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordMx, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordNs(DomainRecord):
    """DomainRecordNs.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordNs, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordSoa(DomainRecord):
    """DomainRecordSoa.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordSoa, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordSrv(DomainRecord):
    """DomainRecordSrv.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordSrv, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class DomainRecordTxt(DomainRecord):
    """DomainRecordTxt.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identifier for each domain record.
    :vartype id: int
    :ivar type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
    :vartype type: str
    :ivar name: The host name, alias, or service being defined by the record.
    :vartype name: str
    :ivar data: Variable data depending on record type. For example, the "data" value for an A
     record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
     contain the domain name of the CA being granted permission to issue certificates.
    :vartype data: str
    :ivar priority: The priority for SRV and MX records.
    :vartype priority: int
    :ivar port: The port for SRV records.
    :vartype port: int
    :ivar ttl: This value is the time to live for the record, in seconds. This defines the time
     frame that clients can cache queried information before a refresh should be requested.
    :vartype ttl: int
    :ivar weight: The weight for SRV records.
    :vartype weight: int
    :ivar flags: An unsigned integer between 0-255 used for CAA records.
    :vartype flags: int
    :ivar tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
     "iodef".
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'data': {'key': 'data', 'type': 'str'},
        'priority': {'key': 'priority', 'type': 'int'},
        'port': {'key': 'port', 'type': 'int'},
        'ttl': {'key': 'ttl', 'type': 'int'},
        'weight': {'key': 'weight', 'type': 'int'},
        'flags': {'key': 'flags', 'type': 'int'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: str,
        name: Optional[str] = None,
        data: Optional[str] = None,
        priority: Optional[int] = None,
        port: Optional[int] = None,
        ttl: Optional[int] = None,
        weight: Optional[int] = None,
        flags: Optional[int] = None,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The type of the DNS record. For example: A, CNAME, TXT, ...
        :paramtype type: str
        :keyword name: The host name, alias, or service being defined by the record.
        :paramtype name: str
        :keyword data: Variable data depending on record type. For example, the "data" value for an A
         record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would
         contain the domain name of the CA being granted permission to issue certificates.
        :paramtype data: str
        :keyword priority: The priority for SRV and MX records.
        :paramtype priority: int
        :keyword port: The port for SRV records.
        :paramtype port: int
        :keyword ttl: This value is the time to live for the record, in seconds. This defines the time
         frame that clients can cache queried information before a refresh should be requested.
        :paramtype ttl: int
        :keyword weight: The weight for SRV records.
        :paramtype weight: int
        :keyword flags: An unsigned integer between 0-255 used for CAA records.
        :paramtype flags: int
        :keyword tag: The parameter tag for CAA records. Valid values are "issue", "issuewild", or
         "iodef".
        :paramtype tag: str
        """
        super(DomainRecordTxt, self).__init__(type=type, name=name, data=data, priority=priority, port=port, ttl=ttl, weight=weight, flags=flags, tag=tag, **kwargs)


class Droplet(msrest.serialization.Model):
    """Droplet.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. A unique identifier for each Droplet instance. This is automatically
     generated upon Droplet creation.
    :vartype id: int
    :ivar name: Required. The human-readable name set for the Droplet instance.
    :vartype name: str
    :ivar memory: Required. Memory of the Droplet in megabytes.
    :vartype memory: int
    :ivar vcpus: Required. The number of virtual CPUs.
    :vartype vcpus: int
    :ivar disk: Required. The size of the Droplet's disk in gigabytes.
    :vartype disk: int
    :ivar locked: Required. A boolean value indicating whether the Droplet has been locked,
     preventing actions by users.
    :vartype locked: bool
    :ivar status: Required. A status string indicating the state of the Droplet instance. This may
     be "new", "active", "off", or "archive". Known values are: "new", "active", "off", "archive".
    :vartype status: str or ~digital_ocean_api.models.DropletStatus
    :ivar kernel: Required. **Note**\ : All Droplets created after March 2017 use internal kernels
     by default.
     These Droplets will have this attribute set to ``null``.
    
     The current `kernel <https://www.digitalocean.com/docs/droplets/how-to/kernel/>`_
     for Droplets with externally managed kernels. This will initially be set to
     the kernel of the base image when the Droplet is created.
    :vartype kernel: ~digital_ocean_api.models.Kernel
    :ivar created_at: Required. A time value given in ISO8601 combined date and time format that
     represents when the Droplet was created.
    :vartype created_at: ~datetime.datetime
    :ivar features: Required. An array of features enabled on this Droplet.
    :vartype features: list[str]
    :ivar backup_ids: Required. An array of backup IDs of any backups that have been taken of the
     Droplet instance.  Droplet backups are enabled at the time of the instance creation.
    :vartype backup_ids: list[int]
    :ivar next_backup_window: Required. The details of the Droplet's backups feature, if backups
     are configured for the Droplet. This object contains keys for the start and end times of the
     window during which the backup will start.
    :vartype next_backup_window: ~digital_ocean_api.models.DropletNextBackupWindow
    :ivar snapshot_ids: Required. An array of snapshot IDs of any snapshots created from the
     Droplet instance.
    :vartype snapshot_ids: list[int]
    :ivar image: Required.
    :vartype image: ~digital_ocean_api.models.Image
    :ivar volume_ids: Required. A flat array including the unique identifier for each Block Storage
     volume attached to the Droplet.
    :vartype volume_ids: list[str]
    :ivar size: Required.
    :vartype size: ~digital_ocean_api.models.Size
    :ivar size_slug: Required. The unique slug identifier for the size of this Droplet.
    :vartype size_slug: str
    :ivar networks: Required. The details of the network that are configured for the Droplet
     instance.  This is an object that contains keys for IPv4 and IPv6.  The value of each of these
     is an array that contains objects describing an individual IP resource allocated to the
     Droplet.  These will define attributes like the IP address, netmask, and gateway of the
     specific network depending on the type of network it is.
    :vartype networks: ~digital_ocean_api.models.DropletNetworks
    :ivar region: Required.
    :vartype region: ~digital_ocean_api.models.Region
    :ivar tags: Required. A set of tags. An array of Tags the Droplet has been tagged with.
    :vartype tags: list[str]
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the Droplet is assigned.
    :vartype vpc_uuid: str
    """

    _validation = {
        'id': {'required': True},
        'name': {'required': True},
        'memory': {'required': True, 'multiple': 8},
        'vcpus': {'required': True},
        'disk': {'required': True},
        'locked': {'required': True},
        'status': {'required': True},
        'kernel': {'required': True},
        'created_at': {'required': True},
        'features': {'required': True},
        'backup_ids': {'required': True},
        'next_backup_window': {'required': True},
        'snapshot_ids': {'required': True},
        'image': {'required': True},
        'volume_ids': {'required': True},
        'size': {'required': True},
        'size_slug': {'required': True},
        'networks': {'required': True},
        'region': {'required': True},
        'tags': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'memory': {'key': 'memory', 'type': 'int'},
        'vcpus': {'key': 'vcpus', 'type': 'int'},
        'disk': {'key': 'disk', 'type': 'int'},
        'locked': {'key': 'locked', 'type': 'bool'},
        'status': {'key': 'status', 'type': 'str'},
        'kernel': {'key': 'kernel', 'type': 'Kernel'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'features': {'key': 'features', 'type': '[str]'},
        'backup_ids': {'key': 'backup_ids', 'type': '[int]'},
        'next_backup_window': {'key': 'next_backup_window', 'type': 'DropletNextBackupWindow'},
        'snapshot_ids': {'key': 'snapshot_ids', 'type': '[int]'},
        'image': {'key': 'image', 'type': 'Image'},
        'volume_ids': {'key': 'volume_ids', 'type': '[str]'},
        'size': {'key': 'size', 'type': 'Size'},
        'size_slug': {'key': 'size_slug', 'type': 'str'},
        'networks': {'key': 'networks', 'type': 'DropletNetworks'},
        'region': {'key': 'region', 'type': 'Region'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: int,
        name: str,
        memory: int,
        vcpus: int,
        disk: int,
        locked: bool,
        status: Union[str, "_models.DropletStatus"],
        kernel: "_models.Kernel",
        created_at: datetime.datetime,
        features: List[str],
        backup_ids: List[int],
        next_backup_window: "_models.DropletNextBackupWindow",
        snapshot_ids: List[int],
        image: "_models.Image",
        volume_ids: List[str],
        size: "_models.Size",
        size_slug: str,
        networks: "_models.DropletNetworks",
        region: "_models.Region",
        tags: List[str],
        vpc_uuid: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: Required. A unique identifier for each Droplet instance. This is automatically
         generated upon Droplet creation.
        :paramtype id: int
        :keyword name: Required. The human-readable name set for the Droplet instance.
        :paramtype name: str
        :keyword memory: Required. Memory of the Droplet in megabytes.
        :paramtype memory: int
        :keyword vcpus: Required. The number of virtual CPUs.
        :paramtype vcpus: int
        :keyword disk: Required. The size of the Droplet's disk in gigabytes.
        :paramtype disk: int
        :keyword locked: Required. A boolean value indicating whether the Droplet has been locked,
         preventing actions by users.
        :paramtype locked: bool
        :keyword status: Required. A status string indicating the state of the Droplet instance. This
         may be "new", "active", "off", or "archive". Known values are: "new", "active", "off",
         "archive".
        :paramtype status: str or ~digital_ocean_api.models.DropletStatus
        :keyword kernel: Required. **Note**\ : All Droplets created after March 2017 use internal
         kernels by default.
         These Droplets will have this attribute set to ``null``.
        
         The current `kernel <https://www.digitalocean.com/docs/droplets/how-to/kernel/>`_
         for Droplets with externally managed kernels. This will initially be set to
         the kernel of the base image when the Droplet is created.
        :paramtype kernel: ~digital_ocean_api.models.Kernel
        :keyword created_at: Required. A time value given in ISO8601 combined date and time format that
         represents when the Droplet was created.
        :paramtype created_at: ~datetime.datetime
        :keyword features: Required. An array of features enabled on this Droplet.
        :paramtype features: list[str]
        :keyword backup_ids: Required. An array of backup IDs of any backups that have been taken of
         the Droplet instance.  Droplet backups are enabled at the time of the instance creation.
        :paramtype backup_ids: list[int]
        :keyword next_backup_window: Required. The details of the Droplet's backups feature, if backups
         are configured for the Droplet. This object contains keys for the start and end times of the
         window during which the backup will start.
        :paramtype next_backup_window: ~digital_ocean_api.models.DropletNextBackupWindow
        :keyword snapshot_ids: Required. An array of snapshot IDs of any snapshots created from the
         Droplet instance.
        :paramtype snapshot_ids: list[int]
        :keyword image: Required.
        :paramtype image: ~digital_ocean_api.models.Image
        :keyword volume_ids: Required. A flat array including the unique identifier for each Block
         Storage volume attached to the Droplet.
        :paramtype volume_ids: list[str]
        :keyword size: Required.
        :paramtype size: ~digital_ocean_api.models.Size
        :keyword size_slug: Required. The unique slug identifier for the size of this Droplet.
        :paramtype size_slug: str
        :keyword networks: Required. The details of the network that are configured for the Droplet
         instance.  This is an object that contains keys for IPv4 and IPv6.  The value of each of these
         is an array that contains objects describing an individual IP resource allocated to the
         Droplet.  These will define attributes like the IP address, netmask, and gateway of the
         specific network depending on the type of network it is.
        :paramtype networks: ~digital_ocean_api.models.DropletNetworks
        :keyword region: Required.
        :paramtype region: ~digital_ocean_api.models.Region
        :keyword tags: Required. A set of tags. An array of Tags the Droplet has been tagged with.
        :paramtype tags: list[str]
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the Droplet is assigned.
        :paramtype vpc_uuid: str
        """
        super(Droplet, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.memory = memory
        self.vcpus = vcpus
        self.disk = disk
        self.locked = locked
        self.status = status
        self.kernel = kernel
        self.created_at = created_at
        self.features = features
        self.backup_ids = backup_ids
        self.next_backup_window = next_backup_window
        self.snapshot_ids = snapshot_ids
        self.image = image
        self.volume_ids = volume_ids
        self.size = size
        self.size_slug = size_slug
        self.networks = networks
        self.region = region
        self.tags = tags
        self.vpc_uuid = vpc_uuid


class DropletCreate(msrest.serialization.Model):
    """DropletCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar region: Required. The slug identifier for the region that you wish to deploy the Droplet
     in.
    :vartype region: str
    :ivar size: Required. The slug identifier for the size that you wish to select for this
     Droplet.
    :vartype size: str
    :ivar image: Required. The image ID of a public or private image or the slug identifier for a
     public image. This image will be the base image for your Droplet.
    :vartype image: any
    :ivar ssh_keys: An array containing the IDs or fingerprints of the SSH keys that you wish to
     embed in the Droplet's root account upon creation.
    :vartype ssh_keys: list[any]
    :ivar backups: A boolean indicating whether automated backups should be enabled for the
     Droplet.
    :vartype backups: bool
    :ivar ipv6: A boolean indicating whether to enable IPv6 on the Droplet.
    :vartype ipv6: bool
    :ivar monitoring: A boolean indicating whether to install the DigitalOcean agent for
     monitoring.
    :vartype monitoring: bool
    :ivar tags: A set of tags. A flat array of tag names as strings to apply to the Droplet after
     it is created. Tag names can either be existing or new tags.
    :vartype tags: list[str]
    :ivar user_data: A string containing 'user data' which may be used to configure the Droplet on
     first boot, often a 'cloud-config' file or Bash script. It must be plain text and may not
     exceed 64 KiB in size.
    :vartype user_data: str
    :ivar private_networking: This parameter has been deprecated. Use ``vpc_uuid`` instead to
     specify a VPC network for the Droplet. If no ``vpc_uuid`` is provided, the Droplet will be
     placed in your account's default VPC for the region.
    :vartype private_networking: bool
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the Droplet will be assigned.
     If excluded, the Droplet will be assigned to your account's default VPC for the region.
    :vartype vpc_uuid: str
    :ivar with_droplet_agent: A boolean indicating whether to install the DigitalOcean agent used
     for providing access to the Droplet web console in the control panel. By default, the agent is
     installed on new Droplets but installation errors (i.e. OS not supported) are ignored. To
     prevent it from being installed, set to ``false``. To make installation errors fatal,
     explicitly set it to ``true``.
    :vartype with_droplet_agent: bool
    """

    _validation = {
        'region': {'required': True},
        'size': {'required': True},
        'image': {'required': True},
    }

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
        'size': {'key': 'size', 'type': 'str'},
        'image': {'key': 'image', 'type': 'object'},
        'ssh_keys': {'key': 'ssh_keys', 'type': '[object]'},
        'backups': {'key': 'backups', 'type': 'bool'},
        'ipv6': {'key': 'ipv6', 'type': 'bool'},
        'monitoring': {'key': 'monitoring', 'type': 'bool'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'user_data': {'key': 'user_data', 'type': 'str'},
        'private_networking': {'key': 'private_networking', 'type': 'bool'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'with_droplet_agent': {'key': 'with_droplet_agent', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        region: str,
        size: str,
        image: Any,
        ssh_keys: Optional[List[Any]] = [],
        backups: Optional[bool] = False,
        ipv6: Optional[bool] = False,
        monitoring: Optional[bool] = False,
        tags: Optional[List[str]] = [],
        user_data: Optional[str] = None,
        private_networking: Optional[bool] = False,
        vpc_uuid: Optional[str] = None,
        with_droplet_agent: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword region: Required. The slug identifier for the region that you wish to deploy the
         Droplet in.
        :paramtype region: str
        :keyword size: Required. The slug identifier for the size that you wish to select for this
         Droplet.
        :paramtype size: str
        :keyword image: Required. The image ID of a public or private image or the slug identifier for
         a public image. This image will be the base image for your Droplet.
        :paramtype image: any
        :keyword ssh_keys: An array containing the IDs or fingerprints of the SSH keys that you wish to
         embed in the Droplet's root account upon creation.
        :paramtype ssh_keys: list[any]
        :keyword backups: A boolean indicating whether automated backups should be enabled for the
         Droplet.
        :paramtype backups: bool
        :keyword ipv6: A boolean indicating whether to enable IPv6 on the Droplet.
        :paramtype ipv6: bool
        :keyword monitoring: A boolean indicating whether to install the DigitalOcean agent for
         monitoring.
        :paramtype monitoring: bool
        :keyword tags: A set of tags. A flat array of tag names as strings to apply to the Droplet
         after it is created. Tag names can either be existing or new tags.
        :paramtype tags: list[str]
        :keyword user_data: A string containing 'user data' which may be used to configure the Droplet
         on first boot, often a 'cloud-config' file or Bash script. It must be plain text and may not
         exceed 64 KiB in size.
        :paramtype user_data: str
        :keyword private_networking: This parameter has been deprecated. Use ``vpc_uuid`` instead to
         specify a VPC network for the Droplet. If no ``vpc_uuid`` is provided, the Droplet will be
         placed in your account's default VPC for the region.
        :paramtype private_networking: bool
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the Droplet will be
         assigned. If excluded, the Droplet will be assigned to your account's default VPC for the
         region.
        :paramtype vpc_uuid: str
        :keyword with_droplet_agent: A boolean indicating whether to install the DigitalOcean agent
         used for providing access to the Droplet web console in the control panel. By default, the
         agent is installed on new Droplets but installation errors (i.e. OS not supported) are ignored.
         To prevent it from being installed, set to ``false``. To make installation errors fatal,
         explicitly set it to ``true``.
        :paramtype with_droplet_agent: bool
        """
        super(DropletCreate, self).__init__(**kwargs)
        self.region = region
        self.size = size
        self.image = image
        self.ssh_keys = ssh_keys
        self.backups = backups
        self.ipv6 = ipv6
        self.monitoring = monitoring
        self.tags = tags
        self.user_data = user_data
        self.private_networking = private_networking
        self.vpc_uuid = vpc_uuid
        self.with_droplet_agent = with_droplet_agent


class DropletCreateApplicationJsonOneOfProperties(msrest.serialization.Model):
    """DropletCreateApplicationJsonOneOfProperties.

    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.ActionLink]
    """

    _attribute_map = {
        'actions': {'key': 'actions', 'type': '[ActionLink]'},
    }

    def __init__(
        self,
        *,
        actions: Optional[List["_models.ActionLink"]] = None,
        **kwargs
    ):
        """
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.ActionLink]
        """
        super(DropletCreateApplicationJsonOneOfProperties, self).__init__(**kwargs)
        self.actions = actions


class DropletMultiCreate(DropletCreate):
    """Multiple Droplet Request.

    All required parameters must be populated in order to send to Azure.

    :ivar region: Required. The slug identifier for the region that you wish to deploy the Droplet
     in.
    :vartype region: str
    :ivar size: Required. The slug identifier for the size that you wish to select for this
     Droplet.
    :vartype size: str
    :ivar image: Required. The image ID of a public or private image or the slug identifier for a
     public image. This image will be the base image for your Droplet.
    :vartype image: any
    :ivar ssh_keys: An array containing the IDs or fingerprints of the SSH keys that you wish to
     embed in the Droplet's root account upon creation.
    :vartype ssh_keys: list[any]
    :ivar backups: A boolean indicating whether automated backups should be enabled for the
     Droplet.
    :vartype backups: bool
    :ivar ipv6: A boolean indicating whether to enable IPv6 on the Droplet.
    :vartype ipv6: bool
    :ivar monitoring: A boolean indicating whether to install the DigitalOcean agent for
     monitoring.
    :vartype monitoring: bool
    :ivar tags: A set of tags. A flat array of tag names as strings to apply to the Droplet after
     it is created. Tag names can either be existing or new tags.
    :vartype tags: list[str]
    :ivar user_data: A string containing 'user data' which may be used to configure the Droplet on
     first boot, often a 'cloud-config' file or Bash script. It must be plain text and may not
     exceed 64 KiB in size.
    :vartype user_data: str
    :ivar private_networking: This parameter has been deprecated. Use ``vpc_uuid`` instead to
     specify a VPC network for the Droplet. If no ``vpc_uuid`` is provided, the Droplet will be
     placed in your account's default VPC for the region.
    :vartype private_networking: bool
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the Droplet will be assigned.
     If excluded, the Droplet will be assigned to your account's default VPC for the region.
    :vartype vpc_uuid: str
    :ivar with_droplet_agent: A boolean indicating whether to install the DigitalOcean agent used
     for providing access to the Droplet web console in the control panel. By default, the agent is
     installed on new Droplets but installation errors (i.e. OS not supported) are ignored. To
     prevent it from being installed, set to ``false``. To make installation errors fatal,
     explicitly set it to ``true``.
    :vartype with_droplet_agent: bool
    :ivar names: Required. An array of human human-readable strings you wish to use when displaying
     the Droplet name. Each name, if set to a domain name managed in the DigitalOcean DNS management
     system, will configure a PTR record for the Droplet. Each name set during creation will also
     determine the hostname for the Droplet in its internal configuration.
    :vartype names: list[str]
    """

    _validation = {
        'region': {'required': True},
        'size': {'required': True},
        'image': {'required': True},
        'names': {'required': True},
    }

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
        'size': {'key': 'size', 'type': 'str'},
        'image': {'key': 'image', 'type': 'object'},
        'ssh_keys': {'key': 'ssh_keys', 'type': '[object]'},
        'backups': {'key': 'backups', 'type': 'bool'},
        'ipv6': {'key': 'ipv6', 'type': 'bool'},
        'monitoring': {'key': 'monitoring', 'type': 'bool'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'user_data': {'key': 'user_data', 'type': 'str'},
        'private_networking': {'key': 'private_networking', 'type': 'bool'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'with_droplet_agent': {'key': 'with_droplet_agent', 'type': 'bool'},
        'names': {'key': 'names', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        region: str,
        size: str,
        image: Any,
        names: List[str],
        ssh_keys: Optional[List[Any]] = [],
        backups: Optional[bool] = False,
        ipv6: Optional[bool] = False,
        monitoring: Optional[bool] = False,
        tags: Optional[List[str]] = [],
        user_data: Optional[str] = None,
        private_networking: Optional[bool] = False,
        vpc_uuid: Optional[str] = None,
        with_droplet_agent: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword region: Required. The slug identifier for the region that you wish to deploy the
         Droplet in.
        :paramtype region: str
        :keyword size: Required. The slug identifier for the size that you wish to select for this
         Droplet.
        :paramtype size: str
        :keyword image: Required. The image ID of a public or private image or the slug identifier for
         a public image. This image will be the base image for your Droplet.
        :paramtype image: any
        :keyword ssh_keys: An array containing the IDs or fingerprints of the SSH keys that you wish to
         embed in the Droplet's root account upon creation.
        :paramtype ssh_keys: list[any]
        :keyword backups: A boolean indicating whether automated backups should be enabled for the
         Droplet.
        :paramtype backups: bool
        :keyword ipv6: A boolean indicating whether to enable IPv6 on the Droplet.
        :paramtype ipv6: bool
        :keyword monitoring: A boolean indicating whether to install the DigitalOcean agent for
         monitoring.
        :paramtype monitoring: bool
        :keyword tags: A set of tags. A flat array of tag names as strings to apply to the Droplet
         after it is created. Tag names can either be existing or new tags.
        :paramtype tags: list[str]
        :keyword user_data: A string containing 'user data' which may be used to configure the Droplet
         on first boot, often a 'cloud-config' file or Bash script. It must be plain text and may not
         exceed 64 KiB in size.
        :paramtype user_data: str
        :keyword private_networking: This parameter has been deprecated. Use ``vpc_uuid`` instead to
         specify a VPC network for the Droplet. If no ``vpc_uuid`` is provided, the Droplet will be
         placed in your account's default VPC for the region.
        :paramtype private_networking: bool
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the Droplet will be
         assigned. If excluded, the Droplet will be assigned to your account's default VPC for the
         region.
        :paramtype vpc_uuid: str
        :keyword with_droplet_agent: A boolean indicating whether to install the DigitalOcean agent
         used for providing access to the Droplet web console in the control panel. By default, the
         agent is installed on new Droplets but installation errors (i.e. OS not supported) are ignored.
         To prevent it from being installed, set to ``false``. To make installation errors fatal,
         explicitly set it to ``true``.
        :paramtype with_droplet_agent: bool
        :keyword names: Required. An array of human human-readable strings you wish to use when
         displaying the Droplet name. Each name, if set to a domain name managed in the DigitalOcean DNS
         management system, will configure a PTR record for the Droplet. Each name set during creation
         will also determine the hostname for the Droplet in its internal configuration.
        :paramtype names: list[str]
        """
        super(DropletMultiCreate, self).__init__(region=region, size=size, image=image, ssh_keys=ssh_keys, backups=backups, ipv6=ipv6, monitoring=monitoring, tags=tags, user_data=user_data, private_networking=private_networking, vpc_uuid=vpc_uuid, with_droplet_agent=with_droplet_agent, **kwargs)
        self.names = names


class DropletNetworks(msrest.serialization.Model):
    """The details of the network that are configured for the Droplet instance.  This is an object that contains keys for IPv4 and IPv6.  The value of each of these is an array that contains objects describing an individual IP resource allocated to the Droplet.  These will define attributes like the IP address, netmask, and gateway of the specific network depending on the type of network it is.

    :ivar v4:
    :vartype v4: list[~digital_ocean_api.models.NetworkV4]
    :ivar v6:
    :vartype v6: list[~digital_ocean_api.models.NetworkV6]
    """

    _attribute_map = {
        'v4': {'key': 'v4', 'type': '[NetworkV4]'},
        'v6': {'key': 'v6', 'type': '[NetworkV6]'},
    }

    def __init__(
        self,
        *,
        v4: Optional[List["_models.NetworkV4"]] = None,
        v6: Optional[List["_models.NetworkV6"]] = None,
        **kwargs
    ):
        """
        :keyword v4:
        :paramtype v4: list[~digital_ocean_api.models.NetworkV4]
        :keyword v6:
        :paramtype v6: list[~digital_ocean_api.models.NetworkV6]
        """
        super(DropletNetworks, self).__init__(**kwargs)
        self.v4 = v4
        self.v6 = v6


class DropletNextBackupWindow(msrest.serialization.Model):
    """The details of the Droplet's backups feature, if backups are configured for the Droplet. This object contains keys for the start and end times of the window during which the backup will start.

    :ivar start: A time value given in ISO8601 combined date and time format specifying the start
     of the Droplet's backup window.
    :vartype start: ~datetime.datetime
    :ivar end: A time value given in ISO8601 combined date and time format specifying the end of
     the Droplet's backup window.
    :vartype end: ~datetime.datetime
    """

    _attribute_map = {
        'start': {'key': 'start', 'type': 'iso-8601'},
        'end': {'key': 'end', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        start: Optional[datetime.datetime] = None,
        end: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword start: A time value given in ISO8601 combined date and time format specifying the
         start of the Droplet's backup window.
        :paramtype start: ~datetime.datetime
        :keyword end: A time value given in ISO8601 combined date and time format specifying the end of
         the Droplet's backup window.
        :paramtype end: ~datetime.datetime
        """
        super(DropletNextBackupWindow, self).__init__(**kwargs)
        self.start = start
        self.end = end


class DropletSingleCreate(DropletCreate):
    """Single Droplet Request.

    All required parameters must be populated in order to send to Azure.

    :ivar region: Required. The slug identifier for the region that you wish to deploy the Droplet
     in.
    :vartype region: str
    :ivar size: Required. The slug identifier for the size that you wish to select for this
     Droplet.
    :vartype size: str
    :ivar image: Required. The image ID of a public or private image or the slug identifier for a
     public image. This image will be the base image for your Droplet.
    :vartype image: any
    :ivar ssh_keys: An array containing the IDs or fingerprints of the SSH keys that you wish to
     embed in the Droplet's root account upon creation.
    :vartype ssh_keys: list[any]
    :ivar backups: A boolean indicating whether automated backups should be enabled for the
     Droplet.
    :vartype backups: bool
    :ivar ipv6: A boolean indicating whether to enable IPv6 on the Droplet.
    :vartype ipv6: bool
    :ivar monitoring: A boolean indicating whether to install the DigitalOcean agent for
     monitoring.
    :vartype monitoring: bool
    :ivar tags: A set of tags. A flat array of tag names as strings to apply to the Droplet after
     it is created. Tag names can either be existing or new tags.
    :vartype tags: list[str]
    :ivar user_data: A string containing 'user data' which may be used to configure the Droplet on
     first boot, often a 'cloud-config' file or Bash script. It must be plain text and may not
     exceed 64 KiB in size.
    :vartype user_data: str
    :ivar private_networking: This parameter has been deprecated. Use ``vpc_uuid`` instead to
     specify a VPC network for the Droplet. If no ``vpc_uuid`` is provided, the Droplet will be
     placed in your account's default VPC for the region.
    :vartype private_networking: bool
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the Droplet will be assigned.
     If excluded, the Droplet will be assigned to your account's default VPC for the region.
    :vartype vpc_uuid: str
    :ivar with_droplet_agent: A boolean indicating whether to install the DigitalOcean agent used
     for providing access to the Droplet web console in the control panel. By default, the agent is
     installed on new Droplets but installation errors (i.e. OS not supported) are ignored. To
     prevent it from being installed, set to ``false``. To make installation errors fatal,
     explicitly set it to ``true``.
    :vartype with_droplet_agent: bool
    :ivar name: Required. The human-readable string you wish to use when displaying the Droplet
     name. The name, if set to a domain name managed in the DigitalOcean DNS management system, will
     configure a PTR record for the Droplet. The name set during creation will also determine the
     hostname for the Droplet in its internal configuration.
    :vartype name: str
    """

    _validation = {
        'region': {'required': True},
        'size': {'required': True},
        'image': {'required': True},
        'name': {'required': True},
    }

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
        'size': {'key': 'size', 'type': 'str'},
        'image': {'key': 'image', 'type': 'object'},
        'ssh_keys': {'key': 'ssh_keys', 'type': '[object]'},
        'backups': {'key': 'backups', 'type': 'bool'},
        'ipv6': {'key': 'ipv6', 'type': 'bool'},
        'monitoring': {'key': 'monitoring', 'type': 'bool'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'user_data': {'key': 'user_data', 'type': 'str'},
        'private_networking': {'key': 'private_networking', 'type': 'bool'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'with_droplet_agent': {'key': 'with_droplet_agent', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        region: str,
        size: str,
        image: Any,
        name: str,
        ssh_keys: Optional[List[Any]] = [],
        backups: Optional[bool] = False,
        ipv6: Optional[bool] = False,
        monitoring: Optional[bool] = False,
        tags: Optional[List[str]] = [],
        user_data: Optional[str] = None,
        private_networking: Optional[bool] = False,
        vpc_uuid: Optional[str] = None,
        with_droplet_agent: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword region: Required. The slug identifier for the region that you wish to deploy the
         Droplet in.
        :paramtype region: str
        :keyword size: Required. The slug identifier for the size that you wish to select for this
         Droplet.
        :paramtype size: str
        :keyword image: Required. The image ID of a public or private image or the slug identifier for
         a public image. This image will be the base image for your Droplet.
        :paramtype image: any
        :keyword ssh_keys: An array containing the IDs or fingerprints of the SSH keys that you wish to
         embed in the Droplet's root account upon creation.
        :paramtype ssh_keys: list[any]
        :keyword backups: A boolean indicating whether automated backups should be enabled for the
         Droplet.
        :paramtype backups: bool
        :keyword ipv6: A boolean indicating whether to enable IPv6 on the Droplet.
        :paramtype ipv6: bool
        :keyword monitoring: A boolean indicating whether to install the DigitalOcean agent for
         monitoring.
        :paramtype monitoring: bool
        :keyword tags: A set of tags. A flat array of tag names as strings to apply to the Droplet
         after it is created. Tag names can either be existing or new tags.
        :paramtype tags: list[str]
        :keyword user_data: A string containing 'user data' which may be used to configure the Droplet
         on first boot, often a 'cloud-config' file or Bash script. It must be plain text and may not
         exceed 64 KiB in size.
        :paramtype user_data: str
        :keyword private_networking: This parameter has been deprecated. Use ``vpc_uuid`` instead to
         specify a VPC network for the Droplet. If no ``vpc_uuid`` is provided, the Droplet will be
         placed in your account's default VPC for the region.
        :paramtype private_networking: bool
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the Droplet will be
         assigned. If excluded, the Droplet will be assigned to your account's default VPC for the
         region.
        :paramtype vpc_uuid: str
        :keyword with_droplet_agent: A boolean indicating whether to install the DigitalOcean agent
         used for providing access to the Droplet web console in the control panel. By default, the
         agent is installed on new Droplets but installation errors (i.e. OS not supported) are ignored.
         To prevent it from being installed, set to ``false``. To make installation errors fatal,
         explicitly set it to ``true``.
        :paramtype with_droplet_agent: bool
        :keyword name: Required. The human-readable string you wish to use when displaying the Droplet
         name. The name, if set to a domain name managed in the DigitalOcean DNS management system, will
         configure a PTR record for the Droplet. The name set during creation will also determine the
         hostname for the Droplet in its internal configuration.
        :paramtype name: str
        """
        super(DropletSingleCreate, self).__init__(region=region, size=size, image=image, ssh_keys=ssh_keys, backups=backups, ipv6=ipv6, monitoring=monitoring, tags=tags, user_data=user_data, private_networking=private_networking, vpc_uuid=vpc_uuid, with_droplet_agent=with_droplet_agent, **kwargs)
        self.name = name


class SnapshotBase(msrest.serialization.Model):
    """SnapshotBase.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A human-readable name for the snapshot.
    :vartype name: str
    :ivar created_at: Required. A time value given in ISO8601 combined date and time format that
     represents when the snapshot was created.
    :vartype created_at: ~datetime.datetime
    :ivar regions: Required. An array of the regions that the snapshot is available in. The regions
     are represented by their identifying slug values.
    :vartype regions: list[str]
    :ivar min_disk_size: Required. The minimum size in GB required for a volume or Droplet to use
     this snapshot.
    :vartype min_disk_size: int
    :ivar size_gigabytes: Required. The billable size of the snapshot in gigabytes.
    :vartype size_gigabytes: float
    """

    _validation = {
        'name': {'required': True},
        'created_at': {'required': True},
        'regions': {'required': True},
        'min_disk_size': {'required': True},
        'size_gigabytes': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'regions': {'key': 'regions', 'type': '[str]'},
        'min_disk_size': {'key': 'min_disk_size', 'type': 'int'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        name: str,
        created_at: datetime.datetime,
        regions: List[str],
        min_disk_size: int,
        size_gigabytes: float,
        **kwargs
    ):
        """
        :keyword name: Required. A human-readable name for the snapshot.
        :paramtype name: str
        :keyword created_at: Required. A time value given in ISO8601 combined date and time format that
         represents when the snapshot was created.
        :paramtype created_at: ~datetime.datetime
        :keyword regions: Required. An array of the regions that the snapshot is available in. The
         regions are represented by their identifying slug values.
        :paramtype regions: list[str]
        :keyword min_disk_size: Required. The minimum size in GB required for a volume or Droplet to
         use this snapshot.
        :paramtype min_disk_size: int
        :keyword size_gigabytes: Required. The billable size of the snapshot in gigabytes.
        :paramtype size_gigabytes: float
        """
        super(SnapshotBase, self).__init__(**kwargs)
        self.name = name
        self.created_at = created_at
        self.regions = regions
        self.min_disk_size = min_disk_size
        self.size_gigabytes = size_gigabytes


class DropletSnapshot(SnapshotBase):
    """DropletSnapshot.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A human-readable name for the snapshot.
    :vartype name: str
    :ivar created_at: Required. A time value given in ISO8601 combined date and time format that
     represents when the snapshot was created.
    :vartype created_at: ~datetime.datetime
    :ivar regions: Required. An array of the regions that the snapshot is available in. The regions
     are represented by their identifying slug values.
    :vartype regions: list[str]
    :ivar min_disk_size: Required. The minimum size in GB required for a volume or Droplet to use
     this snapshot.
    :vartype min_disk_size: int
    :ivar size_gigabytes: Required. The billable size of the snapshot in gigabytes.
    :vartype size_gigabytes: float
    :ivar type: Required. Describes the kind of image. It may be one of ``snapshot`` or ``backup``.
     This specifies whether an image is a user-generated Droplet snapshot or automatically created
     Droplet backup. Known values are: "snapshot", "backup".
    :vartype type: str or ~digital_ocean_api.models.DropletSnapshotType
    """

    _validation = {
        'name': {'required': True},
        'created_at': {'required': True},
        'regions': {'required': True},
        'min_disk_size': {'required': True},
        'size_gigabytes': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'regions': {'key': 'regions', 'type': '[str]'},
        'min_disk_size': {'key': 'min_disk_size', 'type': 'int'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'float'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        created_at: datetime.datetime,
        regions: List[str],
        min_disk_size: int,
        size_gigabytes: float,
        type: Union[str, "_models.DropletSnapshotType"],
        **kwargs
    ):
        """
        :keyword name: Required. A human-readable name for the snapshot.
        :paramtype name: str
        :keyword created_at: Required. A time value given in ISO8601 combined date and time format that
         represents when the snapshot was created.
        :paramtype created_at: ~datetime.datetime
        :keyword regions: Required. An array of the regions that the snapshot is available in. The
         regions are represented by their identifying slug values.
        :paramtype regions: list[str]
        :keyword min_disk_size: Required. The minimum size in GB required for a volume or Droplet to
         use this snapshot.
        :paramtype min_disk_size: int
        :keyword size_gigabytes: Required. The billable size of the snapshot in gigabytes.
        :paramtype size_gigabytes: float
        :keyword type: Required. Describes the kind of image. It may be one of ``snapshot`` or
         ``backup``. This specifies whether an image is a user-generated Droplet snapshot or
         automatically created Droplet backup. Known values are: "snapshot", "backup".
        :paramtype type: str or ~digital_ocean_api.models.DropletSnapshotType
        """
        super(DropletSnapshot, self).__init__(name=name, created_at=created_at, regions=regions, min_disk_size=min_disk_size, size_gigabytes=size_gigabytes, **kwargs)
        self.type = type


class Error(msrest.serialization.Model):
    """Error.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. A short identifier corresponding to the HTTP status code returned. For
     example, the ID for a response returning a 404 status code would be "not_found.".
    :vartype id: str
    :ivar message: Required. A message providing additional information about the error, including
     details to help resolve it when possible.
    :vartype message: str
    :ivar request_id: Optionally, some endpoints may include a request ID that should be  provided
     when reporting bugs or opening support tickets to help  identify the issue.
    :vartype request_id: str
    """

    _validation = {
        'id': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'request_id': {'key': 'request_id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: str,
        message: str,
        request_id: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: Required. A short identifier corresponding to the HTTP status code returned. For
         example, the ID for a response returning a 404 status code would be "not_found.".
        :paramtype id: str
        :keyword message: Required. A message providing additional information about the error,
         including  details to help resolve it when possible.
        :paramtype message: str
        :keyword request_id: Optionally, some endpoints may include a request ID that should be
         provided when reporting bugs or opening support tickets to help  identify the issue.
        :paramtype request_id: str
        """
        super(Error, self).__init__(**kwargs)
        self.id = id
        self.message = message
        self.request_id = request_id


class ErrorWithRootCauses(msrest.serialization.Model):
    """ErrorWithRootCauses.

    All required parameters must be populated in order to send to Azure.

    :ivar error: Required. A message providing information about the error.
    :vartype error: str
    :ivar messages: A list of legacy error messages.
    :vartype messages: list[str]
    :ivar root_causes: Required. A list of underlying causes for the error, including details to
     help  resolve it when possible.
    :vartype root_causes: list[str]
    """

    _validation = {
        'error': {'required': True},
        'root_causes': {'required': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'str'},
        'messages': {'key': 'messages', 'type': '[str]'},
        'root_causes': {'key': 'root_causes', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        error: str,
        root_causes: List[str],
        messages: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword error: Required. A message providing information about the error.
        :paramtype error: str
        :keyword messages: A list of legacy error messages.
        :paramtype messages: list[str]
        :keyword root_causes: Required. A list of underlying causes for the error, including details to
         help  resolve it when possible.
        :paramtype root_causes: list[str]
        """
        super(ErrorWithRootCauses, self).__init__(**kwargs)
        self.error = error
        self.messages = messages
        self.root_causes = root_causes


class FirewallRules(msrest.serialization.Model):
    """FirewallRules.

    :ivar inbound_rules:
    :vartype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
    :ivar outbound_rules:
    :vartype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
    """

    _attribute_map = {
        'inbound_rules': {'key': 'inbound_rules', 'type': '[FirewallRulesInboundRulesItem]'},
        'outbound_rules': {'key': 'outbound_rules', 'type': '[FirewallRulesOutboundRulesItem]'},
    }

    def __init__(
        self,
        *,
        inbound_rules: Optional[List["_models.FirewallRulesInboundRulesItem"]] = None,
        outbound_rules: Optional[List["_models.FirewallRulesOutboundRulesItem"]] = None,
        **kwargs
    ):
        """
        :keyword inbound_rules:
        :paramtype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
        :keyword outbound_rules:
        :paramtype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
        """
        super(FirewallRules, self).__init__(**kwargs)
        self.inbound_rules = inbound_rules
        self.outbound_rules = outbound_rules


class Firewall(FirewallRules):
    """Firewall.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar inbound_rules:
    :vartype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
    :ivar outbound_rules:
    :vartype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
    :ivar id: A unique ID that can be used to identify and reference a firewall.
    :vartype id: str
    :ivar status: A status string indicating the current state of the firewall. This can be
     "waiting", "succeeded", or "failed". Known values are: "waiting", "succeeded", "failed".
    :vartype status: str or ~digital_ocean_api.models.FirewallStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the firewall was created.
    :vartype created_at: ~datetime.datetime
    :ivar pending_changes: An array of objects each containing the fields "droplet_id", "removing",
     and "status". It is provided to detail exactly which Droplets are having their security
     policies updated. When empty, all changes have been successfully applied.
    :vartype pending_changes: list[~digital_ocean_api.models.FirewallPendingChangesItem]
    :ivar name: A human-readable name for a firewall. The name must begin with an alphanumeric
     character. Subsequent characters must either be alphanumeric characters, a period (.), or a
     dash (-).
    :vartype name: str
    :ivar droplet_ids: An array containing the IDs of the Droplets assigned to the firewall.
    :vartype droplet_ids: list[int]
    :ivar tags: A set of tags. Any object.
    :vartype tags: any
    """

    _validation = {
        'id': {'readonly': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'pending_changes': {'readonly': True},
        'name': {'pattern': r'^[a-zA-Z0-9][a-zA-Z0-9\.-]+$'},
    }

    _attribute_map = {
        'inbound_rules': {'key': 'inbound_rules', 'type': '[FirewallRulesInboundRulesItem]'},
        'outbound_rules': {'key': 'outbound_rules', 'type': '[FirewallRulesOutboundRulesItem]'},
        'id': {'key': 'id', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'pending_changes': {'key': 'pending_changes', 'type': '[FirewallPendingChangesItem]'},
        'name': {'key': 'name', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        inbound_rules: Optional[List["_models.FirewallRulesInboundRulesItem"]] = None,
        outbound_rules: Optional[List["_models.FirewallRulesOutboundRulesItem"]] = None,
        name: Optional[str] = None,
        droplet_ids: Optional[List[int]] = None,
        tags: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword inbound_rules:
        :paramtype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
        :keyword outbound_rules:
        :paramtype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
        :keyword name: A human-readable name for a firewall. The name must begin with an alphanumeric
         character. Subsequent characters must either be alphanumeric characters, a period (.), or a
         dash (-).
        :paramtype name: str
        :keyword droplet_ids: An array containing the IDs of the Droplets assigned to the firewall.
        :paramtype droplet_ids: list[int]
        :keyword tags: A set of tags. Any object.
        :paramtype tags: any
        """
        super(Firewall, self).__init__(inbound_rules=inbound_rules, outbound_rules=outbound_rules, **kwargs)
        self.id = None
        self.status = None
        self.created_at = None
        self.pending_changes = None
        self.name = name
        self.droplet_ids = droplet_ids
        self.tags = tags


class FirewallPendingChangesItem(msrest.serialization.Model):
    """FirewallPendingChangesItem.

    :ivar droplet_id:
    :vartype droplet_id: int
    :ivar removing:
    :vartype removing: bool
    :ivar status:
    :vartype status: str
    """

    _attribute_map = {
        'droplet_id': {'key': 'droplet_id', 'type': 'int'},
        'removing': {'key': 'removing', 'type': 'bool'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        droplet_id: Optional[int] = None,
        removing: Optional[bool] = None,
        status: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword droplet_id:
        :paramtype droplet_id: int
        :keyword removing:
        :paramtype removing: bool
        :keyword status:
        :paramtype status: str
        """
        super(FirewallPendingChangesItem, self).__init__(**kwargs)
        self.droplet_id = droplet_id
        self.removing = removing
        self.status = status


class FirewallRule(msrest.serialization.Model):
    """FirewallRule.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar uuid: A unique ID for the firewall rule itself.
    :vartype uuid: str
    :ivar cluster_uuid: A unique ID for the database cluster to which the rule is applied.
    :vartype cluster_uuid: str
    :ivar type: Required. The type of resource that the firewall rule allows to access the database
     cluster. Known values are: "droplet", "k8s", "ip_addr", "tag", "app".
    :vartype type: str or ~digital_ocean_api.models.FirewallRuleType
    :ivar value: Required. The ID of the specific resource, the name of a tag applied to a group of
     resources, or the IP address that the firewall rule allows to access the database cluster.
    :vartype value: str
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the firewall rule was created.
    :vartype created_at: ~datetime.datetime
    """

    _validation = {
        'uuid': {'pattern': r'^$|[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}'},
        'cluster_uuid': {'pattern': r'^$|[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}'},
        'type': {'required': True},
        'value': {'required': True},
        'created_at': {'readonly': True},
    }

    _attribute_map = {
        'uuid': {'key': 'uuid', 'type': 'str'},
        'cluster_uuid': {'key': 'cluster_uuid', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.FirewallRuleType"],
        value: str,
        uuid: Optional[str] = None,
        cluster_uuid: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword uuid: A unique ID for the firewall rule itself.
        :paramtype uuid: str
        :keyword cluster_uuid: A unique ID for the database cluster to which the rule is applied.
        :paramtype cluster_uuid: str
        :keyword type: Required. The type of resource that the firewall rule allows to access the
         database cluster. Known values are: "droplet", "k8s", "ip_addr", "tag", "app".
        :paramtype type: str or ~digital_ocean_api.models.FirewallRuleType
        :keyword value: Required. The ID of the specific resource, the name of a tag applied to a group
         of resources, or the IP address that the firewall rule allows to access the database cluster.
        :paramtype value: str
        """
        super(FirewallRule, self).__init__(**kwargs)
        self.uuid = uuid
        self.cluster_uuid = cluster_uuid
        self.type = type
        self.value = value
        self.created_at = None


class FirewallRuleBase(msrest.serialization.Model):
    """FirewallRuleBase.

    All required parameters must be populated in order to send to Azure.

    :ivar protocol: Required. The type of traffic to be allowed. This may be one of ``tcp``\ ,
     ``udp``\ , or ``icmp``. Known values are: "tcp", "udp", "icmp".
    :vartype protocol: str or ~digital_ocean_api.models.FirewallRuleBaseProtocol
    :ivar ports: Required. The ports on which traffic will be allowed specified as a string
     containing a single port, a range (e.g. "8000-9000"), or "0" when all ports are open for a
     protocol. For ICMP rules this parameter will always return "0".
    :vartype ports: str
    """

    _validation = {
        'protocol': {'required': True},
        'ports': {'required': True},
    }

    _attribute_map = {
        'protocol': {'key': 'protocol', 'type': 'str'},
        'ports': {'key': 'ports', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        protocol: Union[str, "_models.FirewallRuleBaseProtocol"],
        ports: str,
        **kwargs
    ):
        """
        :keyword protocol: Required. The type of traffic to be allowed. This may be one of ``tcp``\ ,
         ``udp``\ , or ``icmp``. Known values are: "tcp", "udp", "icmp".
        :paramtype protocol: str or ~digital_ocean_api.models.FirewallRuleBaseProtocol
        :keyword ports: Required. The ports on which traffic will be allowed specified as a string
         containing a single port, a range (e.g. "8000-9000"), or "0" when all ports are open for a
         protocol. For ICMP rules this parameter will always return "0".
        :paramtype ports: str
        """
        super(FirewallRuleBase, self).__init__(**kwargs)
        self.protocol = protocol
        self.ports = ports


class FirewallRuleTarget(msrest.serialization.Model):
    """FirewallRuleTarget.

    :ivar addresses: An array of strings containing the IPv4 addresses, IPv6 addresses, IPv4 CIDRs,
     and/or IPv6 CIDRs to which the firewall will allow traffic.
    :vartype addresses: list[str]
    :ivar droplet_ids: An array containing the IDs of the Droplets to which the firewall will allow
     traffic.
    :vartype droplet_ids: list[int]
    :ivar load_balancer_uids: An array containing the IDs of the load balancers to which the
     firewall will allow traffic.
    :vartype load_balancer_uids: list[str]
    :ivar kubernetes_ids: An array containing the IDs of the Kubernetes clusters to which the
     firewall will allow traffic.
    :vartype kubernetes_ids: list[str]
    :ivar tags: A set of tags. Any object.
    :vartype tags: any
    """

    _attribute_map = {
        'addresses': {'key': 'addresses', 'type': '[str]'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'load_balancer_uids': {'key': 'load_balancer_uids', 'type': '[str]'},
        'kubernetes_ids': {'key': 'kubernetes_ids', 'type': '[str]'},
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        addresses: Optional[List[str]] = None,
        droplet_ids: Optional[List[int]] = None,
        load_balancer_uids: Optional[List[str]] = None,
        kubernetes_ids: Optional[List[str]] = None,
        tags: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword addresses: An array of strings containing the IPv4 addresses, IPv6 addresses, IPv4
         CIDRs, and/or IPv6 CIDRs to which the firewall will allow traffic.
        :paramtype addresses: list[str]
        :keyword droplet_ids: An array containing the IDs of the Droplets to which the firewall will
         allow traffic.
        :paramtype droplet_ids: list[int]
        :keyword load_balancer_uids: An array containing the IDs of the load balancers to which the
         firewall will allow traffic.
        :paramtype load_balancer_uids: list[str]
        :keyword kubernetes_ids: An array containing the IDs of the Kubernetes clusters to which the
         firewall will allow traffic.
        :paramtype kubernetes_ids: list[str]
        :keyword tags: A set of tags. Any object.
        :paramtype tags: any
        """
        super(FirewallRuleTarget, self).__init__(**kwargs)
        self.addresses = addresses
        self.droplet_ids = droplet_ids
        self.load_balancer_uids = load_balancer_uids
        self.kubernetes_ids = kubernetes_ids
        self.tags = tags


class FirewallRulesInboundRulesAllOfProperties(FirewallRuleTarget):
    """FirewallRulesInboundRulesAllOfProperties.

    :ivar addresses: An array of strings containing the IPv4 addresses, IPv6 addresses, IPv4 CIDRs,
     and/or IPv6 CIDRs to which the firewall will allow traffic.
    :vartype addresses: list[str]
    :ivar droplet_ids: An array containing the IDs of the Droplets to which the firewall will allow
     traffic.
    :vartype droplet_ids: list[int]
    :ivar load_balancer_uids: An array containing the IDs of the load balancers to which the
     firewall will allow traffic.
    :vartype load_balancer_uids: list[str]
    :ivar kubernetes_ids: An array containing the IDs of the Kubernetes clusters to which the
     firewall will allow traffic.
    :vartype kubernetes_ids: list[str]
    :ivar tags: A set of tags. Any object.
    :vartype tags: any
    """

    _attribute_map = {
        'addresses': {'key': 'addresses', 'type': '[str]'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'load_balancer_uids': {'key': 'load_balancer_uids', 'type': '[str]'},
        'kubernetes_ids': {'key': 'kubernetes_ids', 'type': '[str]'},
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        addresses: Optional[List[str]] = None,
        droplet_ids: Optional[List[int]] = None,
        load_balancer_uids: Optional[List[str]] = None,
        kubernetes_ids: Optional[List[str]] = None,
        tags: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword addresses: An array of strings containing the IPv4 addresses, IPv6 addresses, IPv4
         CIDRs, and/or IPv6 CIDRs to which the firewall will allow traffic.
        :paramtype addresses: list[str]
        :keyword droplet_ids: An array containing the IDs of the Droplets to which the firewall will
         allow traffic.
        :paramtype droplet_ids: list[int]
        :keyword load_balancer_uids: An array containing the IDs of the load balancers to which the
         firewall will allow traffic.
        :paramtype load_balancer_uids: list[str]
        :keyword kubernetes_ids: An array containing the IDs of the Kubernetes clusters to which the
         firewall will allow traffic.
        :paramtype kubernetes_ids: list[str]
        :keyword tags: A set of tags. Any object.
        :paramtype tags: any
        """
        super(FirewallRulesInboundRulesAllOfProperties, self).__init__(addresses=addresses, droplet_ids=droplet_ids, load_balancer_uids=load_balancer_uids, kubernetes_ids=kubernetes_ids, tags=tags, **kwargs)


class FirewallRulesInboundRulesItem(FirewallRuleBase, Components15UghnxSchemasFirewallRulesPropertiesInboundRulesItemsAllof1):
    """FirewallRulesInboundRulesItem.

    All required parameters must be populated in order to send to Azure.

    :ivar sources: Required.
    :vartype sources: ~digital_ocean_api.models.FirewallRulesInboundRulesAllOfProperties
    :ivar protocol: Required. The type of traffic to be allowed. This may be one of ``tcp``\ ,
     ``udp``\ , or ``icmp``. Known values are: "tcp", "udp", "icmp".
    :vartype protocol: str or ~digital_ocean_api.models.FirewallRuleBaseProtocol
    :ivar ports: Required. The ports on which traffic will be allowed specified as a string
     containing a single port, a range (e.g. "8000-9000"), or "0" when all ports are open for a
     protocol. For ICMP rules this parameter will always return "0".
    :vartype ports: str
    """

    _validation = {
        'sources': {'required': True},
        'protocol': {'required': True},
        'ports': {'required': True},
    }

    _attribute_map = {
        'sources': {'key': 'sources', 'type': 'FirewallRulesInboundRulesAllOfProperties'},
        'protocol': {'key': 'protocol', 'type': 'str'},
        'ports': {'key': 'ports', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        sources: "_models.FirewallRulesInboundRulesAllOfProperties",
        protocol: Union[str, "_models.FirewallRuleBaseProtocol"],
        ports: str,
        **kwargs
    ):
        """
        :keyword sources: Required.
        :paramtype sources: ~digital_ocean_api.models.FirewallRulesInboundRulesAllOfProperties
        :keyword protocol: Required. The type of traffic to be allowed. This may be one of ``tcp``\ ,
         ``udp``\ , or ``icmp``. Known values are: "tcp", "udp", "icmp".
        :paramtype protocol: str or ~digital_ocean_api.models.FirewallRuleBaseProtocol
        :keyword ports: Required. The ports on which traffic will be allowed specified as a string
         containing a single port, a range (e.g. "8000-9000"), or "0" when all ports are open for a
         protocol. For ICMP rules this parameter will always return "0".
        :paramtype ports: str
        """
        super(FirewallRulesInboundRulesItem, self).__init__(protocol=protocol, ports=ports, sources=sources, **kwargs)
        self.sources = sources
        self.protocol = protocol
        self.ports = ports


class FirewallRulesOutboundRulesAllOfProperties(FirewallRuleTarget):
    """FirewallRulesOutboundRulesAllOfProperties.

    :ivar addresses: An array of strings containing the IPv4 addresses, IPv6 addresses, IPv4 CIDRs,
     and/or IPv6 CIDRs to which the firewall will allow traffic.
    :vartype addresses: list[str]
    :ivar droplet_ids: An array containing the IDs of the Droplets to which the firewall will allow
     traffic.
    :vartype droplet_ids: list[int]
    :ivar load_balancer_uids: An array containing the IDs of the load balancers to which the
     firewall will allow traffic.
    :vartype load_balancer_uids: list[str]
    :ivar kubernetes_ids: An array containing the IDs of the Kubernetes clusters to which the
     firewall will allow traffic.
    :vartype kubernetes_ids: list[str]
    :ivar tags: A set of tags. Any object.
    :vartype tags: any
    """

    _attribute_map = {
        'addresses': {'key': 'addresses', 'type': '[str]'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'load_balancer_uids': {'key': 'load_balancer_uids', 'type': '[str]'},
        'kubernetes_ids': {'key': 'kubernetes_ids', 'type': '[str]'},
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        addresses: Optional[List[str]] = None,
        droplet_ids: Optional[List[int]] = None,
        load_balancer_uids: Optional[List[str]] = None,
        kubernetes_ids: Optional[List[str]] = None,
        tags: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword addresses: An array of strings containing the IPv4 addresses, IPv6 addresses, IPv4
         CIDRs, and/or IPv6 CIDRs to which the firewall will allow traffic.
        :paramtype addresses: list[str]
        :keyword droplet_ids: An array containing the IDs of the Droplets to which the firewall will
         allow traffic.
        :paramtype droplet_ids: list[int]
        :keyword load_balancer_uids: An array containing the IDs of the load balancers to which the
         firewall will allow traffic.
        :paramtype load_balancer_uids: list[str]
        :keyword kubernetes_ids: An array containing the IDs of the Kubernetes clusters to which the
         firewall will allow traffic.
        :paramtype kubernetes_ids: list[str]
        :keyword tags: A set of tags. Any object.
        :paramtype tags: any
        """
        super(FirewallRulesOutboundRulesAllOfProperties, self).__init__(addresses=addresses, droplet_ids=droplet_ids, load_balancer_uids=load_balancer_uids, kubernetes_ids=kubernetes_ids, tags=tags, **kwargs)


class FirewallRulesOutboundRulesItem(FirewallRuleBase, ComponentsZea7QwSchemasFirewallRulesPropertiesOutboundRulesItemsAllof1):
    """FirewallRulesOutboundRulesItem.

    All required parameters must be populated in order to send to Azure.

    :ivar destinations: Required.
    :vartype destinations: ~digital_ocean_api.models.FirewallRulesOutboundRulesAllOfProperties
    :ivar protocol: Required. The type of traffic to be allowed. This may be one of ``tcp``\ ,
     ``udp``\ , or ``icmp``. Known values are: "tcp", "udp", "icmp".
    :vartype protocol: str or ~digital_ocean_api.models.FirewallRuleBaseProtocol
    :ivar ports: Required. The ports on which traffic will be allowed specified as a string
     containing a single port, a range (e.g. "8000-9000"), or "0" when all ports are open for a
     protocol. For ICMP rules this parameter will always return "0".
    :vartype ports: str
    """

    _validation = {
        'destinations': {'required': True},
        'protocol': {'required': True},
        'ports': {'required': True},
    }

    _attribute_map = {
        'destinations': {'key': 'destinations', 'type': 'FirewallRulesOutboundRulesAllOfProperties'},
        'protocol': {'key': 'protocol', 'type': 'str'},
        'ports': {'key': 'ports', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        destinations: "_models.FirewallRulesOutboundRulesAllOfProperties",
        protocol: Union[str, "_models.FirewallRuleBaseProtocol"],
        ports: str,
        **kwargs
    ):
        """
        :keyword destinations: Required.
        :paramtype destinations: ~digital_ocean_api.models.FirewallRulesOutboundRulesAllOfProperties
        :keyword protocol: Required. The type of traffic to be allowed. This may be one of ``tcp``\ ,
         ``udp``\ , or ``icmp``. Known values are: "tcp", "udp", "icmp".
        :paramtype protocol: str or ~digital_ocean_api.models.FirewallRuleBaseProtocol
        :keyword ports: Required. The ports on which traffic will be allowed specified as a string
         containing a single port, a range (e.g. "8000-9000"), or "0" when all ports are open for a
         protocol. For ICMP rules this parameter will always return "0".
        :paramtype ports: str
        """
        super(FirewallRulesOutboundRulesItem, self).__init__(protocol=protocol, ports=ports, destinations=destinations, **kwargs)
        self.destinations = destinations
        self.protocol = protocol
        self.ports = ports


class FloatingIp(msrest.serialization.Model):
    """FloatingIp.

    :ivar ip: The public IP address of the floating IP. It also serves as its identifier.
    :vartype ip: str
    :ivar region:
    :vartype region: ~digital_ocean_api.models.FloatingIpRegion
    :ivar droplet: The Droplet that the floating IP has been assigned to. When you query a floating
     IP, if it is assigned to a Droplet, the entire Droplet object will be returned. If it is not
     assigned, the value will be null.
    :vartype droplet: any
    :ivar locked: A boolean value indicating whether or not the floating IP has pending actions
     preventing new ones from being submitted.
    :vartype locked: bool
    """

    _attribute_map = {
        'ip': {'key': 'ip', 'type': 'str'},
        'region': {'key': 'region', 'type': 'FloatingIpRegion'},
        'droplet': {'key': 'droplet', 'type': 'object'},
        'locked': {'key': 'locked', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        ip: Optional[str] = None,
        region: Optional["_models.FloatingIpRegion"] = None,
        droplet: Optional[Any] = None,
        locked: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword ip: The public IP address of the floating IP. It also serves as its identifier.
        :paramtype ip: str
        :keyword region:
        :paramtype region: ~digital_ocean_api.models.FloatingIpRegion
        :keyword droplet: The Droplet that the floating IP has been assigned to. When you query a
         floating IP, if it is assigned to a Droplet, the entire Droplet object will be returned. If it
         is not assigned, the value will be null.
        :paramtype droplet: any
        :keyword locked: A boolean value indicating whether or not the floating IP has pending actions
         preventing new ones from being submitted.
        :paramtype locked: bool
        """
        super(FloatingIp, self).__init__(**kwargs)
        self.ip = ip
        self.region = region
        self.droplet = droplet
        self.locked = locked


class FloatingIpCreatedApplicationJsonProperties(msrest.serialization.Model):
    """FloatingIpCreatedApplicationJsonProperties.

    :ivar droplets:
    :vartype droplets: list[~digital_ocean_api.models.ActionLink]
    :ivar actions:
    :vartype actions: list[~digital_ocean_api.models.ActionLink]
    """

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': '[ActionLink]'},
        'actions': {'key': 'actions', 'type': '[ActionLink]'},
    }

    def __init__(
        self,
        *,
        droplets: Optional[List["_models.ActionLink"]] = None,
        actions: Optional[List["_models.ActionLink"]] = None,
        **kwargs
    ):
        """
        :keyword droplets:
        :paramtype droplets: list[~digital_ocean_api.models.ActionLink]
        :keyword actions:
        :paramtype actions: list[~digital_ocean_api.models.ActionLink]
        """
        super(FloatingIpCreatedApplicationJsonProperties, self).__init__(**kwargs)
        self.droplets = droplets
        self.actions = actions


class Region(msrest.serialization.Model):
    """Region.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The display name of the region.  This will be a full name that is used in
     the control panel and other interfaces.
    :vartype name: str
    :ivar slug: Required. A human-readable string that is used as a unique identifier for each
     region.
    :vartype slug: str
    :ivar features: Required. This attribute is set to an array which contains features available
     in this region.
    :vartype features: any
    :ivar available: Required. This is a boolean value that represents whether new Droplets can be
     created in this region.
    :vartype available: bool
    :ivar sizes: Required. This attribute is set to an array which contains the identifying slugs
     for the sizes available in this region.
    :vartype sizes: any
    """

    _validation = {
        'name': {'required': True},
        'slug': {'required': True},
        'features': {'required': True},
        'available': {'required': True},
        'sizes': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'features': {'key': 'features', 'type': 'object'},
        'available': {'key': 'available', 'type': 'bool'},
        'sizes': {'key': 'sizes', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        name: str,
        slug: str,
        features: Any,
        available: bool,
        sizes: Any,
        **kwargs
    ):
        """
        :keyword name: Required. The display name of the region.  This will be a full name that is used
         in the control panel and other interfaces.
        :paramtype name: str
        :keyword slug: Required. A human-readable string that is used as a unique identifier for each
         region.
        :paramtype slug: str
        :keyword features: Required. This attribute is set to an array which contains features
         available in this region.
        :paramtype features: any
        :keyword available: Required. This is a boolean value that represents whether new Droplets can
         be created in this region.
        :paramtype available: bool
        :keyword sizes: Required. This attribute is set to an array which contains the identifying
         slugs for the sizes available in this region.
        :paramtype sizes: any
        """
        super(Region, self).__init__(**kwargs)
        self.name = name
        self.slug = slug
        self.features = features
        self.available = available
        self.sizes = sizes


class FloatingIpRegion(Region):
    """FloatingIpRegion.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The display name of the region.  This will be a full name that is used in
     the control panel and other interfaces.
    :vartype name: str
    :ivar slug: Required. A human-readable string that is used as a unique identifier for each
     region.
    :vartype slug: str
    :ivar features: Required. This attribute is set to an array which contains features available
     in this region.
    :vartype features: any
    :ivar available: Required. This is a boolean value that represents whether new Droplets can be
     created in this region.
    :vartype available: bool
    :ivar sizes: Required. This attribute is set to an array which contains the identifying slugs
     for the sizes available in this region.
    :vartype sizes: any
    """

    _validation = {
        'name': {'required': True},
        'slug': {'required': True},
        'features': {'required': True},
        'available': {'required': True},
        'sizes': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'features': {'key': 'features', 'type': 'object'},
        'available': {'key': 'available', 'type': 'bool'},
        'sizes': {'key': 'sizes', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        name: str,
        slug: str,
        features: Any,
        available: bool,
        sizes: Any,
        **kwargs
    ):
        """
        :keyword name: Required. The display name of the region.  This will be a full name that is used
         in the control panel and other interfaces.
        :paramtype name: str
        :keyword slug: Required. A human-readable string that is used as a unique identifier for each
         region.
        :paramtype slug: str
        :keyword features: Required. This attribute is set to an array which contains features
         available in this region.
        :paramtype features: any
        :keyword available: Required. This is a boolean value that represents whether new Droplets can
         be created in this region.
        :paramtype available: bool
        :keyword sizes: Required. This attribute is set to an array which contains the identifying
         slugs for the sizes available in this region.
        :paramtype sizes: any
        """
        super(FloatingIpRegion, self).__init__(name=name, slug=slug, features=features, available=available, sizes=sizes, **kwargs)


class ForwardingRule(msrest.serialization.Model):
    """An object specifying a forwarding rule for a load balancer.

    All required parameters must be populated in order to send to Azure.

    :ivar entry_protocol: Required. The protocol used for traffic to the load balancer. The
     possible values are: ``http``\ , ``https``\ , ``http2``\ , or ``tcp``. Known values are:
     "http", "https", "http2", "tcp".
    :vartype entry_protocol: str or ~digital_ocean_api.models.ForwardingRuleEntryProtocol
    :ivar entry_port: Required. An integer representing the port on which the load balancer
     instance will listen.
    :vartype entry_port: int
    :ivar target_protocol: Required. The protocol used for traffic from the load balancer to the
     backend Droplets. The possible values are: ``http``\ , ``https``\ , ``http2``\ , or ``tcp``.
     Known values are: "http", "https", "http2", "tcp".
    :vartype target_protocol: str or ~digital_ocean_api.models.ForwardingRuleTargetProtocol
    :ivar target_port: Required. An integer representing the port on the backend Droplets to which
     the load balancer will send traffic.
    :vartype target_port: int
    :ivar certificate_id: The ID of the TLS certificate used for SSL termination if enabled.
    :vartype certificate_id: str
    :ivar tls_passthrough: A boolean value indicating whether SSL encrypted traffic will be passed
     through to the backend Droplets.
    :vartype tls_passthrough: bool
    """

    _validation = {
        'entry_protocol': {'required': True},
        'entry_port': {'required': True},
        'target_protocol': {'required': True},
        'target_port': {'required': True},
    }

    _attribute_map = {
        'entry_protocol': {'key': 'entry_protocol', 'type': 'str'},
        'entry_port': {'key': 'entry_port', 'type': 'int'},
        'target_protocol': {'key': 'target_protocol', 'type': 'str'},
        'target_port': {'key': 'target_port', 'type': 'int'},
        'certificate_id': {'key': 'certificate_id', 'type': 'str'},
        'tls_passthrough': {'key': 'tls_passthrough', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        entry_protocol: Union[str, "_models.ForwardingRuleEntryProtocol"],
        entry_port: int,
        target_protocol: Union[str, "_models.ForwardingRuleTargetProtocol"],
        target_port: int,
        certificate_id: Optional[str] = None,
        tls_passthrough: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword entry_protocol: Required. The protocol used for traffic to the load balancer. The
         possible values are: ``http``\ , ``https``\ , ``http2``\ , or ``tcp``. Known values are:
         "http", "https", "http2", "tcp".
        :paramtype entry_protocol: str or ~digital_ocean_api.models.ForwardingRuleEntryProtocol
        :keyword entry_port: Required. An integer representing the port on which the load balancer
         instance will listen.
        :paramtype entry_port: int
        :keyword target_protocol: Required. The protocol used for traffic from the load balancer to the
         backend Droplets. The possible values are: ``http``\ , ``https``\ , ``http2``\ , or ``tcp``.
         Known values are: "http", "https", "http2", "tcp".
        :paramtype target_protocol: str or ~digital_ocean_api.models.ForwardingRuleTargetProtocol
        :keyword target_port: Required. An integer representing the port on the backend Droplets to
         which the load balancer will send traffic.
        :paramtype target_port: int
        :keyword certificate_id: The ID of the TLS certificate used for SSL termination if enabled.
        :paramtype certificate_id: str
        :keyword tls_passthrough: A boolean value indicating whether SSL encrypted traffic will be
         passed through to the backend Droplets.
        :paramtype tls_passthrough: bool
        """
        super(ForwardingRule, self).__init__(**kwargs)
        self.entry_protocol = entry_protocol
        self.entry_port = entry_port
        self.target_protocol = target_protocol
        self.target_port = target_port
        self.certificate_id = certificate_id
        self.tls_passthrough = tls_passthrough


class LinkToNextPage(msrest.serialization.Model):
    """LinkToNextPage.

    :ivar next: URI of the next page of the results.
    :vartype next: str
    """

    _attribute_map = {
        'next': {'key': 'next', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        next: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword next: URI of the next page of the results.
        :paramtype next: str
        """
        super(LinkToNextPage, self).__init__(**kwargs)
        self.next = next


class LinkToLastPage(msrest.serialization.Model):
    """LinkToLastPage.

    :ivar last: URI of the last page of the results.
    :vartype last: str
    """

    _attribute_map = {
        'last': {'key': 'last', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        last: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword last: URI of the last page of the results.
        :paramtype last: str
        """
        super(LinkToLastPage, self).__init__(**kwargs)
        self.last = last


class ForwardLinks(LinkToLastPage, LinkToNextPage):
    """ForwardLinks.

    :ivar next: URI of the next page of the results.
    :vartype next: str
    :ivar last: URI of the last page of the results.
    :vartype last: str
    """

    _attribute_map = {
        'next': {'key': 'next', 'type': 'str'},
        'last': {'key': 'last', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        next: Optional[str] = None,
        last: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword next: URI of the next page of the results.
        :paramtype next: str
        :keyword last: URI of the last page of the results.
        :paramtype last: str
        """
        super(ForwardLinks, self).__init__(last=last, next=next, **kwargs)
        self.next = next
        self.last = last


class GarbageCollection(msrest.serialization.Model):
    """GarbageCollection.

    :ivar uuid: A string specifying the UUID of the garbage collection.
    :vartype uuid: str
    :ivar registry_name: The name of the container registry.
    :vartype registry_name: str
    :ivar status: The current status of this garbage collection. Known values are: "requested",
     "waiting for write JWTs to expire", "scanning manifests", "deleting unreferenced blobs",
     "cancelling", "failed", "succeeded", "cancelled".
    :vartype status: str or ~digital_ocean_api.models.GarbageCollectionStatus
    :ivar created_at: The time the garbage collection was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: The time the garbage collection was last updated.
    :vartype updated_at: ~datetime.datetime
    :ivar blobs_deleted: The number of blobs deleted as a result of this garbage collection.
    :vartype blobs_deleted: int
    :ivar freed_bytes: The number of bytes freed as a result of this garbage collection.
    :vartype freed_bytes: int
    """

    _attribute_map = {
        'uuid': {'key': 'uuid', 'type': 'str'},
        'registry_name': {'key': 'registry_name', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
        'blobs_deleted': {'key': 'blobs_deleted', 'type': 'int'},
        'freed_bytes': {'key': 'freed_bytes', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        uuid: Optional[str] = None,
        registry_name: Optional[str] = None,
        status: Optional[Union[str, "_models.GarbageCollectionStatus"]] = None,
        created_at: Optional[datetime.datetime] = None,
        updated_at: Optional[datetime.datetime] = None,
        blobs_deleted: Optional[int] = None,
        freed_bytes: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword uuid: A string specifying the UUID of the garbage collection.
        :paramtype uuid: str
        :keyword registry_name: The name of the container registry.
        :paramtype registry_name: str
        :keyword status: The current status of this garbage collection. Known values are: "requested",
         "waiting for write JWTs to expire", "scanning manifests", "deleting unreferenced blobs",
         "cancelling", "failed", "succeeded", "cancelled".
        :paramtype status: str or ~digital_ocean_api.models.GarbageCollectionStatus
        :keyword created_at: The time the garbage collection was created.
        :paramtype created_at: ~datetime.datetime
        :keyword updated_at: The time the garbage collection was last updated.
        :paramtype updated_at: ~datetime.datetime
        :keyword blobs_deleted: The number of blobs deleted as a result of this garbage collection.
        :paramtype blobs_deleted: int
        :keyword freed_bytes: The number of bytes freed as a result of this garbage collection.
        :paramtype freed_bytes: int
        """
        super(GarbageCollection, self).__init__(**kwargs)
        self.uuid = uuid
        self.registry_name = registry_name
        self.status = status
        self.created_at = created_at
        self.updated_at = updated_at
        self.blobs_deleted = blobs_deleted
        self.freed_bytes = freed_bytes


class HealthCheck(msrest.serialization.Model):
    """An object specifying health check settings for the load balancer.

    :ivar protocol: The protocol used for health checks sent to the backend Droplets. The possible
     values are ``http``\ , ``https``\ , or ``tcp``. Known values are: "http", "https", "tcp".
     Default value: "http".
    :vartype protocol: str or ~digital_ocean_api.models.HealthCheckProtocol
    :ivar port: An integer representing the port on the backend Droplets on which the health check
     will attempt a connection.
    :vartype port: int
    :ivar path: The path on the backend Droplets to which the load balancer instance will send a
     request.
    :vartype path: str
    :ivar check_interval_seconds: The number of seconds between between two consecutive health
     checks.
    :vartype check_interval_seconds: int
    :ivar response_timeout_seconds: The number of seconds the load balancer instance will wait for
     a response until marking a health check as failed.
    :vartype response_timeout_seconds: int
    :ivar unhealthy_threshold: The number of times a health check must fail for a backend Droplet
     to be marked "unhealthy" and be removed from the pool.
    :vartype unhealthy_threshold: int
    :ivar healthy_threshold: The number of times a health check must pass for a backend Droplet to
     be marked "healthy" and be re-added to the pool.
    :vartype healthy_threshold: int
    """

    _attribute_map = {
        'protocol': {'key': 'protocol', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'path': {'key': 'path', 'type': 'str'},
        'check_interval_seconds': {'key': 'check_interval_seconds', 'type': 'int'},
        'response_timeout_seconds': {'key': 'response_timeout_seconds', 'type': 'int'},
        'unhealthy_threshold': {'key': 'unhealthy_threshold', 'type': 'int'},
        'healthy_threshold': {'key': 'healthy_threshold', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        protocol: Optional[Union[str, "_models.HealthCheckProtocol"]] = "http",
        port: Optional[int] = 80,
        path: Optional[str] = "/",
        check_interval_seconds: Optional[int] = 10,
        response_timeout_seconds: Optional[int] = 5,
        unhealthy_threshold: Optional[int] = 5,
        healthy_threshold: Optional[int] = 3,
        **kwargs
    ):
        """
        :keyword protocol: The protocol used for health checks sent to the backend Droplets. The
         possible values are ``http``\ , ``https``\ , or ``tcp``. Known values are: "http", "https",
         "tcp". Default value: "http".
        :paramtype protocol: str or ~digital_ocean_api.models.HealthCheckProtocol
        :keyword port: An integer representing the port on the backend Droplets on which the health
         check will attempt a connection.
        :paramtype port: int
        :keyword path: The path on the backend Droplets to which the load balancer instance will send a
         request.
        :paramtype path: str
        :keyword check_interval_seconds: The number of seconds between between two consecutive health
         checks.
        :paramtype check_interval_seconds: int
        :keyword response_timeout_seconds: The number of seconds the load balancer instance will wait
         for a response until marking a health check as failed.
        :paramtype response_timeout_seconds: int
        :keyword unhealthy_threshold: The number of times a health check must fail for a backend
         Droplet to be marked "unhealthy" and be removed from the pool.
        :paramtype unhealthy_threshold: int
        :keyword healthy_threshold: The number of times a health check must pass for a backend Droplet
         to be marked "healthy" and be re-added to the pool.
        :paramtype healthy_threshold: int
        """
        super(HealthCheck, self).__init__(**kwargs)
        self.protocol = protocol
        self.port = port
        self.path = path
        self.check_interval_seconds = check_interval_seconds
        self.response_timeout_seconds = response_timeout_seconds
        self.unhealthy_threshold = unhealthy_threshold
        self.healthy_threshold = healthy_threshold


class Image(msrest.serialization.Model):
    """Image.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A unique number that can be used to identify and reference a specific image.
    :vartype id: int
    :ivar name: The display name that has been given to an image.  This is what is shown in the
     control panel and is generally a descriptive title for the image in question.
    :vartype name: str
    :ivar type: Describes the kind of image. It may be one of "snapshot", "backup", or "custom".
     This specifies whether an image is a user-generated Droplet snapshot, automatically created
     Droplet backup, or a user-provided virtual machine image. Known values are: "base", "snapshot",
     "backup", "custom".
    :vartype type: str or ~digital_ocean_api.models.ImageType
    :ivar distribution: The name of a custom image's distribution. Currently, the valid values are
     "Arch Linux", "CentOS", "CoreOS", "Debian", "Fedora", "Fedora Atomic",  "FreeBSD", "Gentoo",
     "openSUSE", "RancherOS", "Ubuntu", and "Unknown".  Any other value will be accepted but
     ignored, and "Unknown" will be used in its place. Known values are: "Arch Linux", "CentOS",
     "CoreOS", "Debian", "Fedora", "Fedora Atomic", "FreeBSD", "Gentoo", "openSUSE", "RancherOS",
     "Ubuntu", "Unknown".
    :vartype distribution: str or ~digital_ocean_api.models.Distribution
    :ivar slug: A uniquely identifying string that is associated with each of the
     DigitalOcean-provided public images. These can be used to reference a public image as an
     alternative to the numeric id.
    :vartype slug: str
    :ivar public: This is a boolean value that indicates whether the image in question is public or
     not. An image that is public is available to all accounts. A non-public image is only
     accessible from your account.
    :vartype public: bool
    :ivar regions: This attribute is an array of the regions that the image is available in. The
     regions are represented by their identifying slug values.
    :vartype regions: list[str or ~digital_ocean_api.models.RegionSlug]
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the image was created.
    :vartype created_at: ~datetime.datetime
    :ivar min_disk_size: The minimum disk size in GB required for a Droplet to use this image.
    :vartype min_disk_size: int
    :ivar size_gigabytes: The size of the image in gigabytes.
    :vartype size_gigabytes: float
    :ivar description: An optional free-form text field to describe an image.
    :vartype description: str
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    :ivar status: A status string indicating the state of a custom image. This may be ``NEW``\ ,
      ``available``\ , ``pending``\ , ``deleted``\ , or ``retired``. Known values are: "NEW",
     "available", "pending", "deleted", "retired".
    :vartype status: str or ~digital_ocean_api.models.ImageStatus
    :ivar error_message: A string containing information about errors that may occur when importing
      a custom image.
    :vartype error_message: str
    """

    _validation = {
        'id': {'readonly': True},
        'min_disk_size': {'minimum': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'distribution': {'key': 'distribution', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'public': {'key': 'public', 'type': 'bool'},
        'regions': {'key': 'regions', 'type': '[str]'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'min_disk_size': {'key': 'min_disk_size', 'type': 'int'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'float'},
        'description': {'key': 'description', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'status': {'key': 'status', 'type': 'str'},
        'error_message': {'key': 'error_message', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[Union[str, "_models.ImageType"]] = None,
        distribution: Optional[Union[str, "_models.Distribution"]] = None,
        slug: Optional[str] = None,
        public: Optional[bool] = None,
        regions: Optional[List[Union[str, "_models.RegionSlug"]]] = None,
        created_at: Optional[datetime.datetime] = None,
        min_disk_size: Optional[int] = None,
        size_gigabytes: Optional[float] = None,
        description: Optional[str] = None,
        tags: Optional[List[str]] = None,
        status: Optional[Union[str, "_models.ImageStatus"]] = None,
        error_message: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The display name that has been given to an image.  This is what is shown in the
         control panel and is generally a descriptive title for the image in question.
        :paramtype name: str
        :keyword type: Describes the kind of image. It may be one of "snapshot", "backup", or "custom".
         This specifies whether an image is a user-generated Droplet snapshot, automatically created
         Droplet backup, or a user-provided virtual machine image. Known values are: "base", "snapshot",
         "backup", "custom".
        :paramtype type: str or ~digital_ocean_api.models.ImageType
        :keyword distribution: The name of a custom image's distribution. Currently, the valid values
         are  "Arch Linux", "CentOS", "CoreOS", "Debian", "Fedora", "Fedora Atomic",  "FreeBSD",
         "Gentoo", "openSUSE", "RancherOS", "Ubuntu", and "Unknown".  Any other value will be accepted
         but ignored, and "Unknown" will be used in its place. Known values are: "Arch Linux", "CentOS",
         "CoreOS", "Debian", "Fedora", "Fedora Atomic", "FreeBSD", "Gentoo", "openSUSE", "RancherOS",
         "Ubuntu", "Unknown".
        :paramtype distribution: str or ~digital_ocean_api.models.Distribution
        :keyword slug: A uniquely identifying string that is associated with each of the
         DigitalOcean-provided public images. These can be used to reference a public image as an
         alternative to the numeric id.
        :paramtype slug: str
        :keyword public: This is a boolean value that indicates whether the image in question is public
         or not. An image that is public is available to all accounts. A non-public image is only
         accessible from your account.
        :paramtype public: bool
        :keyword regions: This attribute is an array of the regions that the image is available in. The
         regions are represented by their identifying slug values.
        :paramtype regions: list[str or ~digital_ocean_api.models.RegionSlug]
        :keyword created_at: A time value given in ISO8601 combined date and time format that
         represents when the image was created.
        :paramtype created_at: ~datetime.datetime
        :keyword min_disk_size: The minimum disk size in GB required for a Droplet to use this image.
        :paramtype min_disk_size: int
        :keyword size_gigabytes: The size of the image in gigabytes.
        :paramtype size_gigabytes: float
        :keyword description: An optional free-form text field to describe an image.
        :paramtype description: str
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        :keyword status: A status string indicating the state of a custom image. This may be ``NEW``\ ,
          ``available``\ , ``pending``\ , ``deleted``\ , or ``retired``. Known values are: "NEW",
         "available", "pending", "deleted", "retired".
        :paramtype status: str or ~digital_ocean_api.models.ImageStatus
        :keyword error_message: A string containing information about errors that may occur when
         importing
          a custom image.
        :paramtype error_message: str
        """
        super(Image, self).__init__(**kwargs)
        self.id = None
        self.name = name
        self.type = type
        self.distribution = distribution
        self.slug = slug
        self.public = public
        self.regions = regions
        self.created_at = created_at
        self.min_disk_size = min_disk_size
        self.size_gigabytes = size_gigabytes
        self.description = description
        self.tags = tags
        self.status = status
        self.error_message = error_message


class ImageActionBase(msrest.serialization.Model):
    """ImageActionBase.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The action to be taken on the image. Can be either ``convert`` or
     ``transfer``. Known values are: "convert", "transfer".
    :vartype type: str or ~digital_ocean_api.models.ImageActionBaseType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.ImageActionBaseType"],
        **kwargs
    ):
        """
        :keyword type: Required. The action to be taken on the image. Can be either ``convert`` or
         ``transfer``. Known values are: "convert", "transfer".
        :paramtype type: str or ~digital_ocean_api.models.ImageActionBaseType
        """
        super(ImageActionBase, self).__init__(**kwargs)
        self.type = type


class ImageActionTransfer(ImageActionBase):
    """ImageActionTransfer.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The action to be taken on the image. Can be either ``convert`` or
     ``transfer``. Known values are: "convert", "transfer".
    :vartype type: str or ~digital_ocean_api.models.ImageActionBaseType
    :ivar region: Required. The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    """

    _validation = {
        'type': {'required': True},
        'region': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.ImageActionBaseType"],
        region: Union[str, "_models.RegionSlug"],
        **kwargs
    ):
        """
        :keyword type: Required. The action to be taken on the image. Can be either ``convert`` or
         ``transfer``. Known values are: "convert", "transfer".
        :paramtype type: str or ~digital_ocean_api.models.ImageActionBaseType
        :keyword region: Required. The slug identifier for the region where the resource will initially
         be  available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1",
         "nyc2", "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        """
        super(ImageActionTransfer, self).__init__(type=type, **kwargs)
        self.region = region


class ImageUpdate(msrest.serialization.Model):
    """ImageUpdate.

    :ivar name: The display name that has been given to an image.  This is what is shown in the
     control panel and is generally a descriptive title for the image in question.
    :vartype name: str
    :ivar distribution: The name of a custom image's distribution. Currently, the valid values are
     "Arch Linux", "CentOS", "CoreOS", "Debian", "Fedora", "Fedora Atomic",  "FreeBSD", "Gentoo",
     "openSUSE", "RancherOS", "Ubuntu", and "Unknown".  Any other value will be accepted but
     ignored, and "Unknown" will be used in its place. Known values are: "Arch Linux", "CentOS",
     "CoreOS", "Debian", "Fedora", "Fedora Atomic", "FreeBSD", "Gentoo", "openSUSE", "RancherOS",
     "Ubuntu", "Unknown".
    :vartype distribution: str or ~digital_ocean_api.models.Distribution
    :ivar description: An optional free-form text field to describe an image.
    :vartype description: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'distribution': {'key': 'distribution', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        distribution: Optional[Union[str, "_models.Distribution"]] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The display name that has been given to an image.  This is what is shown in the
         control panel and is generally a descriptive title for the image in question.
        :paramtype name: str
        :keyword distribution: The name of a custom image's distribution. Currently, the valid values
         are  "Arch Linux", "CentOS", "CoreOS", "Debian", "Fedora", "Fedora Atomic",  "FreeBSD",
         "Gentoo", "openSUSE", "RancherOS", "Ubuntu", and "Unknown".  Any other value will be accepted
         but ignored, and "Unknown" will be used in its place. Known values are: "Arch Linux", "CentOS",
         "CoreOS", "Debian", "Fedora", "Fedora Atomic", "FreeBSD", "Gentoo", "openSUSE", "RancherOS",
         "Ubuntu", "Unknown".
        :paramtype distribution: str or ~digital_ocean_api.models.Distribution
        :keyword description: An optional free-form text field to describe an image.
        :paramtype description: str
        """
        super(ImageUpdate, self).__init__(**kwargs)
        self.name = name
        self.distribution = distribution
        self.description = description


class ImageNewCustom(ImageUpdate):
    """ImageNewCustom.

    All required parameters must be populated in order to send to Azure.

    :ivar name: The display name that has been given to an image.  This is what is shown in the
     control panel and is generally a descriptive title for the image in question.
    :vartype name: str
    :ivar distribution: The name of a custom image's distribution. Currently, the valid values are
     "Arch Linux", "CentOS", "CoreOS", "Debian", "Fedora", "Fedora Atomic",  "FreeBSD", "Gentoo",
     "openSUSE", "RancherOS", "Ubuntu", and "Unknown".  Any other value will be accepted but
     ignored, and "Unknown" will be used in its place. Known values are: "Arch Linux", "CentOS",
     "CoreOS", "Debian", "Fedora", "Fedora Atomic", "FreeBSD", "Gentoo", "openSUSE", "RancherOS",
     "Ubuntu", "Unknown".
    :vartype distribution: str or ~digital_ocean_api.models.Distribution
    :ivar description: An optional free-form text field to describe an image.
    :vartype description: str
    :ivar url: Required. A URL from which the custom Linux virtual machine image may be retrieved.
     The image it points to must be in the raw, qcow2, vhdx, vdi, or vmdk format.  It may be
     compressed using gzip or bzip2 and must be smaller than 100 GB after being decompressed.
    :vartype url: str
    :ivar region: Required. The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    """

    _validation = {
        'url': {'required': True},
        'region': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'distribution': {'key': 'distribution', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'url': {'key': 'url', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        url: str,
        region: Union[str, "_models.RegionSlug"],
        name: Optional[str] = None,
        distribution: Optional[Union[str, "_models.Distribution"]] = None,
        description: Optional[str] = None,
        tags: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword name: The display name that has been given to an image.  This is what is shown in the
         control panel and is generally a descriptive title for the image in question.
        :paramtype name: str
        :keyword distribution: The name of a custom image's distribution. Currently, the valid values
         are  "Arch Linux", "CentOS", "CoreOS", "Debian", "Fedora", "Fedora Atomic",  "FreeBSD",
         "Gentoo", "openSUSE", "RancherOS", "Ubuntu", and "Unknown".  Any other value will be accepted
         but ignored, and "Unknown" will be used in its place. Known values are: "Arch Linux", "CentOS",
         "CoreOS", "Debian", "Fedora", "Fedora Atomic", "FreeBSD", "Gentoo", "openSUSE", "RancherOS",
         "Ubuntu", "Unknown".
        :paramtype distribution: str or ~digital_ocean_api.models.Distribution
        :keyword description: An optional free-form text field to describe an image.
        :paramtype description: str
        :keyword url: Required. A URL from which the custom Linux virtual machine image may be
         retrieved.  The image it points to must be in the raw, qcow2, vhdx, vdi, or vmdk format.  It
         may be compressed using gzip or bzip2 and must be smaller than 100 GB after being decompressed.
        :paramtype url: str
        :keyword region: Required. The slug identifier for the region where the resource will initially
         be  available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1",
         "nyc2", "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        """
        super(ImageNewCustom, self).__init__(name=name, distribution=distribution, description=description, **kwargs)
        self.url = url
        self.region = region
        self.tags = tags


class InvoiceItem(msrest.serialization.Model):
    """InvoiceItem.

    :ivar product: Name of the product being billed in the invoice item.
    :vartype product: str
    :ivar resource_uuid: UUID of the resource billing in the invoice item if available.
    :vartype resource_uuid: str
    :ivar resource_id: ID of the resource billing in the invoice item if available.
    :vartype resource_id: str
    :ivar group_description: Description of the invoice item when it is a grouped set of usage,
     such  as DOKS or databases.
    :vartype group_description: str
    :ivar description: Description of the invoice item.
    :vartype description: str
    :ivar amount: Billed amount of this invoice item. Billed in USD.
    :vartype amount: str
    :ivar duration: Duration of time this invoice item was used and subsequently billed.
    :vartype duration: str
    :ivar duration_unit: Unit of time for duration.
    :vartype duration_unit: str
    :ivar start_time: Time the invoice item began to be billed for usage.
    :vartype start_time: str
    :ivar end_time: Time the invoice item stoped being billed for usage.
    :vartype end_time: str
    :ivar project_name: Name of the DigitalOcean Project this resource belongs to.
    :vartype project_name: str
    """

    _attribute_map = {
        'product': {'key': 'product', 'type': 'str'},
        'resource_uuid': {'key': 'resource_uuid', 'type': 'str'},
        'resource_id': {'key': 'resource_id', 'type': 'str'},
        'group_description': {'key': 'group_description', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
        'duration': {'key': 'duration', 'type': 'str'},
        'duration_unit': {'key': 'duration_unit', 'type': 'str'},
        'start_time': {'key': 'start_time', 'type': 'str'},
        'end_time': {'key': 'end_time', 'type': 'str'},
        'project_name': {'key': 'project_name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        product: Optional[str] = None,
        resource_uuid: Optional[str] = None,
        resource_id: Optional[str] = None,
        group_description: Optional[str] = None,
        description: Optional[str] = None,
        amount: Optional[str] = None,
        duration: Optional[str] = None,
        duration_unit: Optional[str] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        project_name: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword product: Name of the product being billed in the invoice item.
        :paramtype product: str
        :keyword resource_uuid: UUID of the resource billing in the invoice item if available.
        :paramtype resource_uuid: str
        :keyword resource_id: ID of the resource billing in the invoice item if available.
        :paramtype resource_id: str
        :keyword group_description: Description of the invoice item when it is a grouped set of usage,
         such  as DOKS or databases.
        :paramtype group_description: str
        :keyword description: Description of the invoice item.
        :paramtype description: str
        :keyword amount: Billed amount of this invoice item. Billed in USD.
        :paramtype amount: str
        :keyword duration: Duration of time this invoice item was used and subsequently billed.
        :paramtype duration: str
        :keyword duration_unit: Unit of time for duration.
        :paramtype duration_unit: str
        :keyword start_time: Time the invoice item began to be billed for usage.
        :paramtype start_time: str
        :keyword end_time: Time the invoice item stoped being billed for usage.
        :paramtype end_time: str
        :keyword project_name: Name of the DigitalOcean Project this resource belongs to.
        :paramtype project_name: str
        """
        super(InvoiceItem, self).__init__(**kwargs)
        self.product = product
        self.resource_uuid = resource_uuid
        self.resource_id = resource_id
        self.group_description = group_description
        self.description = description
        self.amount = amount
        self.duration = duration
        self.duration_unit = duration_unit
        self.start_time = start_time
        self.end_time = end_time
        self.project_name = project_name


class InvoicePreview(msrest.serialization.Model):
    """The invoice preview.

    :ivar invoice_uuid: The UUID of the invoice. The canonical reference for the invoice.
    :vartype invoice_uuid: str
    :ivar amount: Total amount of the invoice, in USD.  This will reflect month-to-date usage in
     the invoice preview.
    :vartype amount: str
    :ivar invoice_period: Billing period of usage for which the invoice is issued, in ``YYYY-MM``
     format.
    :vartype invoice_period: str
    :ivar updated_at: Time the invoice was last updated.  This is only included with the invoice
     preview.
    :vartype updated_at: str
    """

    _attribute_map = {
        'invoice_uuid': {'key': 'invoice_uuid', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
        'invoice_period': {'key': 'invoice_period', 'type': 'str'},
        'updated_at': {'key': 'updated_at', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        invoice_uuid: Optional[str] = None,
        amount: Optional[str] = None,
        invoice_period: Optional[str] = None,
        updated_at: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword invoice_uuid: The UUID of the invoice. The canonical reference for the invoice.
        :paramtype invoice_uuid: str
        :keyword amount: Total amount of the invoice, in USD.  This will reflect month-to-date usage in
         the invoice preview.
        :paramtype amount: str
        :keyword invoice_period: Billing period of usage for which the invoice is issued, in
         ``YYYY-MM``  format.
        :paramtype invoice_period: str
        :keyword updated_at: Time the invoice was last updated.  This is only included with the invoice
         preview.
        :paramtype updated_at: str
        """
        super(InvoicePreview, self).__init__(**kwargs)
        self.invoice_uuid = invoice_uuid
        self.amount = amount
        self.invoice_period = invoice_period
        self.updated_at = updated_at


class InvoiceSummary(msrest.serialization.Model):
    """InvoiceSummary.

    :ivar invoice_uuid: UUID of the invoice.
    :vartype invoice_uuid: str
    :ivar billing_period: Billing period of usage for which the invoice is issued, in ``YYYY-MM``
     format.
    :vartype billing_period: str
    :ivar amount: Total amount of the invoice, in USD.  This will reflect month-to-date usage in
     the invoice preview.
    :vartype amount: str
    :ivar user_name: Name of the DigitalOcean customer being invoiced.
    :vartype user_name: str
    :ivar user_billing_address:
    :vartype user_billing_address: ~digital_ocean_api.models.InvoiceSummaryUserBillingAddress
    :ivar user_company: Company of the DigitalOcean customer being invoiced, if set.
    :vartype user_company: str
    :ivar user_email: Email of the DigitalOcean customer being invoiced.
    :vartype user_email: str
    :ivar product_charges:
    :vartype product_charges: ~digital_ocean_api.models.InvoiceSummaryProductCharges
    :ivar overages:
    :vartype overages: ~digital_ocean_api.models.InvoiceSummaryOverages
    :ivar taxes:
    :vartype taxes: ~digital_ocean_api.models.InvoiceSummaryTaxes
    :ivar credits_and_adjustments:
    :vartype credits_and_adjustments: ~digital_ocean_api.models.InvoiceSummaryCreditsAndAdjustments
    """

    _attribute_map = {
        'invoice_uuid': {'key': 'invoice_uuid', 'type': 'str'},
        'billing_period': {'key': 'billing_period', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
        'user_name': {'key': 'user_name', 'type': 'str'},
        'user_billing_address': {'key': 'user_billing_address', 'type': 'InvoiceSummaryUserBillingAddress'},
        'user_company': {'key': 'user_company', 'type': 'str'},
        'user_email': {'key': 'user_email', 'type': 'str'},
        'product_charges': {'key': 'product_charges', 'type': 'InvoiceSummaryProductCharges'},
        'overages': {'key': 'overages', 'type': 'InvoiceSummaryOverages'},
        'taxes': {'key': 'taxes', 'type': 'InvoiceSummaryTaxes'},
        'credits_and_adjustments': {'key': 'credits_and_adjustments', 'type': 'InvoiceSummaryCreditsAndAdjustments'},
    }

    def __init__(
        self,
        *,
        invoice_uuid: Optional[str] = None,
        billing_period: Optional[str] = None,
        amount: Optional[str] = None,
        user_name: Optional[str] = None,
        user_billing_address: Optional["_models.InvoiceSummaryUserBillingAddress"] = None,
        user_company: Optional[str] = None,
        user_email: Optional[str] = None,
        product_charges: Optional["_models.InvoiceSummaryProductCharges"] = None,
        overages: Optional["_models.InvoiceSummaryOverages"] = None,
        taxes: Optional["_models.InvoiceSummaryTaxes"] = None,
        credits_and_adjustments: Optional["_models.InvoiceSummaryCreditsAndAdjustments"] = None,
        **kwargs
    ):
        """
        :keyword invoice_uuid: UUID of the invoice.
        :paramtype invoice_uuid: str
        :keyword billing_period: Billing period of usage for which the invoice is issued, in
         ``YYYY-MM``  format.
        :paramtype billing_period: str
        :keyword amount: Total amount of the invoice, in USD.  This will reflect month-to-date usage in
         the invoice preview.
        :paramtype amount: str
        :keyword user_name: Name of the DigitalOcean customer being invoiced.
        :paramtype user_name: str
        :keyword user_billing_address:
        :paramtype user_billing_address: ~digital_ocean_api.models.InvoiceSummaryUserBillingAddress
        :keyword user_company: Company of the DigitalOcean customer being invoiced, if set.
        :paramtype user_company: str
        :keyword user_email: Email of the DigitalOcean customer being invoiced.
        :paramtype user_email: str
        :keyword product_charges:
        :paramtype product_charges: ~digital_ocean_api.models.InvoiceSummaryProductCharges
        :keyword overages:
        :paramtype overages: ~digital_ocean_api.models.InvoiceSummaryOverages
        :keyword taxes:
        :paramtype taxes: ~digital_ocean_api.models.InvoiceSummaryTaxes
        :keyword credits_and_adjustments:
        :paramtype credits_and_adjustments:
         ~digital_ocean_api.models.InvoiceSummaryCreditsAndAdjustments
        """
        super(InvoiceSummary, self).__init__(**kwargs)
        self.invoice_uuid = invoice_uuid
        self.billing_period = billing_period
        self.amount = amount
        self.user_name = user_name
        self.user_billing_address = user_billing_address
        self.user_company = user_company
        self.user_email = user_email
        self.product_charges = product_charges
        self.overages = overages
        self.taxes = taxes
        self.credits_and_adjustments = credits_and_adjustments


class SimpleCharge(msrest.serialization.Model):
    """SimpleCharge.

    :ivar name: Name of the charge.
    :vartype name: str
    :ivar amount: Total amount charged in USD.
    :vartype amount: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        amount: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: Name of the charge.
        :paramtype name: str
        :keyword amount: Total amount charged in USD.
        :paramtype amount: str
        """
        super(SimpleCharge, self).__init__(**kwargs)
        self.name = name
        self.amount = amount


class InvoiceSummaryCreditsAndAdjustments(SimpleCharge):
    """InvoiceSummaryCreditsAndAdjustments.

    :ivar name: Name of the charge.
    :vartype name: str
    :ivar amount: Total amount charged in USD.
    :vartype amount: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        amount: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: Name of the charge.
        :paramtype name: str
        :keyword amount: Total amount charged in USD.
        :paramtype amount: str
        """
        super(InvoiceSummaryCreditsAndAdjustments, self).__init__(name=name, amount=amount, **kwargs)


class InvoiceSummaryOverages(SimpleCharge):
    """InvoiceSummaryOverages.

    :ivar name: Name of the charge.
    :vartype name: str
    :ivar amount: Total amount charged in USD.
    :vartype amount: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        amount: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: Name of the charge.
        :paramtype name: str
        :keyword amount: Total amount charged in USD.
        :paramtype amount: str
        """
        super(InvoiceSummaryOverages, self).__init__(name=name, amount=amount, **kwargs)


class ProductUsageCharges(msrest.serialization.Model):
    """ProductUsageCharges.

    :ivar name: Description of usage charges.
    :vartype name: str
    :ivar amount: Total amount charged.
    :vartype amount: str
    :ivar items: List of amount, and grouped aggregates by resource type.
    :vartype items: list[~digital_ocean_api.models.ProductChargeItem]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
        'items': {'key': 'items', 'type': '[ProductChargeItem]'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        amount: Optional[str] = None,
        items: Optional[List["_models.ProductChargeItem"]] = None,
        **kwargs
    ):
        """
        :keyword name: Description of usage charges.
        :paramtype name: str
        :keyword amount: Total amount charged.
        :paramtype amount: str
        :keyword items: List of amount, and grouped aggregates by resource type.
        :paramtype items: list[~digital_ocean_api.models.ProductChargeItem]
        """
        super(ProductUsageCharges, self).__init__(**kwargs)
        self.name = name
        self.amount = amount
        self.items = items


class InvoiceSummaryProductCharges(ProductUsageCharges):
    """InvoiceSummaryProductCharges.

    :ivar name: Description of usage charges.
    :vartype name: str
    :ivar amount: Total amount charged.
    :vartype amount: str
    :ivar items: List of amount, and grouped aggregates by resource type.
    :vartype items: list[~digital_ocean_api.models.ProductChargeItem]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
        'items': {'key': 'items', 'type': '[ProductChargeItem]'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        amount: Optional[str] = None,
        items: Optional[List["_models.ProductChargeItem"]] = None,
        **kwargs
    ):
        """
        :keyword name: Description of usage charges.
        :paramtype name: str
        :keyword amount: Total amount charged.
        :paramtype amount: str
        :keyword items: List of amount, and grouped aggregates by resource type.
        :paramtype items: list[~digital_ocean_api.models.ProductChargeItem]
        """
        super(InvoiceSummaryProductCharges, self).__init__(name=name, amount=amount, items=items, **kwargs)


class InvoiceSummaryTaxes(SimpleCharge):
    """InvoiceSummaryTaxes.

    :ivar name: Name of the charge.
    :vartype name: str
    :ivar amount: Total amount charged in USD.
    :vartype amount: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        amount: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: Name of the charge.
        :paramtype name: str
        :keyword amount: Total amount charged in USD.
        :paramtype amount: str
        """
        super(InvoiceSummaryTaxes, self).__init__(name=name, amount=amount, **kwargs)


class InvoiceSummaryUserBillingAddress(BillingAddress):
    """InvoiceSummaryUserBillingAddress.

    :ivar address_line1: Street address line 1.
    :vartype address_line1: str
    :ivar address_line2: Street address line 2.
    :vartype address_line2: str
    :ivar city: City.
    :vartype city: str
    :ivar region: Region.
    :vartype region: str
    :ivar postal_code: Postal code.
    :vartype postal_code: str
    :ivar country_iso2_code: Country (ISO2) code.
    :vartype country_iso2_code: str
    :ivar created_at: Timestamp billing address was created.
    :vartype created_at: str
    :ivar updated_at: Timestamp billing address was updated.
    :vartype updated_at: str
    """

    _attribute_map = {
        'address_line1': {'key': 'address_line1', 'type': 'str'},
        'address_line2': {'key': 'address_line2', 'type': 'str'},
        'city': {'key': 'city', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'postal_code': {'key': 'postal_code', 'type': 'str'},
        'country_iso2_code': {'key': 'country_iso2_code', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'str'},
        'updated_at': {'key': 'updated_at', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        address_line1: Optional[str] = None,
        address_line2: Optional[str] = None,
        city: Optional[str] = None,
        region: Optional[str] = None,
        postal_code: Optional[str] = None,
        country_iso2_code: Optional[str] = None,
        created_at: Optional[str] = None,
        updated_at: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address_line1: Street address line 1.
        :paramtype address_line1: str
        :keyword address_line2: Street address line 2.
        :paramtype address_line2: str
        :keyword city: City.
        :paramtype city: str
        :keyword region: Region.
        :paramtype region: str
        :keyword postal_code: Postal code.
        :paramtype postal_code: str
        :keyword country_iso2_code: Country (ISO2) code.
        :paramtype country_iso2_code: str
        :keyword created_at: Timestamp billing address was created.
        :paramtype created_at: str
        :keyword updated_at: Timestamp billing address was updated.
        :paramtype updated_at: str
        """
        super(InvoiceSummaryUserBillingAddress, self).__init__(address_line1=address_line1, address_line2=address_line2, city=city, region=region, postal_code=postal_code, country_iso2_code=country_iso2_code, created_at=created_at, updated_at=updated_at, **kwargs)


class Kernel(msrest.serialization.Model):
    """**Note**\ : All Droplets created after March 2017 use internal kernels by default.
These Droplets will have this attribute set to ``null``.

The current `kernel <https://www.digitalocean.com/docs/droplets/how-to/kernel/>`_
for Droplets with externally managed kernels. This will initially be set to
the kernel of the base image when the Droplet is created.

    :ivar id: A unique number used to identify and reference a specific kernel.
    :vartype id: int
    :ivar name: The display name of the kernel. This is shown in the web UI and is generally a
     descriptive title for the kernel in question.
    :vartype name: str
    :ivar version: A standard kernel version string representing the version, patch, and release
     information.
    :vartype version: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        name: Optional[str] = None,
        version: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: A unique number used to identify and reference a specific kernel.
        :paramtype id: int
        :keyword name: The display name of the kernel. This is shown in the web UI and is generally a
         descriptive title for the kernel in question.
        :paramtype name: str
        :keyword version: A standard kernel version string representing the version, patch, and release
         information.
        :paramtype version: str
        """
        super(Kernel, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.version = version


class KubernetesNodePoolBase(msrest.serialization.Model):
    """KubernetesNodePoolBase.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A unique ID that can be used to identify and reference a specific node pool.
    :vartype id: str
    :ivar name: A human-readable name for the node pool.
    :vartype name: str
    :ivar count: The number of Droplet instances in the node pool.
    :vartype count: int
    :ivar tags: A set of tags. An array containing the tags applied to the node pool. All node
     pools are automatically tagged ``k8s``\ , ``k8s-worker``\ , and ``k8s:$K8S_CLUSTER_ID``.
    :vartype tags: list[str]
    :ivar labels: An object containing a set of Kubernetes labels. The keys and are values are both
     user-defined.
    :vartype labels: any
    :ivar taints: An array of taints to apply to all nodes in a pool. Taints will automatically be
     applied to all existing nodes and any subsequent nodes added to the pool. When a taint is
     removed, it is removed from all nodes in the pool.
    :vartype taints: list[~digital_ocean_api.models.KubernetesNodePoolTaint]
    :ivar auto_scale: A boolean value indicating whether auto-scaling is enabled for this node
     pool.
    :vartype auto_scale: bool
    :ivar min_nodes: The minimum number of nodes that this node pool can be auto-scaled to. The
     value will be ``0`` if ``auto_scale`` is set to ``false``.
    :vartype min_nodes: int
    :ivar max_nodes: The maximum number of nodes that this node pool can be auto-scaled to. The
     value will be ``0`` if ``auto_scale`` is set to ``false``.
    :vartype max_nodes: int
    :ivar nodes: An object specifying the details of a specific worker node in a node pool.
    :vartype nodes: list[~digital_ocean_api.models.Node]
    """

    _validation = {
        'id': {'readonly': True},
        'nodes': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'count': {'key': 'count', 'type': 'int'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'labels': {'key': 'labels', 'type': 'object'},
        'taints': {'key': 'taints', 'type': '[KubernetesNodePoolTaint]'},
        'auto_scale': {'key': 'auto_scale', 'type': 'bool'},
        'min_nodes': {'key': 'min_nodes', 'type': 'int'},
        'max_nodes': {'key': 'max_nodes', 'type': 'int'},
        'nodes': {'key': 'nodes', 'type': '[Node]'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        count: Optional[int] = None,
        tags: Optional[List[str]] = None,
        labels: Optional[Any] = None,
        taints: Optional[List["_models.KubernetesNodePoolTaint"]] = None,
        auto_scale: Optional[bool] = None,
        min_nodes: Optional[int] = None,
        max_nodes: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for the node pool.
        :paramtype name: str
        :keyword count: The number of Droplet instances in the node pool.
        :paramtype count: int
        :keyword tags: A set of tags. An array containing the tags applied to the node pool. All node
         pools are automatically tagged ``k8s``\ , ``k8s-worker``\ , and ``k8s:$K8S_CLUSTER_ID``.
        :paramtype tags: list[str]
        :keyword labels: An object containing a set of Kubernetes labels. The keys and are values are
         both user-defined.
        :paramtype labels: any
        :keyword taints: An array of taints to apply to all nodes in a pool. Taints will automatically
         be applied to all existing nodes and any subsequent nodes added to the pool. When a taint is
         removed, it is removed from all nodes in the pool.
        :paramtype taints: list[~digital_ocean_api.models.KubernetesNodePoolTaint]
        :keyword auto_scale: A boolean value indicating whether auto-scaling is enabled for this node
         pool.
        :paramtype auto_scale: bool
        :keyword min_nodes: The minimum number of nodes that this node pool can be auto-scaled to. The
         value will be ``0`` if ``auto_scale`` is set to ``false``.
        :paramtype min_nodes: int
        :keyword max_nodes: The maximum number of nodes that this node pool can be auto-scaled to. The
         value will be ``0`` if ``auto_scale`` is set to ``false``.
        :paramtype max_nodes: int
        """
        super(KubernetesNodePoolBase, self).__init__(**kwargs)
        self.id = None
        self.name = name
        self.count = count
        self.tags = tags
        self.labels = labels
        self.taints = taints
        self.auto_scale = auto_scale
        self.min_nodes = min_nodes
        self.max_nodes = max_nodes
        self.nodes = None


class KubernetesNodePoolSize(msrest.serialization.Model):
    """KubernetesNodePoolSize.

    :ivar size: The slug identifier for the type of Droplet used as workers in the node pool.
    :vartype size: str
    """

    _attribute_map = {
        'size': {'key': 'size', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        size: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword size: The slug identifier for the type of Droplet used as workers in the node pool.
        :paramtype size: str
        """
        super(KubernetesNodePoolSize, self).__init__(**kwargs)
        self.size = size


class KubernetesNodePool(KubernetesNodePoolSize, KubernetesNodePoolBase):
    """KubernetesNodePool.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A unique ID that can be used to identify and reference a specific node pool.
    :vartype id: str
    :ivar name: A human-readable name for the node pool.
    :vartype name: str
    :ivar count: The number of Droplet instances in the node pool.
    :vartype count: int
    :ivar tags: A set of tags. An array containing the tags applied to the node pool. All node
     pools are automatically tagged ``k8s``\ , ``k8s-worker``\ , and ``k8s:$K8S_CLUSTER_ID``.
    :vartype tags: list[str]
    :ivar labels: An object containing a set of Kubernetes labels. The keys and are values are both
     user-defined.
    :vartype labels: any
    :ivar taints: An array of taints to apply to all nodes in a pool. Taints will automatically be
     applied to all existing nodes and any subsequent nodes added to the pool. When a taint is
     removed, it is removed from all nodes in the pool.
    :vartype taints: list[~digital_ocean_api.models.KubernetesNodePoolTaint]
    :ivar auto_scale: A boolean value indicating whether auto-scaling is enabled for this node
     pool.
    :vartype auto_scale: bool
    :ivar min_nodes: The minimum number of nodes that this node pool can be auto-scaled to. The
     value will be ``0`` if ``auto_scale`` is set to ``false``.
    :vartype min_nodes: int
    :ivar max_nodes: The maximum number of nodes that this node pool can be auto-scaled to. The
     value will be ``0`` if ``auto_scale`` is set to ``false``.
    :vartype max_nodes: int
    :ivar nodes: An object specifying the details of a specific worker node in a node pool.
    :vartype nodes: list[~digital_ocean_api.models.Node]
    :ivar size: The slug identifier for the type of Droplet used as workers in the node pool.
    :vartype size: str
    """

    _validation = {
        'id': {'readonly': True},
        'nodes': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'count': {'key': 'count', 'type': 'int'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'labels': {'key': 'labels', 'type': 'object'},
        'taints': {'key': 'taints', 'type': '[KubernetesNodePoolTaint]'},
        'auto_scale': {'key': 'auto_scale', 'type': 'bool'},
        'min_nodes': {'key': 'min_nodes', 'type': 'int'},
        'max_nodes': {'key': 'max_nodes', 'type': 'int'},
        'nodes': {'key': 'nodes', 'type': '[Node]'},
        'size': {'key': 'size', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        count: Optional[int] = None,
        tags: Optional[List[str]] = None,
        labels: Optional[Any] = None,
        taints: Optional[List["_models.KubernetesNodePoolTaint"]] = None,
        auto_scale: Optional[bool] = None,
        min_nodes: Optional[int] = None,
        max_nodes: Optional[int] = None,
        size: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for the node pool.
        :paramtype name: str
        :keyword count: The number of Droplet instances in the node pool.
        :paramtype count: int
        :keyword tags: A set of tags. An array containing the tags applied to the node pool. All node
         pools are automatically tagged ``k8s``\ , ``k8s-worker``\ , and ``k8s:$K8S_CLUSTER_ID``.
        :paramtype tags: list[str]
        :keyword labels: An object containing a set of Kubernetes labels. The keys and are values are
         both user-defined.
        :paramtype labels: any
        :keyword taints: An array of taints to apply to all nodes in a pool. Taints will automatically
         be applied to all existing nodes and any subsequent nodes added to the pool. When a taint is
         removed, it is removed from all nodes in the pool.
        :paramtype taints: list[~digital_ocean_api.models.KubernetesNodePoolTaint]
        :keyword auto_scale: A boolean value indicating whether auto-scaling is enabled for this node
         pool.
        :paramtype auto_scale: bool
        :keyword min_nodes: The minimum number of nodes that this node pool can be auto-scaled to. The
         value will be ``0`` if ``auto_scale`` is set to ``false``.
        :paramtype min_nodes: int
        :keyword max_nodes: The maximum number of nodes that this node pool can be auto-scaled to. The
         value will be ``0`` if ``auto_scale`` is set to ``false``.
        :paramtype max_nodes: int
        :keyword size: The slug identifier for the type of Droplet used as workers in the node pool.
        :paramtype size: str
        """
        super(KubernetesNodePool, self).__init__(size=size, name=name, count=count, tags=tags, labels=labels, taints=taints, auto_scale=auto_scale, min_nodes=min_nodes, max_nodes=max_nodes, **kwargs)
        self.id = None
        self.name = name
        self.count = count
        self.tags = tags
        self.labels = labels
        self.taints = taints
        self.auto_scale = auto_scale
        self.min_nodes = min_nodes
        self.max_nodes = max_nodes
        self.nodes = None
        self.size = size


class KubernetesNodePoolTaint(msrest.serialization.Model):
    """KubernetesNodePoolTaint.

    :ivar key: An arbitrary string. The ``key`` and ``value`` fields of the ``taint`` object form a
     key-value pair. For example, if the value of the ``key`` field is "special" and the value of
     the ``value`` field is "gpu", the key value pair would be ``special=gpu``.
    :vartype key: str
    :ivar value: An arbitrary string. The ``key`` and ``value`` fields of the ``taint`` object form
     a key-value pair. For example, if the value of the ``key`` field is "special" and the value of
     the ``value`` field is "gpu", the key value pair would be ``special=gpu``.
    :vartype value: str
    :ivar effect: How the node reacts to pods that it won't tolerate. Available effect values are
     ``NoSchedule``\ , ``PreferNoSchedule``\ , and ``NoExecute``. Known values are: "NoSchedule",
     "PreferNoSchedule", "NoExecute".
    :vartype effect: str or ~digital_ocean_api.models.KubernetesNodePoolTaintEffect
    """

    _attribute_map = {
        'key': {'key': 'key', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'effect': {'key': 'effect', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key: Optional[str] = None,
        value: Optional[str] = None,
        effect: Optional[Union[str, "_models.KubernetesNodePoolTaintEffect"]] = None,
        **kwargs
    ):
        """
        :keyword key: An arbitrary string. The ``key`` and ``value`` fields of the ``taint`` object
         form a key-value pair. For example, if the value of the ``key`` field is "special" and the
         value of the ``value`` field is "gpu", the key value pair would be ``special=gpu``.
        :paramtype key: str
        :keyword value: An arbitrary string. The ``key`` and ``value`` fields of the ``taint`` object
         form a key-value pair. For example, if the value of the ``key`` field is "special" and the
         value of the ``value`` field is "gpu", the key value pair would be ``special=gpu``.
        :paramtype value: str
        :keyword effect: How the node reacts to pods that it won't tolerate. Available effect values
         are ``NoSchedule``\ , ``PreferNoSchedule``\ , and ``NoExecute``. Known values are:
         "NoSchedule", "PreferNoSchedule", "NoExecute".
        :paramtype effect: str or ~digital_ocean_api.models.KubernetesNodePoolTaintEffect
        """
        super(KubernetesNodePoolTaint, self).__init__(**kwargs)
        self.key = key
        self.value = value
        self.effect = effect


class KubernetesNodePoolUpdate(KubernetesNodePoolBase):
    """KubernetesNodePoolUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A unique ID that can be used to identify and reference a specific node pool.
    :vartype id: str
    :ivar name: A human-readable name for the node pool.
    :vartype name: str
    :ivar count: The number of Droplet instances in the node pool.
    :vartype count: int
    :ivar tags: A set of tags. An array containing the tags applied to the node pool. All node
     pools are automatically tagged ``k8s``\ , ``k8s-worker``\ , and ``k8s:$K8S_CLUSTER_ID``.
    :vartype tags: list[str]
    :ivar labels: An object containing a set of Kubernetes labels. The keys and are values are both
     user-defined.
    :vartype labels: any
    :ivar taints: An array of taints to apply to all nodes in a pool. Taints will automatically be
     applied to all existing nodes and any subsequent nodes added to the pool. When a taint is
     removed, it is removed from all nodes in the pool.
    :vartype taints: list[~digital_ocean_api.models.KubernetesNodePoolTaint]
    :ivar auto_scale: A boolean value indicating whether auto-scaling is enabled for this node
     pool.
    :vartype auto_scale: bool
    :ivar min_nodes: The minimum number of nodes that this node pool can be auto-scaled to. The
     value will be ``0`` if ``auto_scale`` is set to ``false``.
    :vartype min_nodes: int
    :ivar max_nodes: The maximum number of nodes that this node pool can be auto-scaled to. The
     value will be ``0`` if ``auto_scale`` is set to ``false``.
    :vartype max_nodes: int
    :ivar nodes: An object specifying the details of a specific worker node in a node pool.
    :vartype nodes: list[~digital_ocean_api.models.Node]
    """

    _validation = {
        'id': {'readonly': True},
        'nodes': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'count': {'key': 'count', 'type': 'int'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'labels': {'key': 'labels', 'type': 'object'},
        'taints': {'key': 'taints', 'type': '[KubernetesNodePoolTaint]'},
        'auto_scale': {'key': 'auto_scale', 'type': 'bool'},
        'min_nodes': {'key': 'min_nodes', 'type': 'int'},
        'max_nodes': {'key': 'max_nodes', 'type': 'int'},
        'nodes': {'key': 'nodes', 'type': '[Node]'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        count: Optional[int] = None,
        tags: Optional[List[str]] = None,
        labels: Optional[Any] = None,
        taints: Optional[List["_models.KubernetesNodePoolTaint"]] = None,
        auto_scale: Optional[bool] = None,
        min_nodes: Optional[int] = None,
        max_nodes: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for the node pool.
        :paramtype name: str
        :keyword count: The number of Droplet instances in the node pool.
        :paramtype count: int
        :keyword tags: A set of tags. An array containing the tags applied to the node pool. All node
         pools are automatically tagged ``k8s``\ , ``k8s-worker``\ , and ``k8s:$K8S_CLUSTER_ID``.
        :paramtype tags: list[str]
        :keyword labels: An object containing a set of Kubernetes labels. The keys and are values are
         both user-defined.
        :paramtype labels: any
        :keyword taints: An array of taints to apply to all nodes in a pool. Taints will automatically
         be applied to all existing nodes and any subsequent nodes added to the pool. When a taint is
         removed, it is removed from all nodes in the pool.
        :paramtype taints: list[~digital_ocean_api.models.KubernetesNodePoolTaint]
        :keyword auto_scale: A boolean value indicating whether auto-scaling is enabled for this node
         pool.
        :paramtype auto_scale: bool
        :keyword min_nodes: The minimum number of nodes that this node pool can be auto-scaled to. The
         value will be ``0`` if ``auto_scale`` is set to ``false``.
        :paramtype min_nodes: int
        :keyword max_nodes: The maximum number of nodes that this node pool can be auto-scaled to. The
         value will be ``0`` if ``auto_scale`` is set to ``false``.
        :paramtype max_nodes: int
        """
        super(KubernetesNodePoolUpdate, self).__init__(name=name, count=count, tags=tags, labels=labels, taints=taints, auto_scale=auto_scale, min_nodes=min_nodes, max_nodes=max_nodes, **kwargs)


class KubernetesOptions(msrest.serialization.Model):
    """KubernetesOptions.

    :ivar options:
    :vartype options: ~digital_ocean_api.models.KubernetesOptionsOptions
    """

    _attribute_map = {
        'options': {'key': 'options', 'type': 'KubernetesOptionsOptions'},
    }

    def __init__(
        self,
        *,
        options: Optional["_models.KubernetesOptionsOptions"] = None,
        **kwargs
    ):
        """
        :keyword options:
        :paramtype options: ~digital_ocean_api.models.KubernetesOptionsOptions
        """
        super(KubernetesOptions, self).__init__(**kwargs)
        self.options = options


class KubernetesOptionsOptions(msrest.serialization.Model):
    """KubernetesOptionsOptions.

    :ivar regions:
    :vartype regions: list[~digital_ocean_api.models.KubernetesRegion]
    :ivar versions:
    :vartype versions: list[~digital_ocean_api.models.KubernetesVersion]
    :ivar sizes:
    :vartype sizes: list[~digital_ocean_api.models.KubernetesSize]
    """

    _attribute_map = {
        'regions': {'key': 'regions', 'type': '[KubernetesRegion]'},
        'versions': {'key': 'versions', 'type': '[KubernetesVersion]'},
        'sizes': {'key': 'sizes', 'type': '[KubernetesSize]'},
    }

    def __init__(
        self,
        *,
        regions: Optional[List["_models.KubernetesRegion"]] = None,
        versions: Optional[List["_models.KubernetesVersion"]] = None,
        sizes: Optional[List["_models.KubernetesSize"]] = None,
        **kwargs
    ):
        """
        :keyword regions:
        :paramtype regions: list[~digital_ocean_api.models.KubernetesRegion]
        :keyword versions:
        :paramtype versions: list[~digital_ocean_api.models.KubernetesVersion]
        :keyword sizes:
        :paramtype sizes: list[~digital_ocean_api.models.KubernetesSize]
        """
        super(KubernetesOptionsOptions, self).__init__(**kwargs)
        self.regions = regions
        self.versions = versions
        self.sizes = sizes


class KubernetesRegion(msrest.serialization.Model):
    """KubernetesRegion.

    :ivar name: A DigitalOcean region where Kubernetes is available.
    :vartype name: str
    :ivar slug: The identifier for a region for use when creating a new cluster.
    :vartype slug: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        slug: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: A DigitalOcean region where Kubernetes is available.
        :paramtype name: str
        :keyword slug: The identifier for a region for use when creating a new cluster.
        :paramtype slug: str
        """
        super(KubernetesRegion, self).__init__(**kwargs)
        self.name = name
        self.slug = slug


class KubernetesSize(msrest.serialization.Model):
    """KubernetesSize.

    :ivar name: A Droplet size available for use in a Kubernetes node pool.
    :vartype name: str
    :ivar slug: The identifier for a size for use when creating a new cluster.
    :vartype slug: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        slug: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: A Droplet size available for use in a Kubernetes node pool.
        :paramtype name: str
        :keyword slug: The identifier for a size for use when creating a new cluster.
        :paramtype slug: str
        """
        super(KubernetesSize, self).__init__(**kwargs)
        self.name = name
        self.slug = slug


class KubernetesVersion(msrest.serialization.Model):
    """KubernetesVersion.

    :ivar slug: The slug identifier for an available version of Kubernetes for use when creating or
     updating a cluster. The string contains both the upstream version of Kubernetes as well as the
     DigitalOcean revision.
    :vartype slug: str
    :ivar kubernetes_version: The upstream version string for the version of Kubernetes provided by
     a given slug.
    :vartype kubernetes_version: str
    :ivar supported_features: The features available with the version of Kubernetes provided by a
     given slug.
    :vartype supported_features: list[str]
    """

    _attribute_map = {
        'slug': {'key': 'slug', 'type': 'str'},
        'kubernetes_version': {'key': 'kubernetes_version', 'type': 'str'},
        'supported_features': {'key': 'supported_features', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        slug: Optional[str] = None,
        kubernetes_version: Optional[str] = None,
        supported_features: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword slug: The slug identifier for an available version of Kubernetes for use when creating
         or updating a cluster. The string contains both the upstream version of Kubernetes as well as
         the DigitalOcean revision.
        :paramtype slug: str
        :keyword kubernetes_version: The upstream version string for the version of Kubernetes provided
         by a given slug.
        :paramtype kubernetes_version: str
        :keyword supported_features: The features available with the version of Kubernetes provided by
         a given slug.
        :paramtype supported_features: list[str]
        """
        super(KubernetesVersion, self).__init__(**kwargs)
        self.slug = slug
        self.kubernetes_version = kubernetes_version
        self.supported_features = supported_features


class LoadBalancer(LoadBalancerBase):
    """LoadBalancer.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique ID that can be used to identify and reference a load balancer.
    :vartype id: str
    :ivar name: A human-readable name for a load balancer instance.
    :vartype name: str
    :ivar ip: An attribute containing the public-facing IP address of the load balancer.
    :vartype ip: str
    :ivar size_unit: How many nodes the load balancer contains. Each additional node increases the
     load balancer's ability to manage more connections. Load balancers can be scaled up or down,
     and you can change the number of nodes after creation up to once per hour. This field is
     currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
     load balancers that reside in these regions.
    :vartype size_unit: int
    :ivar size: This field has been replaced by the ``size_unit`` field for all regions except in
     AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having
     a set number of nodes.
    
    
     * ``lb-small`` = 1 node
     * ``lb-medium`` = 3 nodes
     * ``lb-large`` = 6 nodes
    
     You can resize load balancers after creation up to once per hour. You cannot resize a load
     balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
     "lb-large". Default value: "lb-small".
    :vartype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
    :ivar algorithm: This field has been deprecated. You can no longer specify an algorithm for
     load balancers. Known values are: "round_robin", "least_connections". Default value:
     "round_robin".
    :vartype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
    :ivar status: A status string indicating the current state of the load balancer. This can be
     ``new``\ , ``active``\ , or ``errored``. Known values are: "new", "active", "errored".
    :vartype status: str or ~digital_ocean_api.models.LoadBalancerBaseStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the load balancer was created.
    :vartype created_at: ~datetime.datetime
    :ivar forwarding_rules: Required. An array of objects specifying the forwarding rules for a
     load balancer.
    :vartype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
    :ivar health_check: An object specifying health check settings for the load balancer.
    :vartype health_check: ~digital_ocean_api.models.HealthCheck
    :ivar sticky_sessions: An object specifying sticky sessions settings for the load balancer.
    :vartype sticky_sessions: ~digital_ocean_api.models.StickySessions
    :ivar redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
     balancer on port 80 will be redirected to HTTPS on port 443.
    :vartype redirect_http_to_https: bool
    :ivar enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
    :vartype enable_proxy_protocol: bool
    :ivar enable_backend_keepalive: A boolean value indicating whether HTTP keepalive connections
     are maintained to target Droplets.
    :vartype enable_backend_keepalive: bool
    :ivar vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is assigned.
    :vartype vpc_uuid: str
    :ivar disable_lets_encrypt_dns_records: A boolean value indicating whether to disable automatic
     DNS record creation for Let's Encrypt certificates that are added to the load balancer.
    :vartype disable_lets_encrypt_dns_records: bool
    :ivar tag: The name of a Droplet tag corresponding to Droplets assigned to the load balancer.
    :vartype tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'ip': {'readonly': True, 'pattern': r'^$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'},
        'size_unit': {'maximum': 100, 'minimum': 1},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'forwarding_rules': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'ip': {'key': 'ip', 'type': 'str'},
        'size_unit': {'key': 'size_unit', 'type': 'int'},
        'size': {'key': 'size', 'type': 'str'},
        'algorithm': {'key': 'algorithm', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'forwarding_rules': {'key': 'forwarding_rules', 'type': '[ForwardingRule]'},
        'health_check': {'key': 'health_check', 'type': 'HealthCheck'},
        'sticky_sessions': {'key': 'sticky_sessions', 'type': 'StickySessions'},
        'redirect_http_to_https': {'key': 'redirect_http_to_https', 'type': 'bool'},
        'enable_proxy_protocol': {'key': 'enable_proxy_protocol', 'type': 'bool'},
        'enable_backend_keepalive': {'key': 'enable_backend_keepalive', 'type': 'bool'},
        'vpc_uuid': {'key': 'vpc_uuid', 'type': 'str'},
        'disable_lets_encrypt_dns_records': {'key': 'disable_lets_encrypt_dns_records', 'type': 'bool'},
        'tag': {'key': 'tag', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        forwarding_rules: List["_models.ForwardingRule"],
        name: Optional[str] = None,
        size_unit: Optional[int] = 1,
        size: Optional[Union[str, "_models.LoadBalancerBaseSize"]] = "lb-small",
        algorithm: Optional[Union[str, "_models.LoadBalancerBaseAlgorithm"]] = "round_robin",
        health_check: Optional["_models.HealthCheck"] = None,
        sticky_sessions: Optional["_models.StickySessions"] = None,
        redirect_http_to_https: Optional[bool] = False,
        enable_proxy_protocol: Optional[bool] = False,
        enable_backend_keepalive: Optional[bool] = False,
        vpc_uuid: Optional[str] = None,
        disable_lets_encrypt_dns_records: Optional[bool] = False,
        tag: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for a load balancer instance.
        :paramtype name: str
        :keyword size_unit: How many nodes the load balancer contains. Each additional node increases
         the load balancer's ability to manage more connections. Load balancers can be scaled up or
         down, and you can change the number of nodes after creation up to once per hour. This field is
         currently not available in the AMS2, NYC2, or SFO1 regions. Use the ``size`` field to scale
         load balancers that reside in these regions.
        :paramtype size_unit: int
        :keyword size: This field has been replaced by the ``size_unit`` field for all regions except
         in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer
         having a set number of nodes.
        
        
         * ``lb-small`` = 1 node
         * ``lb-medium`` = 3 nodes
         * ``lb-large`` = 6 nodes
        
         You can resize load balancers after creation up to once per hour. You cannot resize a load
         balancer within the first hour of its creation. Known values are: "lb-small", "lb-medium",
         "lb-large". Default value: "lb-small".
        :paramtype size: str or ~digital_ocean_api.models.LoadBalancerBaseSize
        :keyword algorithm: This field has been deprecated. You can no longer specify an algorithm for
         load balancers. Known values are: "round_robin", "least_connections". Default value:
         "round_robin".
        :paramtype algorithm: str or ~digital_ocean_api.models.LoadBalancerBaseAlgorithm
        :keyword forwarding_rules: Required. An array of objects specifying the forwarding rules for a
         load balancer.
        :paramtype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
        :keyword health_check: An object specifying health check settings for the load balancer.
        :paramtype health_check: ~digital_ocean_api.models.HealthCheck
        :keyword sticky_sessions: An object specifying sticky sessions settings for the load balancer.
        :paramtype sticky_sessions: ~digital_ocean_api.models.StickySessions
        :keyword redirect_http_to_https: A boolean value indicating whether HTTP requests to the load
         balancer on port 80 will be redirected to HTTPS on port 443.
        :paramtype redirect_http_to_https: bool
        :keyword enable_proxy_protocol: A boolean value indicating whether PROXY Protocol is in use.
        :paramtype enable_proxy_protocol: bool
        :keyword enable_backend_keepalive: A boolean value indicating whether HTTP keepalive
         connections are maintained to target Droplets.
        :paramtype enable_backend_keepalive: bool
        :keyword vpc_uuid: A string specifying the UUID of the VPC to which the load balancer is
         assigned.
        :paramtype vpc_uuid: str
        :keyword disable_lets_encrypt_dns_records: A boolean value indicating whether to disable
         automatic DNS record creation for Let's Encrypt certificates that are added to the load
         balancer.
        :paramtype disable_lets_encrypt_dns_records: bool
        :keyword tag: The name of a Droplet tag corresponding to Droplets assigned to the load
         balancer.
        :paramtype tag: str
        """
        super(LoadBalancer, self).__init__(name=name, size_unit=size_unit, size=size, algorithm=algorithm, forwarding_rules=forwarding_rules, health_check=health_check, sticky_sessions=sticky_sessions, redirect_http_to_https=redirect_http_to_https, enable_proxy_protocol=enable_proxy_protocol, enable_backend_keepalive=enable_backend_keepalive, vpc_uuid=vpc_uuid, disable_lets_encrypt_dns_records=disable_lets_encrypt_dns_records, **kwargs)
        self.tag = tag


class MaintenancePolicy(msrest.serialization.Model):
    """An object specifying the maintenance window policy for the Kubernetes cluster.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar start_time: The start time in UTC of the maintenance window policy in 24-hour clock
     format / HH:MM notation (e.g., ``15:00``\ ).
    :vartype start_time: str
    :ivar duration: The duration of the maintenance window policy in human-readable format.
    :vartype duration: str
    :ivar day: The day of the maintenance window policy. May be one of ``monday`` through
     ``sunday``\ , or ``any`` to indicate an arbitrary week day. Known values are: "any", "monday",
     "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday".
    :vartype day: str or ~digital_ocean_api.models.MaintenancePolicyDay
    """

    _validation = {
        'duration': {'readonly': True},
    }

    _attribute_map = {
        'start_time': {'key': 'start_time', 'type': 'str'},
        'duration': {'key': 'duration', 'type': 'str'},
        'day': {'key': 'day', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        start_time: Optional[str] = None,
        day: Optional[Union[str, "_models.MaintenancePolicyDay"]] = None,
        **kwargs
    ):
        """
        :keyword start_time: The start time in UTC of the maintenance window policy in 24-hour clock
         format / HH:MM notation (e.g., ``15:00``\ ).
        :paramtype start_time: str
        :keyword day: The day of the maintenance window policy. May be one of ``monday`` through
         ``sunday``\ , or ``any`` to indicate an arbitrary week day. Known values are: "any", "monday",
         "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday".
        :paramtype day: str or ~digital_ocean_api.models.MaintenancePolicyDay
        """
        super(MaintenancePolicy, self).__init__(**kwargs)
        self.start_time = start_time
        self.duration = None
        self.day = day


class MetaMeta(msrest.serialization.Model):
    """Information about the response itself.

    All required parameters must be populated in order to send to Azure.

    :ivar total: Required. Number of objects returned by the request.
    :vartype total: int
    """

    _validation = {
        'total': {'required': True},
    }

    _attribute_map = {
        'total': {'key': 'total', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        total: int,
        **kwargs
    ):
        """
        :keyword total: Required. Number of objects returned by the request.
        :paramtype total: int
        """
        super(MetaMeta, self).__init__(**kwargs)
        self.total = total


class Metrics(msrest.serialization.Model):
    """Metrics.

    All required parameters must be populated in order to send to Azure.

    :ivar data: Required.
    :vartype data: ~digital_ocean_api.models.MetricsData
    :ivar status: Required. Known values are: "success", "error".
    :vartype status: str or ~digital_ocean_api.models.MetricsStatus
    """

    _validation = {
        'data': {'required': True},
        'status': {'required': True},
    }

    _attribute_map = {
        'data': {'key': 'data', 'type': 'MetricsData'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        data: "_models.MetricsData",
        status: Union[str, "_models.MetricsStatus"],
        **kwargs
    ):
        """
        :keyword data: Required.
        :paramtype data: ~digital_ocean_api.models.MetricsData
        :keyword status: Required. Known values are: "success", "error".
        :paramtype status: str or ~digital_ocean_api.models.MetricsStatus
        """
        super(Metrics, self).__init__(**kwargs)
        self.data = data
        self.status = status


class MetricsData(msrest.serialization.Model):
    """MetricsData.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar result: Required. Result of query.
    :vartype result: list[~digital_ocean_api.models.MetricsResult]
    :ivar result_type:  Has constant value: "matrix".
    :vartype result_type: str
    """

    _validation = {
        'result': {'required': True},
        'result_type': {'required': True, 'constant': True},
    }

    _attribute_map = {
        'result': {'key': 'result', 'type': '[MetricsResult]'},
        'result_type': {'key': 'resultType', 'type': 'str'},
    }

    result_type = "matrix"

    def __init__(
        self,
        *,
        result: List["_models.MetricsResult"],
        **kwargs
    ):
        """
        :keyword result: Required. Result of query.
        :paramtype result: list[~digital_ocean_api.models.MetricsResult]
        """
        super(MetricsData, self).__init__(**kwargs)
        self.result = result


class MetricsResult(msrest.serialization.Model):
    """MetricsResult.

    All required parameters must be populated in order to send to Azure.

    :ivar metric: Required. An object containing the metric labels.
    :vartype metric: dict[str, str]
    :ivar values: Required.
    :vartype values: list[list[any]]
    """

    _validation = {
        'metric': {'required': True},
        'values': {'required': True},
    }

    _attribute_map = {
        'metric': {'key': 'metric', 'type': '{str}'},
        'values': {'key': 'values', 'type': '[[object]]'},
    }

    def __init__(
        self,
        *,
        metric: Dict[str, str],
        values: List[List[Any]],
        **kwargs
    ):
        """
        :keyword metric: Required. An object containing the metric labels.
        :paramtype metric: dict[str, str]
        :keyword values: Required.
        :paramtype values: list[list[any]]
        """
        super(MetricsResult, self).__init__(**kwargs)
        self.metric = metric
        self.values = values


class MultipleDropletResponse(msrest.serialization.Model):
    """Multiple Droplet Response.

    All required parameters must be populated in order to send to Azure.

    :ivar droplets: Required.
    :vartype droplets: list[~digital_ocean_api.models.Droplet]
    :ivar links: Required.
    :vartype links:
     ~digital_ocean_api.models.Components10LqvkkResponsesDropletCreateContentApplicationJsonSchemaOneof1PropertiesLinks
    """

    _validation = {
        'droplets': {'required': True},
        'links': {'required': True},
    }

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': '[Droplet]'},
        'links': {'key': 'links', 'type': 'Components10LqvkkResponsesDropletCreateContentApplicationJsonSchemaOneof1PropertiesLinks'},
    }

    def __init__(
        self,
        *,
        droplets: List["_models.Droplet"],
        links: "_models.Components10LqvkkResponsesDropletCreateContentApplicationJsonSchemaOneof1PropertiesLinks",
        **kwargs
    ):
        """
        :keyword droplets: Required.
        :paramtype droplets: list[~digital_ocean_api.models.Droplet]
        :keyword links: Required.
        :paramtype links:
         ~digital_ocean_api.models.Components10LqvkkResponsesDropletCreateContentApplicationJsonSchemaOneof1PropertiesLinks
        """
        super(MultipleDropletResponse, self).__init__(**kwargs)
        self.droplets = droplets
        self.links = links


class Mysql(msrest.serialization.Model):
    """Mysql.

    :ivar sql_mode: Global SQL mode. If empty, uses MySQL server defaults. Must only include
     uppercase alphabetic characters, underscores, and commas.
    :vartype sql_mode: str
    :ivar connect_timeout: The number of seconds that the mysqld server waits for a connect packet
     before responding with bad handshake.
    :vartype connect_timeout: int
    :ivar default_time_zone: Default server time zone, in the form of an offset from UTC (from
     -12:00 to +12:00), a time zone name (EST), or 'SYSTEM' to use the MySQL server default.
    :vartype default_time_zone: str
    :ivar innodb_lock_wait_timeout: The number of seconds that an InnoDB transaction waits for a
     row lock. before giving up.
    :vartype innodb_lock_wait_timeout: int
    :ivar innodb_log_buffer_size: The size of the buffer, in bytes, that InnoDB uses to write to
     the log files. on disk.
    :vartype innodb_log_buffer_size: int
    :ivar innodb_online_alter_log_max_size: The upper limit, in bytes, of the size of the temporary
     log files used during online DDL operations for InnoDB tables.
    :vartype innodb_online_alter_log_max_size: int
    :ivar interactive_timeout: The number of seconds the server waits for activity on an
     interactive connection before closing it.
    :vartype interactive_timeout: int
    :ivar net_read_timeout: The number of seconds to wait for more data from a connection before
     aborting the read.
    :vartype net_read_timeout: int
    :ivar net_write_timeout: The number of seconds to wait for a block to be written to a
     connection before aborting the write.
    :vartype net_write_timeout: int
    :ivar sql_require_primary_key: Require primary key to be defined for new tables or old tables
     modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys
     because various functionality may break if any large table is missing them.
    :vartype sql_require_primary_key: bool
    :ivar wait_timeout: The number of seconds the server waits for activity on a noninteractive
     connection before closing it.
    :vartype wait_timeout: int
    :ivar max_allowed_packet: The size of the largest message, in bytes, that can be received by
     the server. Default is 67108864 (64M).
    :vartype max_allowed_packet: int
    :ivar sort_buffer_size: Sort buffer size, in bytes, for ORDER BY optimization. Default is
     262144 (256K).
    :vartype sort_buffer_size: int
    """

    _validation = {
        'sql_mode': {'max_length': 1024, 'min_length': 0, 'pattern': r'^[A-Z_]*(,[A-Z_]+)*$'},
        'connect_timeout': {'maximum': 3600, 'minimum': 2},
        'default_time_zone': {'max_length': 100, 'min_length': 2},
        'innodb_lock_wait_timeout': {'maximum': 3600, 'minimum': 1},
        'innodb_log_buffer_size': {'maximum': 4294967295, 'minimum': 1048576},
        'innodb_online_alter_log_max_size': {'maximum': 1099511627776, 'minimum': 65536},
        'interactive_timeout': {'maximum': 604800, 'minimum': 30},
        'net_read_timeout': {'maximum': 3600, 'minimum': 1},
        'net_write_timeout': {'maximum': 3600, 'minimum': 1},
        'wait_timeout': {'maximum': 2147483, 'minimum': 1},
        'max_allowed_packet': {'maximum': 1073741824, 'minimum': 102400},
        'sort_buffer_size': {'maximum': 1073741824, 'minimum': 32768},
    }

    _attribute_map = {
        'sql_mode': {'key': 'sql_mode', 'type': 'str'},
        'connect_timeout': {'key': 'connect_timeout', 'type': 'int'},
        'default_time_zone': {'key': 'default_time_zone', 'type': 'str'},
        'innodb_lock_wait_timeout': {'key': 'innodb_lock_wait_timeout', 'type': 'int'},
        'innodb_log_buffer_size': {'key': 'innodb_log_buffer_size', 'type': 'int'},
        'innodb_online_alter_log_max_size': {'key': 'innodb_online_alter_log_max_size', 'type': 'int'},
        'interactive_timeout': {'key': 'interactive_timeout', 'type': 'int'},
        'net_read_timeout': {'key': 'net_read_timeout', 'type': 'int'},
        'net_write_timeout': {'key': 'net_write_timeout', 'type': 'int'},
        'sql_require_primary_key': {'key': 'sql_require_primary_key', 'type': 'bool'},
        'wait_timeout': {'key': 'wait_timeout', 'type': 'int'},
        'max_allowed_packet': {'key': 'max_allowed_packet', 'type': 'int'},
        'sort_buffer_size': {'key': 'sort_buffer_size', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        sql_mode: Optional[str] = None,
        connect_timeout: Optional[int] = None,
        default_time_zone: Optional[str] = None,
        innodb_lock_wait_timeout: Optional[int] = None,
        innodb_log_buffer_size: Optional[int] = None,
        innodb_online_alter_log_max_size: Optional[int] = None,
        interactive_timeout: Optional[int] = None,
        net_read_timeout: Optional[int] = None,
        net_write_timeout: Optional[int] = None,
        sql_require_primary_key: Optional[bool] = None,
        wait_timeout: Optional[int] = None,
        max_allowed_packet: Optional[int] = None,
        sort_buffer_size: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword sql_mode: Global SQL mode. If empty, uses MySQL server defaults. Must only include
         uppercase alphabetic characters, underscores, and commas.
        :paramtype sql_mode: str
        :keyword connect_timeout: The number of seconds that the mysqld server waits for a connect
         packet before responding with bad handshake.
        :paramtype connect_timeout: int
        :keyword default_time_zone: Default server time zone, in the form of an offset from UTC (from
         -12:00 to +12:00), a time zone name (EST), or 'SYSTEM' to use the MySQL server default.
        :paramtype default_time_zone: str
        :keyword innodb_lock_wait_timeout: The number of seconds that an InnoDB transaction waits for a
         row lock. before giving up.
        :paramtype innodb_lock_wait_timeout: int
        :keyword innodb_log_buffer_size: The size of the buffer, in bytes, that InnoDB uses to write to
         the log files. on disk.
        :paramtype innodb_log_buffer_size: int
        :keyword innodb_online_alter_log_max_size: The upper limit, in bytes, of the size of the
         temporary log files used during online DDL operations for InnoDB tables.
        :paramtype innodb_online_alter_log_max_size: int
        :keyword interactive_timeout: The number of seconds the server waits for activity on an
         interactive connection before closing it.
        :paramtype interactive_timeout: int
        :keyword net_read_timeout: The number of seconds to wait for more data from a connection before
         aborting the read.
        :paramtype net_read_timeout: int
        :keyword net_write_timeout: The number of seconds to wait for a block to be written to a
         connection before aborting the write.
        :paramtype net_write_timeout: int
        :keyword sql_require_primary_key: Require primary key to be defined for new tables or old
         tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary
         keys because various functionality may break if any large table is missing them.
        :paramtype sql_require_primary_key: bool
        :keyword wait_timeout: The number of seconds the server waits for activity on a noninteractive
         connection before closing it.
        :paramtype wait_timeout: int
        :keyword max_allowed_packet: The size of the largest message, in bytes, that can be received by
         the server. Default is 67108864 (64M).
        :paramtype max_allowed_packet: int
        :keyword sort_buffer_size: Sort buffer size, in bytes, for ORDER BY optimization. Default is
         262144 (256K).
        :paramtype sort_buffer_size: int
        """
        super(Mysql, self).__init__(**kwargs)
        self.sql_mode = sql_mode
        self.connect_timeout = connect_timeout
        self.default_time_zone = default_time_zone
        self.innodb_lock_wait_timeout = innodb_lock_wait_timeout
        self.innodb_log_buffer_size = innodb_log_buffer_size
        self.innodb_online_alter_log_max_size = innodb_online_alter_log_max_size
        self.interactive_timeout = interactive_timeout
        self.net_read_timeout = net_read_timeout
        self.net_write_timeout = net_write_timeout
        self.sql_require_primary_key = sql_require_primary_key
        self.wait_timeout = wait_timeout
        self.max_allowed_packet = max_allowed_packet
        self.sort_buffer_size = sort_buffer_size


class MysqlSettings(msrest.serialization.Model):
    """MysqlSettings.

    All required parameters must be populated in order to send to Azure.

    :ivar auth_plugin: Required. A string specifying the authentication method to be used for
     connections
     to the MySQL user account. The valid values are ``mysql_native_password``
     or ``caching_sha2_password``. If excluded when creating a new user, the
     default for the version of MySQL in use will be used. As of MySQL 8.0, the
     default is ``caching_sha2_password``. Known values are: "mysql_native_password",
     "caching_sha2_password".
    :vartype auth_plugin: str or ~digital_ocean_api.models.MysqlSettingsAuthPlugin
    """

    _validation = {
        'auth_plugin': {'required': True},
    }

    _attribute_map = {
        'auth_plugin': {'key': 'auth_plugin', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        auth_plugin: Union[str, "_models.MysqlSettingsAuthPlugin"],
        **kwargs
    ):
        """
        :keyword auth_plugin: Required. A string specifying the authentication method to be used for
         connections
         to the MySQL user account. The valid values are ``mysql_native_password``
         or ``caching_sha2_password``. If excluded when creating a new user, the
         default for the version of MySQL in use will be used. As of MySQL 8.0, the
         default is ``caching_sha2_password``. Known values are: "mysql_native_password",
         "caching_sha2_password".
        :paramtype auth_plugin: str or ~digital_ocean_api.models.MysqlSettingsAuthPlugin
        """
        super(MysqlSettings, self).__init__(**kwargs)
        self.auth_plugin = auth_plugin


class NeighborIds(msrest.serialization.Model):
    """NeighborIds.

    :ivar neighbor_ids: An array of arrays. Each array will contain a set of Droplet IDs for
     Droplets that share a physical server.
    :vartype neighbor_ids: list[list[int]]
    """

    _attribute_map = {
        'neighbor_ids': {'key': 'neighbor_ids', 'type': '[[int]]'},
    }

    def __init__(
        self,
        *,
        neighbor_ids: Optional[List[List[int]]] = None,
        **kwargs
    ):
        """
        :keyword neighbor_ids: An array of arrays. Each array will contain a set of Droplet IDs for
         Droplets that share a physical server.
        :paramtype neighbor_ids: list[list[int]]
        """
        super(NeighborIds, self).__init__(**kwargs)
        self.neighbor_ids = neighbor_ids


class NetworkV4(msrest.serialization.Model):
    """NetworkV4.

    :ivar ip_address: The IP address of the IPv4 network interface.
    :vartype ip_address: str
    :ivar netmask: The netmask of the IPv4 network interface.
    :vartype netmask: str
    :ivar gateway: The gateway of the specified IPv4 network interface.
    
     For private interfaces, a gateway is not provided. This is denoted by
     returning ``nil`` as its value.
    :vartype gateway: str
    :ivar type: The type of the IPv4 network interface. Known values are: "public", "private".
    :vartype type: str or ~digital_ocean_api.models.NetworkV4Type
    """

    _attribute_map = {
        'ip_address': {'key': 'ip_address', 'type': 'str'},
        'netmask': {'key': 'netmask', 'type': 'str'},
        'gateway': {'key': 'gateway', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        ip_address: Optional[str] = None,
        netmask: Optional[str] = None,
        gateway: Optional[str] = None,
        type: Optional[Union[str, "_models.NetworkV4Type"]] = None,
        **kwargs
    ):
        """
        :keyword ip_address: The IP address of the IPv4 network interface.
        :paramtype ip_address: str
        :keyword netmask: The netmask of the IPv4 network interface.
        :paramtype netmask: str
        :keyword gateway: The gateway of the specified IPv4 network interface.
        
         For private interfaces, a gateway is not provided. This is denoted by
         returning ``nil`` as its value.
        :paramtype gateway: str
        :keyword type: The type of the IPv4 network interface. Known values are: "public", "private".
        :paramtype type: str or ~digital_ocean_api.models.NetworkV4Type
        """
        super(NetworkV4, self).__init__(**kwargs)
        self.ip_address = ip_address
        self.netmask = netmask
        self.gateway = gateway
        self.type = type


class NetworkV6(msrest.serialization.Model):
    """NetworkV6.

    :ivar ip_address: The IP address of the IPv6 network interface.
    :vartype ip_address: str
    :ivar netmask: The netmask of the IPv6 network interface.
    :vartype netmask: int
    :ivar gateway: The gateway of the specified IPv6 network interface.
    :vartype gateway: str
    :ivar type: The type of the IPv6 network interface.
    
     **Note**\ : IPv6 private  networking is not currently supported. The only acceptable values to
     pass in are None and "public". The default value is None.
    :vartype type: str
    """

    _attribute_map = {
        'ip_address': {'key': 'ip_address', 'type': 'str'},
        'netmask': {'key': 'netmask', 'type': 'int'},
        'gateway': {'key': 'gateway', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        ip_address: Optional[str] = None,
        netmask: Optional[int] = None,
        gateway: Optional[str] = None,
        type: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword ip_address: The IP address of the IPv6 network interface.
        :paramtype ip_address: str
        :keyword netmask: The netmask of the IPv6 network interface.
        :paramtype netmask: int
        :keyword gateway: The gateway of the specified IPv6 network interface.
        :paramtype gateway: str
        :keyword type: The type of the IPv6 network interface.
        
         **Note**\ : IPv6 private  networking is not currently supported. The only acceptable values to
         pass in are None and "public". The default value is None.
        :paramtype type: str
        """
        super(NetworkV6, self).__init__(**kwargs)
        self.ip_address = ip_address
        self.netmask = netmask
        self.gateway = gateway
        self.type = type


class VolumeWriteFileSystemType(msrest.serialization.Model):
    """VolumeWriteFileSystemType.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: NewVolumeExt4, NewVolumeXfs.

    All required parameters must be populated in order to send to Azure.

    :ivar filesystem_type: Required. The name of the filesystem type to be used on the volume. When
     provided, the volume will automatically be formatted to the specified filesystem type.
     Currently, the available options are ``ext4`` and ``xfs``. Pre-formatted volumes are
     automatically mounted when attached to Ubuntu, Debian, Fedora, Fedora Atomic, and CentOS
     Droplets created on or after April 26, 2018. Attaching pre-formatted volumes to other Droplets
     is not recommended.Constant filled by server.
    :vartype filesystem_type: str
    """

    _validation = {
        'filesystem_type': {'required': True},
    }

    _attribute_map = {
        'filesystem_type': {'key': 'filesystem_type', 'type': 'str'},
    }

    _subtype_map = {
        'filesystem_type': {'EXT4': 'NewVolumeExt4', 'XFS': 'NewVolumeXfs'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(VolumeWriteFileSystemType, self).__init__(**kwargs)
        self.filesystem_type = None  # type: Optional[str]


class VolumeSnapshotId(msrest.serialization.Model):
    """VolumeSnapshotId.

    :ivar snapshot_id: The unique identifier for the volume snapshot from which to create the
     volume.
    :vartype snapshot_id: str
    """

    _attribute_map = {
        'snapshot_id': {'key': 'snapshot_id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        snapshot_id: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword snapshot_id: The unique identifier for the volume snapshot from which to create the
         volume.
        :paramtype snapshot_id: str
        """
        super(VolumeSnapshotId, self).__init__(**kwargs)
        self.snapshot_id = snapshot_id


class VolumeBase(msrest.serialization.Model):
    """VolumeBase.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The unique identifier for the block storage volume.
    :vartype id: str
    :ivar droplet_ids: An array containing the IDs of the Droplets the volume is attached to. Note
     that at this time, a volume can only be attached to a single Droplet.
    :vartype droplet_ids: list[int]
    :ivar name: A human-readable name for the block storage volume. Must be lowercase and be
     composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
     with a letter.
    :vartype name: str
    :ivar description: An optional free-form text field to describe a block storage volume.
    :vartype description: str
    :ivar size_gigabytes: The size of the block storage volume in GiB (1024^3).
    :vartype size_gigabytes: int
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the block storage volume was created.
    :vartype created_at: str
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    """

    _validation = {
        'id': {'readonly': True},
        'droplet_ids': {'readonly': True},
        'created_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'int'},
        'created_at': {'key': 'created_at', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        size_gigabytes: Optional[int] = None,
        tags: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for the block storage volume. Must be lowercase and be
         composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
         with a letter.
        :paramtype name: str
        :keyword description: An optional free-form text field to describe a block storage volume.
        :paramtype description: str
        :keyword size_gigabytes: The size of the block storage volume in GiB (1024^3).
        :paramtype size_gigabytes: int
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        """
        super(VolumeBase, self).__init__(**kwargs)
        self.id = None
        self.droplet_ids = None
        self.name = name
        self.description = description
        self.size_gigabytes = size_gigabytes
        self.created_at = None
        self.tags = tags


class NewVolumeExt4(VolumeBase, VolumeSnapshotId, VolumeWriteFileSystemType):
    """NewVolumeExt4.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar filesystem_type: Required. The name of the filesystem type to be used on the volume. When
     provided, the volume will automatically be formatted to the specified filesystem type.
     Currently, the available options are ``ext4`` and ``xfs``. Pre-formatted volumes are
     automatically mounted when attached to Ubuntu, Debian, Fedora, Fedora Atomic, and CentOS
     Droplets created on or after April 26, 2018. Attaching pre-formatted volumes to other Droplets
     is not recommended.Constant filled by server.
    :vartype filesystem_type: str
    :ivar snapshot_id: The unique identifier for the volume snapshot from which to create the
     volume.
    :vartype snapshot_id: str
    :ivar id: The unique identifier for the block storage volume.
    :vartype id: str
    :ivar droplet_ids: An array containing the IDs of the Droplets the volume is attached to. Note
     that at this time, a volume can only be attached to a single Droplet.
    :vartype droplet_ids: list[int]
    :ivar name: A human-readable name for the block storage volume. Must be lowercase and be
     composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
     with a letter.
    :vartype name: str
    :ivar description: An optional free-form text field to describe a block storage volume.
    :vartype description: str
    :ivar size_gigabytes: The size of the block storage volume in GiB (1024^3).
    :vartype size_gigabytes: int
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the block storage volume was created.
    :vartype created_at: str
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    :ivar region: Required. The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar filesystem_label: Any object.
    :vartype filesystem_label: any
    """

    _validation = {
        'filesystem_type': {'required': True},
        'id': {'readonly': True},
        'droplet_ids': {'readonly': True},
        'created_at': {'readonly': True},
        'region': {'required': True},
    }

    _attribute_map = {
        'filesystem_type': {'key': 'filesystem_type', 'type': 'str'},
        'snapshot_id': {'key': 'snapshot_id', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'int'},
        'created_at': {'key': 'created_at', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'region': {'key': 'region', 'type': 'str'},
        'filesystem_label': {'key': 'filesystem_label', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        region: Union[str, "_models.RegionSlug"],
        snapshot_id: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        size_gigabytes: Optional[int] = None,
        tags: Optional[List[str]] = None,
        filesystem_label: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword snapshot_id: The unique identifier for the volume snapshot from which to create the
         volume.
        :paramtype snapshot_id: str
        :keyword name: A human-readable name for the block storage volume. Must be lowercase and be
         composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
         with a letter.
        :paramtype name: str
        :keyword description: An optional free-form text field to describe a block storage volume.
        :paramtype description: str
        :keyword size_gigabytes: The size of the block storage volume in GiB (1024^3).
        :paramtype size_gigabytes: int
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        :keyword region: Required. The slug identifier for the region where the resource will initially
         be  available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1",
         "nyc2", "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword filesystem_label: Any object.
        :paramtype filesystem_label: any
        """
        super(NewVolumeExt4, self).__init__(name=name, description=description, size_gigabytes=size_gigabytes, tags=tags, snapshot_id=snapshot_id, **kwargs)
        self.filesystem_type = 'EXT4'  # type: str
        self.snapshot_id = snapshot_id
        self.region = region
        self.filesystem_label = filesystem_label
        self.id = None
        self.droplet_ids = None
        self.name = name
        self.description = description
        self.size_gigabytes = size_gigabytes
        self.created_at = None
        self.tags = tags


class NewVolumeXfs(VolumeBase, VolumeSnapshotId, VolumeWriteFileSystemType):
    """NewVolumeXfs.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar filesystem_type: Required. The name of the filesystem type to be used on the volume. When
     provided, the volume will automatically be formatted to the specified filesystem type.
     Currently, the available options are ``ext4`` and ``xfs``. Pre-formatted volumes are
     automatically mounted when attached to Ubuntu, Debian, Fedora, Fedora Atomic, and CentOS
     Droplets created on or after April 26, 2018. Attaching pre-formatted volumes to other Droplets
     is not recommended.Constant filled by server.
    :vartype filesystem_type: str
    :ivar snapshot_id: The unique identifier for the volume snapshot from which to create the
     volume.
    :vartype snapshot_id: str
    :ivar id: The unique identifier for the block storage volume.
    :vartype id: str
    :ivar droplet_ids: An array containing the IDs of the Droplets the volume is attached to. Note
     that at this time, a volume can only be attached to a single Droplet.
    :vartype droplet_ids: list[int]
    :ivar name: A human-readable name for the block storage volume. Must be lowercase and be
     composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
     with a letter.
    :vartype name: str
    :ivar description: An optional free-form text field to describe a block storage volume.
    :vartype description: str
    :ivar size_gigabytes: The size of the block storage volume in GiB (1024^3).
    :vartype size_gigabytes: int
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the block storage volume was created.
    :vartype created_at: str
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    :ivar region: Required. The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar filesystem_label: Any object.
    :vartype filesystem_label: any
    """

    _validation = {
        'filesystem_type': {'required': True},
        'id': {'readonly': True},
        'droplet_ids': {'readonly': True},
        'created_at': {'readonly': True},
        'region': {'required': True},
    }

    _attribute_map = {
        'filesystem_type': {'key': 'filesystem_type', 'type': 'str'},
        'snapshot_id': {'key': 'snapshot_id', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'int'},
        'created_at': {'key': 'created_at', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'region': {'key': 'region', 'type': 'str'},
        'filesystem_label': {'key': 'filesystem_label', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        region: Union[str, "_models.RegionSlug"],
        snapshot_id: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        size_gigabytes: Optional[int] = None,
        tags: Optional[List[str]] = None,
        filesystem_label: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword snapshot_id: The unique identifier for the volume snapshot from which to create the
         volume.
        :paramtype snapshot_id: str
        :keyword name: A human-readable name for the block storage volume. Must be lowercase and be
         composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
         with a letter.
        :paramtype name: str
        :keyword description: An optional free-form text field to describe a block storage volume.
        :paramtype description: str
        :keyword size_gigabytes: The size of the block storage volume in GiB (1024^3).
        :paramtype size_gigabytes: int
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        :keyword region: Required. The slug identifier for the region where the resource will initially
         be  available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1",
         "nyc2", "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword filesystem_label: Any object.
        :paramtype filesystem_label: any
        """
        super(NewVolumeXfs, self).__init__(name=name, description=description, size_gigabytes=size_gigabytes, tags=tags, snapshot_id=snapshot_id, **kwargs)
        self.filesystem_type = 'XFS'  # type: str
        self.snapshot_id = snapshot_id
        self.region = region
        self.filesystem_label = filesystem_label
        self.id = None
        self.droplet_ids = None
        self.name = name
        self.description = description
        self.size_gigabytes = size_gigabytes
        self.created_at = None
        self.tags = tags


class Node(msrest.serialization.Model):
    """Node.

    :ivar id: A unique ID that can be used to identify and reference the node.
    :vartype id: str
    :ivar name: An automatically generated, human-readable name for the node.
    :vartype name: str
    :ivar status: An object containing a ``state`` attribute whose value is set to a string
     indicating the current status of the node.
    :vartype status: ~digital_ocean_api.models.NodeStatus
    :ivar droplet_id: The ID of the Droplet used for the worker node.
    :vartype droplet_id: str
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the node was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: A time value given in ISO8601 combined date and time format that represents
     when the node was last updated.
    :vartype updated_at: ~datetime.datetime
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'status': {'key': 'status', 'type': 'NodeStatus'},
        'droplet_id': {'key': 'droplet_id', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        name: Optional[str] = None,
        status: Optional["_models.NodeStatus"] = None,
        droplet_id: Optional[str] = None,
        created_at: Optional[datetime.datetime] = None,
        updated_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword id: A unique ID that can be used to identify and reference the node.
        :paramtype id: str
        :keyword name: An automatically generated, human-readable name for the node.
        :paramtype name: str
        :keyword status: An object containing a ``state`` attribute whose value is set to a string
         indicating the current status of the node.
        :paramtype status: ~digital_ocean_api.models.NodeStatus
        :keyword droplet_id: The ID of the Droplet used for the worker node.
        :paramtype droplet_id: str
        :keyword created_at: A time value given in ISO8601 combined date and time format that
         represents when the node was created.
        :paramtype created_at: ~datetime.datetime
        :keyword updated_at: A time value given in ISO8601 combined date and time format that
         represents when the node was last updated.
        :paramtype updated_at: ~datetime.datetime
        """
        super(Node, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.status = status
        self.droplet_id = droplet_id
        self.created_at = created_at
        self.updated_at = updated_at


class NodeStatus(msrest.serialization.Model):
    """An object containing a ``state`` attribute whose value is set to a string indicating the current status of the node.

    :ivar state: A string indicating the current status of the node. Known values are:
     "provisioning", "running", "draining", "deleting".
    :vartype state: str or ~digital_ocean_api.models.NodeStatusState
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        state: Optional[Union[str, "_models.NodeStatusState"]] = None,
        **kwargs
    ):
        """
        :keyword state: A string indicating the current status of the node. Known values are:
         "provisioning", "running", "draining", "deleting".
        :paramtype state: str or ~digital_ocean_api.models.NodeStatusState
        """
        super(NodeStatus, self).__init__(**kwargs)
        self.state = state


class OneClick(msrest.serialization.Model):
    """OneClick.

    All required parameters must be populated in order to send to Azure.

    :ivar slug: Required. The slug identifier for the 1-Click application.
    :vartype slug: str
    :ivar type: Required. The type of the 1-Click application.
    :vartype type: str
    """

    _validation = {
        'slug': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'slug': {'key': 'slug', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        slug: str,
        type: str,
        **kwargs
    ):
        """
        :keyword slug: Required. The slug identifier for the 1-Click application.
        :paramtype slug: str
        :keyword type: Required. The type of the 1-Click application.
        :paramtype type: str
        """
        super(OneClick, self).__init__(**kwargs)
        self.slug = slug
        self.type = type


class OneClickCreate(msrest.serialization.Model):
    """OneClickCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar addon_slugs: Required. An array of 1-Click Application slugs to be installed to the
     Kubernetes cluster.
    :vartype addon_slugs: list[str]
    :ivar cluster_uuid: Required. A unique ID for the Kubernetes cluster to which the 1-Click
     Applications will be installed.
    :vartype cluster_uuid: str
    """

    _validation = {
        'addon_slugs': {'required': True},
        'cluster_uuid': {'required': True},
    }

    _attribute_map = {
        'addon_slugs': {'key': 'addon_slugs', 'type': '[str]'},
        'cluster_uuid': {'key': 'cluster_uuid', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        addon_slugs: List[str],
        cluster_uuid: str,
        **kwargs
    ):
        """
        :keyword addon_slugs: Required. An array of 1-Click Application slugs to be installed to the
         Kubernetes cluster.
        :paramtype addon_slugs: list[str]
        :keyword cluster_uuid: Required. A unique ID for the Kubernetes cluster to which the 1-Click
         Applications will be installed.
        :paramtype cluster_uuid: str
        """
        super(OneClickCreate, self).__init__(**kwargs)
        self.addon_slugs = addon_slugs
        self.cluster_uuid = cluster_uuid


class OnlineMigration(msrest.serialization.Model):
    """OnlineMigration.

    :ivar id: The ID of the currently running migration.
    :vartype id: str
    :ivar status: The current status of the migration.
    :vartype status: str
    :ivar created_at: The time the migration was initiated, in ISO 8601 format.
    :vartype created_at: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        status: Optional[str] = None,
        created_at: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: The ID of the currently running migration.
        :paramtype id: str
        :keyword status: The current status of the migration.
        :paramtype status: str
        :keyword created_at: The time the migration was initiated, in ISO 8601 format.
        :paramtype created_at: str
        """
        super(OnlineMigration, self).__init__(**kwargs)
        self.id = id
        self.status = status
        self.created_at = created_at


class PageLinks(msrest.serialization.Model):
    """PageLinks.

    :ivar pages:
    :vartype pages: any
    """

    _attribute_map = {
        'pages': {'key': 'pages', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        pages: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword pages:
        :paramtype pages: any
        """
        super(PageLinks, self).__init__(**kwargs)
        self.pages = pages


class Paths10D0V7IV2RegistrySubscriptionPostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths10D0V7IV2RegistrySubscriptionPostRequestbodyContentApplicationJsonSchema.

    :ivar tier_slug: The slug of the subscription tier to sign up for. Known values are: "starter",
     "basic", "professional".
    :vartype tier_slug: str or ~digital_ocean_api.models.PostContentSchemaTierSlug
    """

    _attribute_map = {
        'tier_slug': {'key': 'tier_slug', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        tier_slug: Optional[Union[str, "_models.PostContentSchemaTierSlug"]] = None,
        **kwargs
    ):
        """
        :keyword tier_slug: The slug of the subscription tier to sign up for. Known values are:
         "starter", "basic", "professional".
        :paramtype tier_slug: str or ~digital_ocean_api.models.PostContentSchemaTierSlug
        """
        super(Paths10D0V7IV2RegistrySubscriptionPostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.tier_slug = tier_slug


class Paths10XlofV2FirewallsFirewallIdDropletsDeleteRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths10XlofV2FirewallsFirewallIdDropletsDeleteRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar droplet_ids: Required. An array containing the IDs of the Droplets to be removed from the
     firewall.
    :vartype droplet_ids: list[int]
    """

    _validation = {
        'droplet_ids': {'required': True},
    }

    _attribute_map = {
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
    }

    def __init__(
        self,
        *,
        droplet_ids: List[int],
        **kwargs
    ):
        """
        :keyword droplet_ids: Required. An array containing the IDs of the Droplets to be removed from
         the firewall.
        :paramtype droplet_ids: list[int]
        """
        super(Paths10XlofV2FirewallsFirewallIdDropletsDeleteRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.droplet_ids = droplet_ids


class Paths142ArgoV2DatabasesPostRequestbodyContentApplicationJsonSchemaAllof1(msrest.serialization.Model):
    """Paths142ArgoV2DatabasesPostRequestbodyContentApplicationJsonSchemaAllof1.

    :ivar backup_restore:
    :vartype backup_restore: ~digital_ocean_api.models.DatabaseBackup
    """

    _attribute_map = {
        'backup_restore': {'key': 'backup_restore', 'type': 'DatabaseBackup'},
    }

    def __init__(
        self,
        *,
        backup_restore: Optional["_models.DatabaseBackup"] = None,
        **kwargs
    ):
        """
        :keyword backup_restore:
        :paramtype backup_restore: ~digital_ocean_api.models.DatabaseBackup
        """
        super(Paths142ArgoV2DatabasesPostRequestbodyContentApplicationJsonSchemaAllof1, self).__init__(**kwargs)
        self.backup_restore = backup_restore


class Paths17ErwptV2FirewallsFirewallIdRulesDeleteRequestbodyContentApplicationJsonSchema(FirewallRules):
    """Paths17ErwptV2FirewallsFirewallIdRulesDeleteRequestbodyContentApplicationJsonSchema.

    :ivar inbound_rules:
    :vartype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
    :ivar outbound_rules:
    :vartype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
    """

    _attribute_map = {
        'inbound_rules': {'key': 'inbound_rules', 'type': '[FirewallRulesInboundRulesItem]'},
        'outbound_rules': {'key': 'outbound_rules', 'type': '[FirewallRulesOutboundRulesItem]'},
    }

    def __init__(
        self,
        *,
        inbound_rules: Optional[List["_models.FirewallRulesInboundRulesItem"]] = None,
        outbound_rules: Optional[List["_models.FirewallRulesOutboundRulesItem"]] = None,
        **kwargs
    ):
        """
        :keyword inbound_rules:
        :paramtype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
        :keyword outbound_rules:
        :paramtype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
        """
        super(Paths17ErwptV2FirewallsFirewallIdRulesDeleteRequestbodyContentApplicationJsonSchema, self).__init__(inbound_rules=inbound_rules, outbound_rules=outbound_rules, **kwargs)


class VpcCreate(msrest.serialization.Model):
    """VpcCreate.

    :ivar region: The slug identifier for the region where the VPC will be created.
    :vartype region: str
    :ivar ip_range: The range of IP addresses in the VPC in CIDR notation. Network ranges cannot
     overlap with other networks in the same account and must be in range of private addresses as
     defined in RFC1918. It may not be smaller than ``/28`` nor larger than ``/16``. If no IP range
     is specified, a ``/20`` network range is generated that won't conflict with other VPC networks
     in your account.
    :vartype ip_range: str
    """

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
        'ip_range': {'key': 'ip_range', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        region: Optional[str] = None,
        ip_range: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword region: The slug identifier for the region where the VPC will be created.
        :paramtype region: str
        :keyword ip_range: The range of IP addresses in the VPC in CIDR notation. Network ranges cannot
         overlap with other networks in the same account and must be in range of private addresses as
         defined in RFC1918. It may not be smaller than ``/28`` nor larger than ``/16``. If no IP range
         is specified, a ``/20`` network range is generated that won't conflict with other VPC networks
         in your account.
        :paramtype ip_range: str
        """
        super(VpcCreate, self).__init__(**kwargs)
        self.region = region
        self.ip_range = ip_range


class VpcUpdatable(msrest.serialization.Model):
    """VpcUpdatable.

    :ivar name: The name of the VPC. Must be unique and may only contain alphanumeric characters,
     dashes, and periods.
    :vartype name: str
    :ivar description: A free-form text field for describing the VPC's purpose. It may be a maximum
     of 255 characters.
    :vartype description: str
    """

    _validation = {
        'name': {'pattern': r'^[a-zA-Z0-9\-\.]+$'},
        'description': {'max_length': 255, 'min_length': 0},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of the VPC. Must be unique and may only contain alphanumeric
         characters, dashes, and periods.
        :paramtype name: str
        :keyword description: A free-form text field for describing the VPC's purpose. It may be a
         maximum of 255 characters.
        :paramtype description: str
        """
        super(VpcUpdatable, self).__init__(**kwargs)
        self.name = name
        self.description = description


class Paths1853Y6RV2VpcsPostRequestbodyContentApplicationJsonSchema(VpcUpdatable, VpcCreate):
    """Paths1853Y6RV2VpcsPostRequestbodyContentApplicationJsonSchema.

    :ivar region: The slug identifier for the region where the VPC will be created.
    :vartype region: str
    :ivar ip_range: The range of IP addresses in the VPC in CIDR notation. Network ranges cannot
     overlap with other networks in the same account and must be in range of private addresses as
     defined in RFC1918. It may not be smaller than ``/28`` nor larger than ``/16``. If no IP range
     is specified, a ``/20`` network range is generated that won't conflict with other VPC networks
     in your account.
    :vartype ip_range: str
    :ivar name: The name of the VPC. Must be unique and may only contain alphanumeric characters,
     dashes, and periods.
    :vartype name: str
    :ivar description: A free-form text field for describing the VPC's purpose. It may be a maximum
     of 255 characters.
    :vartype description: str
    """

    _validation = {
        'name': {'pattern': r'^[a-zA-Z0-9\-\.]+$'},
        'description': {'max_length': 255, 'min_length': 0},
    }

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
        'ip_range': {'key': 'ip_range', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        region: Optional[str] = None,
        ip_range: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword region: The slug identifier for the region where the VPC will be created.
        :paramtype region: str
        :keyword ip_range: The range of IP addresses in the VPC in CIDR notation. Network ranges cannot
         overlap with other networks in the same account and must be in range of private addresses as
         defined in RFC1918. It may not be smaller than ``/28`` nor larger than ``/16``. If no IP range
         is specified, a ``/20`` network range is generated that won't conflict with other VPC networks
         in your account.
        :paramtype ip_range: str
        :keyword name: The name of the VPC. Must be unique and may only contain alphanumeric
         characters, dashes, and periods.
        :paramtype name: str
        :keyword description: A free-form text field for describing the VPC's purpose. It may be a
         maximum of 255 characters.
        :paramtype description: str
        """
        super(Paths1853Y6RV2VpcsPostRequestbodyContentApplicationJsonSchema, self).__init__(name=name, description=description, region=region, ip_range=ip_range, **kwargs)
        self.region = region
        self.ip_range = ip_range
        self.name = name
        self.description = description


class Paths18B54PqV2LoadBalancersLbIdForwardingRulesDeleteRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths18B54PqV2LoadBalancersLbIdForwardingRulesDeleteRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar forwarding_rules: Required.
    :vartype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
    """

    _validation = {
        'forwarding_rules': {'required': True},
    }

    _attribute_map = {
        'forwarding_rules': {'key': 'forwarding_rules', 'type': '[ForwardingRule]'},
    }

    def __init__(
        self,
        *,
        forwarding_rules: List["_models.ForwardingRule"],
        **kwargs
    ):
        """
        :keyword forwarding_rules: Required.
        :paramtype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
        """
        super(Paths18B54PqV2LoadBalancersLbIdForwardingRulesDeleteRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.forwarding_rules = forwarding_rules


class Paths1Cfx96QV2KubernetesClustersClusterIdUpgradePostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths1Cfx96QV2KubernetesClustersClusterIdUpgradePostRequestbodyContentApplicationJsonSchema.

    :ivar version: The slug identifier for the version of Kubernetes that the cluster will be
     upgraded to.
    :vartype version: str
    """

    _attribute_map = {
        'version': {'key': 'version', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        version: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword version: The slug identifier for the version of Kubernetes that the cluster will be
         upgraded to.
        :paramtype version: str
        """
        super(Paths1Cfx96QV2KubernetesClustersClusterIdUpgradePostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.version = version


class Paths1Cscq1HV2FirewallsPostRequestbodyContentApplicationJsonSchema(Firewall):
    """Paths1Cscq1HV2FirewallsPostRequestbodyContentApplicationJsonSchema.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar inbound_rules:
    :vartype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
    :ivar outbound_rules:
    :vartype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
    :ivar id: A unique ID that can be used to identify and reference a firewall.
    :vartype id: str
    :ivar status: A status string indicating the current state of the firewall. This can be
     "waiting", "succeeded", or "failed". Known values are: "waiting", "succeeded", "failed".
    :vartype status: str or ~digital_ocean_api.models.FirewallStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the firewall was created.
    :vartype created_at: ~datetime.datetime
    :ivar pending_changes: An array of objects each containing the fields "droplet_id", "removing",
     and "status". It is provided to detail exactly which Droplets are having their security
     policies updated. When empty, all changes have been successfully applied.
    :vartype pending_changes: list[~digital_ocean_api.models.FirewallPendingChangesItem]
    :ivar name: A human-readable name for a firewall. The name must begin with an alphanumeric
     character. Subsequent characters must either be alphanumeric characters, a period (.), or a
     dash (-).
    :vartype name: str
    :ivar droplet_ids: An array containing the IDs of the Droplets assigned to the firewall.
    :vartype droplet_ids: list[int]
    :ivar tags: A set of tags. Any object.
    :vartype tags: any
    """

    _validation = {
        'id': {'readonly': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'pending_changes': {'readonly': True},
        'name': {'pattern': r'^[a-zA-Z0-9][a-zA-Z0-9\.-]+$'},
    }

    _attribute_map = {
        'inbound_rules': {'key': 'inbound_rules', 'type': '[FirewallRulesInboundRulesItem]'},
        'outbound_rules': {'key': 'outbound_rules', 'type': '[FirewallRulesOutboundRulesItem]'},
        'id': {'key': 'id', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'pending_changes': {'key': 'pending_changes', 'type': '[FirewallPendingChangesItem]'},
        'name': {'key': 'name', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        inbound_rules: Optional[List["_models.FirewallRulesInboundRulesItem"]] = None,
        outbound_rules: Optional[List["_models.FirewallRulesOutboundRulesItem"]] = None,
        name: Optional[str] = None,
        droplet_ids: Optional[List[int]] = None,
        tags: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword inbound_rules:
        :paramtype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
        :keyword outbound_rules:
        :paramtype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
        :keyword name: A human-readable name for a firewall. The name must begin with an alphanumeric
         character. Subsequent characters must either be alphanumeric characters, a period (.), or a
         dash (-).
        :paramtype name: str
        :keyword droplet_ids: An array containing the IDs of the Droplets assigned to the firewall.
        :paramtype droplet_ids: list[int]
        :keyword tags: A set of tags. Any object.
        :paramtype tags: any
        """
        super(Paths1Cscq1HV2FirewallsPostRequestbodyContentApplicationJsonSchema, self).__init__(inbound_rules=inbound_rules, outbound_rules=outbound_rules, name=name, droplet_ids=droplet_ids, tags=tags, **kwargs)


class Paths1F4Kj8QV2FirewallsFirewallIdPutRequestbodyContentApplicationJsonSchema(Firewall):
    """Paths1F4Kj8QV2FirewallsFirewallIdPutRequestbodyContentApplicationJsonSchema.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar inbound_rules:
    :vartype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
    :ivar outbound_rules:
    :vartype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
    :ivar id: A unique ID that can be used to identify and reference a firewall.
    :vartype id: str
    :ivar status: A status string indicating the current state of the firewall. This can be
     "waiting", "succeeded", or "failed". Known values are: "waiting", "succeeded", "failed".
    :vartype status: str or ~digital_ocean_api.models.FirewallStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the firewall was created.
    :vartype created_at: ~datetime.datetime
    :ivar pending_changes: An array of objects each containing the fields "droplet_id", "removing",
     and "status". It is provided to detail exactly which Droplets are having their security
     policies updated. When empty, all changes have been successfully applied.
    :vartype pending_changes: list[~digital_ocean_api.models.FirewallPendingChangesItem]
    :ivar name: A human-readable name for a firewall. The name must begin with an alphanumeric
     character. Subsequent characters must either be alphanumeric characters, a period (.), or a
     dash (-).
    :vartype name: str
    :ivar droplet_ids: An array containing the IDs of the Droplets assigned to the firewall.
    :vartype droplet_ids: list[int]
    :ivar tags: A set of tags. Any object.
    :vartype tags: any
    """

    _validation = {
        'id': {'readonly': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'pending_changes': {'readonly': True},
        'name': {'pattern': r'^[a-zA-Z0-9][a-zA-Z0-9\.-]+$'},
    }

    _attribute_map = {
        'inbound_rules': {'key': 'inbound_rules', 'type': '[FirewallRulesInboundRulesItem]'},
        'outbound_rules': {'key': 'outbound_rules', 'type': '[FirewallRulesOutboundRulesItem]'},
        'id': {'key': 'id', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'pending_changes': {'key': 'pending_changes', 'type': '[FirewallPendingChangesItem]'},
        'name': {'key': 'name', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        inbound_rules: Optional[List["_models.FirewallRulesInboundRulesItem"]] = None,
        outbound_rules: Optional[List["_models.FirewallRulesOutboundRulesItem"]] = None,
        name: Optional[str] = None,
        droplet_ids: Optional[List[int]] = None,
        tags: Optional[Any] = None,
        **kwargs
    ):
        """
        :keyword inbound_rules:
        :paramtype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
        :keyword outbound_rules:
        :paramtype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
        :keyword name: A human-readable name for a firewall. The name must begin with an alphanumeric
         character. Subsequent characters must either be alphanumeric characters, a period (.), or a
         dash (-).
        :paramtype name: str
        :keyword droplet_ids: An array containing the IDs of the Droplets assigned to the firewall.
        :paramtype droplet_ids: list[int]
        :keyword tags: A set of tags. Any object.
        :paramtype tags: any
        """
        super(Paths1F4Kj8QV2FirewallsFirewallIdPutRequestbodyContentApplicationJsonSchema, self).__init__(inbound_rules=inbound_rules, outbound_rules=outbound_rules, name=name, droplet_ids=droplet_ids, tags=tags, **kwargs)


class Paths1Fu1VqlV2DatabasesDatabaseClusterUuidMigratePutRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths1Fu1VqlV2DatabasesDatabaseClusterUuidMigratePutRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar region: Required. A slug identifier for the region to which the database cluster will be
     migrated.
    :vartype region: str
    """

    _validation = {
        'region': {'required': True},
    }

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        region: str,
        **kwargs
    ):
        """
        :keyword region: Required. A slug identifier for the region to which the database cluster will
         be migrated.
        :paramtype region: str
        """
        super(Paths1Fu1VqlV2DatabasesDatabaseClusterUuidMigratePutRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.region = region


class Paths1Mxnz3IV2FirewallsFirewallIdDropletsPostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths1Mxnz3IV2FirewallsFirewallIdDropletsPostRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar droplet_ids: Required. An array containing the IDs of the Droplets to be assigned to the
     firewall.
    :vartype droplet_ids: list[int]
    """

    _validation = {
        'droplet_ids': {'required': True},
    }

    _attribute_map = {
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
    }

    def __init__(
        self,
        *,
        droplet_ids: List[int],
        **kwargs
    ):
        """
        :keyword droplet_ids: Required. An array containing the IDs of the Droplets to be assigned to
         the firewall.
        :paramtype droplet_ids: list[int]
        """
        super(Paths1Mxnz3IV2FirewallsFirewallIdDropletsPostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.droplet_ids = droplet_ids


class ProjectBase(msrest.serialization.Model):
    """ProjectBase.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The unique universal identifier of this project.
    :vartype id: str
    :ivar owner_uuid: The unique universal identifier of the project owner.
    :vartype owner_uuid: str
    :ivar owner_id: The integer id of the project owner.
    :vartype owner_id: int
    :ivar name: The human-readable name for the project. The maximum length is 175 characters and
     the name must be unique.
    :vartype name: str
    :ivar description: The description of the project. The maximum length is 255 characters.
    :vartype description: str
    :ivar purpose: The purpose of the project. The maximum length is 255 characters. It can
     have one of the following values:
    
    
     * Just trying out DigitalOcean
     * Class project / Educational purposes
     * Website or blog
     * Web Application
     * Service or API
     * Mobile Application
     * Machine learning / AI / Data processing
     * IoT
     * Operational / Developer tooling
    
     If another value for purpose is specified, for example, "your custom purpose",
     your purpose will be stored as ``Other: your custom purpose``.
    :vartype purpose: str
    :ivar environment: The environment of the project's resources. Known values are: "Development",
     "Staging", "Production".
    :vartype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the project was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: A time value given in ISO8601 combined date and time format that represents
     when the project was updated.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'owner_uuid': {'readonly': True},
        'owner_id': {'readonly': True},
        'name': {'max_length': 175, 'min_length': 0},
        'description': {'max_length': 255, 'min_length': 0},
        'purpose': {'max_length': 255, 'min_length': 0},
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'owner_uuid': {'key': 'owner_uuid', 'type': 'str'},
        'owner_id': {'key': 'owner_id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'purpose': {'key': 'purpose', 'type': 'str'},
        'environment': {'key': 'environment', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        purpose: Optional[str] = None,
        environment: Optional[Union[str, "_models.ProjectBaseEnvironment"]] = None,
        **kwargs
    ):
        """
        :keyword name: The human-readable name for the project. The maximum length is 175 characters
         and the name must be unique.
        :paramtype name: str
        :keyword description: The description of the project. The maximum length is 255 characters.
        :paramtype description: str
        :keyword purpose: The purpose of the project. The maximum length is 255 characters. It can
         have one of the following values:
        
        
         * Just trying out DigitalOcean
         * Class project / Educational purposes
         * Website or blog
         * Web Application
         * Service or API
         * Mobile Application
         * Machine learning / AI / Data processing
         * IoT
         * Operational / Developer tooling
        
         If another value for purpose is specified, for example, "your custom purpose",
         your purpose will be stored as ``Other: your custom purpose``.
        :paramtype purpose: str
        :keyword environment: The environment of the project's resources. Known values are:
         "Development", "Staging", "Production".
        :paramtype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
        """
        super(ProjectBase, self).__init__(**kwargs)
        self.id = None
        self.owner_uuid = None
        self.owner_id = None
        self.name = name
        self.description = description
        self.purpose = purpose
        self.environment = environment
        self.created_at = None
        self.updated_at = None


class Project(ProjectBase):
    """Project.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The unique universal identifier of this project.
    :vartype id: str
    :ivar owner_uuid: The unique universal identifier of the project owner.
    :vartype owner_uuid: str
    :ivar owner_id: The integer id of the project owner.
    :vartype owner_id: int
    :ivar name: The human-readable name for the project. The maximum length is 175 characters and
     the name must be unique.
    :vartype name: str
    :ivar description: The description of the project. The maximum length is 255 characters.
    :vartype description: str
    :ivar purpose: The purpose of the project. The maximum length is 255 characters. It can
     have one of the following values:
    
    
     * Just trying out DigitalOcean
     * Class project / Educational purposes
     * Website or blog
     * Web Application
     * Service or API
     * Mobile Application
     * Machine learning / AI / Data processing
     * IoT
     * Operational / Developer tooling
    
     If another value for purpose is specified, for example, "your custom purpose",
     your purpose will be stored as ``Other: your custom purpose``.
    :vartype purpose: str
    :ivar environment: The environment of the project's resources. Known values are: "Development",
     "Staging", "Production".
    :vartype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the project was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: A time value given in ISO8601 combined date and time format that represents
     when the project was updated.
    :vartype updated_at: ~datetime.datetime
    :ivar is_default: If true, all resources will be added to this project if no project is
     specified.
    :vartype is_default: bool
    """

    _validation = {
        'id': {'readonly': True},
        'owner_uuid': {'readonly': True},
        'owner_id': {'readonly': True},
        'name': {'max_length': 175, 'min_length': 0},
        'description': {'max_length': 255, 'min_length': 0},
        'purpose': {'max_length': 255, 'min_length': 0},
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'owner_uuid': {'key': 'owner_uuid', 'type': 'str'},
        'owner_id': {'key': 'owner_id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'purpose': {'key': 'purpose', 'type': 'str'},
        'environment': {'key': 'environment', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
        'is_default': {'key': 'is_default', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        purpose: Optional[str] = None,
        environment: Optional[Union[str, "_models.ProjectBaseEnvironment"]] = None,
        is_default: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword name: The human-readable name for the project. The maximum length is 175 characters
         and the name must be unique.
        :paramtype name: str
        :keyword description: The description of the project. The maximum length is 255 characters.
        :paramtype description: str
        :keyword purpose: The purpose of the project. The maximum length is 255 characters. It can
         have one of the following values:
        
        
         * Just trying out DigitalOcean
         * Class project / Educational purposes
         * Website or blog
         * Web Application
         * Service or API
         * Mobile Application
         * Machine learning / AI / Data processing
         * IoT
         * Operational / Developer tooling
        
         If another value for purpose is specified, for example, "your custom purpose",
         your purpose will be stored as ``Other: your custom purpose``.
        :paramtype purpose: str
        :keyword environment: The environment of the project's resources. Known values are:
         "Development", "Staging", "Production".
        :paramtype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
        :keyword is_default: If true, all resources will be added to this project if no project is
         specified.
        :paramtype is_default: bool
        """
        super(Project, self).__init__(name=name, description=description, purpose=purpose, environment=environment, **kwargs)
        self.is_default = is_default


class Paths1Ns9Sb3V2ProjectsDefaultPutRequestbodyContentApplicationJsonSchema(Project):
    """Paths1Ns9Sb3V2ProjectsDefaultPutRequestbodyContentApplicationJsonSchema.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The unique universal identifier of this project.
    :vartype id: str
    :ivar owner_uuid: The unique universal identifier of the project owner.
    :vartype owner_uuid: str
    :ivar owner_id: The integer id of the project owner.
    :vartype owner_id: int
    :ivar name: The human-readable name for the project. The maximum length is 175 characters and
     the name must be unique.
    :vartype name: str
    :ivar description: The description of the project. The maximum length is 255 characters.
    :vartype description: str
    :ivar purpose: The purpose of the project. The maximum length is 255 characters. It can
     have one of the following values:
    
    
     * Just trying out DigitalOcean
     * Class project / Educational purposes
     * Website or blog
     * Web Application
     * Service or API
     * Mobile Application
     * Machine learning / AI / Data processing
     * IoT
     * Operational / Developer tooling
    
     If another value for purpose is specified, for example, "your custom purpose",
     your purpose will be stored as ``Other: your custom purpose``.
    :vartype purpose: str
    :ivar environment: The environment of the project's resources. Known values are: "Development",
     "Staging", "Production".
    :vartype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the project was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: A time value given in ISO8601 combined date and time format that represents
     when the project was updated.
    :vartype updated_at: ~datetime.datetime
    :ivar is_default: If true, all resources will be added to this project if no project is
     specified.
    :vartype is_default: bool
    """

    _validation = {
        'id': {'readonly': True},
        'owner_uuid': {'readonly': True},
        'owner_id': {'readonly': True},
        'name': {'max_length': 175, 'min_length': 0},
        'description': {'max_length': 255, 'min_length': 0},
        'purpose': {'max_length': 255, 'min_length': 0},
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'owner_uuid': {'key': 'owner_uuid', 'type': 'str'},
        'owner_id': {'key': 'owner_id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'purpose': {'key': 'purpose', 'type': 'str'},
        'environment': {'key': 'environment', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
        'is_default': {'key': 'is_default', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        purpose: Optional[str] = None,
        environment: Optional[Union[str, "_models.ProjectBaseEnvironment"]] = None,
        is_default: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword name: The human-readable name for the project. The maximum length is 175 characters
         and the name must be unique.
        :paramtype name: str
        :keyword description: The description of the project. The maximum length is 255 characters.
        :paramtype description: str
        :keyword purpose: The purpose of the project. The maximum length is 255 characters. It can
         have one of the following values:
        
        
         * Just trying out DigitalOcean
         * Class project / Educational purposes
         * Website or blog
         * Web Application
         * Service or API
         * Mobile Application
         * Machine learning / AI / Data processing
         * IoT
         * Operational / Developer tooling
        
         If another value for purpose is specified, for example, "your custom purpose",
         your purpose will be stored as ``Other: your custom purpose``.
        :paramtype purpose: str
        :keyword environment: The environment of the project's resources. Known values are:
         "Development", "Staging", "Production".
        :paramtype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
        :keyword is_default: If true, all resources will be added to this project if no project is
         specified.
        :paramtype is_default: bool
        """
        super(Paths1Ns9Sb3V2ProjectsDefaultPutRequestbodyContentApplicationJsonSchema, self).__init__(name=name, description=description, purpose=purpose, environment=environment, is_default=is_default, **kwargs)


class VpcDefault(msrest.serialization.Model):
    """VpcDefault.

    :ivar default: A boolean value indicating whether or not the VPC is the default network for the
     region. All applicable resources are placed into the default VPC network unless otherwise
     specified during their creation. The ``default`` field cannot be unset from ``true``. If you
     want to set a new default VPC network, update the ``default`` field of another VPC network in
     the same region. The previous network's ``default`` field will be set to ``false`` when a new
     default VPC has been defined.
    :vartype default: bool
    """

    _attribute_map = {
        'default': {'key': 'default', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        default: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword default: A boolean value indicating whether or not the VPC is the default network for
         the region. All applicable resources are placed into the default VPC network unless otherwise
         specified during their creation. The ``default`` field cannot be unset from ``true``. If you
         want to set a new default VPC network, update the ``default`` field of another VPC network in
         the same region. The previous network's ``default`` field will be set to ``false`` when a new
         default VPC has been defined.
        :paramtype default: bool
        """
        super(VpcDefault, self).__init__(**kwargs)
        self.default = default


class Paths1NwapakV2VpcsVpcIdPatchRequestbodyContentApplicationJsonSchema(VpcUpdatable, VpcDefault):
    """Paths1NwapakV2VpcsVpcIdPatchRequestbodyContentApplicationJsonSchema.

    :ivar default: A boolean value indicating whether or not the VPC is the default network for the
     region. All applicable resources are placed into the default VPC network unless otherwise
     specified during their creation. The ``default`` field cannot be unset from ``true``. If you
     want to set a new default VPC network, update the ``default`` field of another VPC network in
     the same region. The previous network's ``default`` field will be set to ``false`` when a new
     default VPC has been defined.
    :vartype default: bool
    :ivar name: The name of the VPC. Must be unique and may only contain alphanumeric characters,
     dashes, and periods.
    :vartype name: str
    :ivar description: A free-form text field for describing the VPC's purpose. It may be a maximum
     of 255 characters.
    :vartype description: str
    """

    _validation = {
        'name': {'pattern': r'^[a-zA-Z0-9\-\.]+$'},
        'description': {'max_length': 255, 'min_length': 0},
    }

    _attribute_map = {
        'default': {'key': 'default', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        default: Optional[bool] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword default: A boolean value indicating whether or not the VPC is the default network for
         the region. All applicable resources are placed into the default VPC network unless otherwise
         specified during their creation. The ``default`` field cannot be unset from ``true``. If you
         want to set a new default VPC network, update the ``default`` field of another VPC network in
         the same region. The previous network's ``default`` field will be set to ``false`` when a new
         default VPC has been defined.
        :paramtype default: bool
        :keyword name: The name of the VPC. Must be unique and may only contain alphanumeric
         characters, dashes, and periods.
        :paramtype name: str
        :keyword description: A free-form text field for describing the VPC's purpose. It may be a
         maximum of 255 characters.
        :paramtype description: str
        """
        super(Paths1NwapakV2VpcsVpcIdPatchRequestbodyContentApplicationJsonSchema, self).__init__(name=name, description=description, default=default, **kwargs)
        self.default = default
        self.name = name
        self.description = description


class Paths1QqskwcV2DatabasesDatabaseClusterUuidFirewallPutRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths1QqskwcV2DatabasesDatabaseClusterUuidFirewallPutRequestbodyContentApplicationJsonSchema.

    :ivar rules:
    :vartype rules: list[~digital_ocean_api.models.FirewallRule]
    """

    _attribute_map = {
        'rules': {'key': 'rules', 'type': '[FirewallRule]'},
    }

    def __init__(
        self,
        *,
        rules: Optional[List["_models.FirewallRule"]] = None,
        **kwargs
    ):
        """
        :keyword rules:
        :paramtype rules: list[~digital_ocean_api.models.FirewallRule]
        """
        super(Paths1QqskwcV2DatabasesDatabaseClusterUuidFirewallPutRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.rules = rules


class Paths1RzpbdoV2ProjectsPostRequestbodyContentApplicationJsonSchema(ProjectBase):
    """Paths1RzpbdoV2ProjectsPostRequestbodyContentApplicationJsonSchema.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The unique universal identifier of this project.
    :vartype id: str
    :ivar owner_uuid: The unique universal identifier of the project owner.
    :vartype owner_uuid: str
    :ivar owner_id: The integer id of the project owner.
    :vartype owner_id: int
    :ivar name: The human-readable name for the project. The maximum length is 175 characters and
     the name must be unique.
    :vartype name: str
    :ivar description: The description of the project. The maximum length is 255 characters.
    :vartype description: str
    :ivar purpose: The purpose of the project. The maximum length is 255 characters. It can
     have one of the following values:
    
    
     * Just trying out DigitalOcean
     * Class project / Educational purposes
     * Website or blog
     * Web Application
     * Service or API
     * Mobile Application
     * Machine learning / AI / Data processing
     * IoT
     * Operational / Developer tooling
    
     If another value for purpose is specified, for example, "your custom purpose",
     your purpose will be stored as ``Other: your custom purpose``.
    :vartype purpose: str
    :ivar environment: The environment of the project's resources. Known values are: "Development",
     "Staging", "Production".
    :vartype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the project was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: A time value given in ISO8601 combined date and time format that represents
     when the project was updated.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'owner_uuid': {'readonly': True},
        'owner_id': {'readonly': True},
        'name': {'max_length': 175, 'min_length': 0},
        'description': {'max_length': 255, 'min_length': 0},
        'purpose': {'max_length': 255, 'min_length': 0},
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'owner_uuid': {'key': 'owner_uuid', 'type': 'str'},
        'owner_id': {'key': 'owner_id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'purpose': {'key': 'purpose', 'type': 'str'},
        'environment': {'key': 'environment', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        purpose: Optional[str] = None,
        environment: Optional[Union[str, "_models.ProjectBaseEnvironment"]] = None,
        **kwargs
    ):
        """
        :keyword name: The human-readable name for the project. The maximum length is 175 characters
         and the name must be unique.
        :paramtype name: str
        :keyword description: The description of the project. The maximum length is 255 characters.
        :paramtype description: str
        :keyword purpose: The purpose of the project. The maximum length is 255 characters. It can
         have one of the following values:
        
        
         * Just trying out DigitalOcean
         * Class project / Educational purposes
         * Website or blog
         * Web Application
         * Service or API
         * Mobile Application
         * Machine learning / AI / Data processing
         * IoT
         * Operational / Developer tooling
        
         If another value for purpose is specified, for example, "your custom purpose",
         your purpose will be stored as ``Other: your custom purpose``.
        :paramtype purpose: str
        :keyword environment: The environment of the project's resources. Known values are:
         "Development", "Staging", "Production".
        :paramtype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
        """
        super(Paths1RzpbdoV2ProjectsPostRequestbodyContentApplicationJsonSchema, self).__init__(name=name, description=description, purpose=purpose, environment=environment, **kwargs)


class Paths1Utqt8MV2FirewallsFirewallIdRulesPostRequestbodyContentApplicationJsonSchema(FirewallRules):
    """Paths1Utqt8MV2FirewallsFirewallIdRulesPostRequestbodyContentApplicationJsonSchema.

    :ivar inbound_rules:
    :vartype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
    :ivar outbound_rules:
    :vartype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
    """

    _attribute_map = {
        'inbound_rules': {'key': 'inbound_rules', 'type': '[FirewallRulesInboundRulesItem]'},
        'outbound_rules': {'key': 'outbound_rules', 'type': '[FirewallRulesOutboundRulesItem]'},
    }

    def __init__(
        self,
        *,
        inbound_rules: Optional[List["_models.FirewallRulesInboundRulesItem"]] = None,
        outbound_rules: Optional[List["_models.FirewallRulesOutboundRulesItem"]] = None,
        **kwargs
    ):
        """
        :keyword inbound_rules:
        :paramtype inbound_rules: list[~digital_ocean_api.models.FirewallRulesInboundRulesItem]
        :keyword outbound_rules:
        :paramtype outbound_rules: list[~digital_ocean_api.models.FirewallRulesOutboundRulesItem]
        """
        super(Paths1Utqt8MV2FirewallsFirewallIdRulesPostRequestbodyContentApplicationJsonSchema, self).__init__(inbound_rules=inbound_rules, outbound_rules=outbound_rules, **kwargs)


class Paths1Vjb9PvV2VolumesVolumeIdSnapshotsPostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths1Vjb9PvV2VolumesVolumeIdSnapshotsPostRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A human-readable name for the volume snapshot.
    :vartype name: str
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        name: str,
        tags: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword name: Required. A human-readable name for the volume snapshot.
        :paramtype name: str
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        """
        super(Paths1Vjb9PvV2VolumesVolumeIdSnapshotsPostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.name = name
        self.tags = tags


class Paths1YaighgV2KubernetesClustersClusterIdNodePoolsNodePoolIdRecyclePostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """Paths1YaighgV2KubernetesClustersClusterIdNodePoolsNodePoolIdRecyclePostRequestbodyContentApplicationJsonSchema.

    :ivar nodes:
    :vartype nodes: list[str]
    """

    _attribute_map = {
        'nodes': {'key': 'nodes', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        nodes: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword nodes:
        :paramtype nodes: list[str]
        """
        super(Paths1YaighgV2KubernetesClustersClusterIdNodePoolsNodePoolIdRecyclePostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.nodes = nodes


class PathsDh0O2RV2LoadBalancersLbIdForwardingRulesPostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """PathsDh0O2RV2LoadBalancersLbIdForwardingRulesPostRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar forwarding_rules: Required.
    :vartype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
    """

    _validation = {
        'forwarding_rules': {'required': True},
    }

    _attribute_map = {
        'forwarding_rules': {'key': 'forwarding_rules', 'type': '[ForwardingRule]'},
    }

    def __init__(
        self,
        *,
        forwarding_rules: List["_models.ForwardingRule"],
        **kwargs
    ):
        """
        :keyword forwarding_rules: Required.
        :paramtype forwarding_rules: list[~digital_ocean_api.models.ForwardingRule]
        """
        super(PathsDh0O2RV2LoadBalancersLbIdForwardingRulesPostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.forwarding_rules = forwarding_rules


class PathsEyeh4JV2AccountKeysSshKeyIdentifierPutRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """PathsEyeh4JV2AccountKeysSshKeyIdentifierPutRequestbodyContentApplicationJsonSchema.

    :ivar name: A human-readable display name for this key, used to easily identify the SSH keys
     when they are displayed.
    :vartype name: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable display name for this key, used to easily identify the SSH keys
         when they are displayed.
        :paramtype name: str
        """
        super(PathsEyeh4JV2AccountKeysSshKeyIdentifierPutRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.name = name


class PathsNeiuahV2LoadBalancersLbIdDropletsPostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """PathsNeiuahV2LoadBalancersLbIdDropletsPostRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar droplet_ids: Required. An array containing the IDs of the Droplets assigned to the load
     balancer.
    :vartype droplet_ids: list[int]
    """

    _validation = {
        'droplet_ids': {'required': True},
    }

    _attribute_map = {
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
    }

    def __init__(
        self,
        *,
        droplet_ids: List[int],
        **kwargs
    ):
        """
        :keyword droplet_ids: Required. An array containing the IDs of the Droplets assigned to the
         load balancer.
        :paramtype droplet_ids: list[int]
        """
        super(PathsNeiuahV2LoadBalancersLbIdDropletsPostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.droplet_ids = droplet_ids


class PathsOwv6DtV2LoadBalancersLbIdDropletsDeleteRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """PathsOwv6DtV2LoadBalancersLbIdDropletsDeleteRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar droplet_ids: Required. An array containing the IDs of the Droplets assigned to the load
     balancer.
    :vartype droplet_ids: list[int]
    """

    _validation = {
        'droplet_ids': {'required': True},
    }

    _attribute_map = {
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
    }

    def __init__(
        self,
        *,
        droplet_ids: List[int],
        **kwargs
    ):
        """
        :keyword droplet_ids: Required. An array containing the IDs of the Droplets assigned to the
         load balancer.
        :paramtype droplet_ids: list[int]
        """
        super(PathsOwv6DtV2LoadBalancersLbIdDropletsDeleteRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.droplet_ids = droplet_ids


class PathsQ9AxjgV2DatabasesDatabaseClusterUuidUsersUsernameResetAuthPostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """PathsQ9AxjgV2DatabasesDatabaseClusterUuidUsersUsernameResetAuthPostRequestbodyContentApplicationJsonSchema.

    :ivar mysql_settings:
    :vartype mysql_settings: ~digital_ocean_api.models.MysqlSettings
    """

    _attribute_map = {
        'mysql_settings': {'key': 'mysql_settings', 'type': 'MysqlSettings'},
    }

    def __init__(
        self,
        *,
        mysql_settings: Optional["_models.MysqlSettings"] = None,
        **kwargs
    ):
        """
        :keyword mysql_settings:
        :paramtype mysql_settings: ~digital_ocean_api.models.MysqlSettings
        """
        super(PathsQ9AxjgV2DatabasesDatabaseClusterUuidUsersUsernameResetAuthPostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.mysql_settings = mysql_settings


class PathsQqxkghV2DatabasesDatabaseClusterUuidReplicasPostRequestbodyContentApplicationJsonSchema(DatabaseReplica):
    """PathsQqxkghV2DatabasesDatabaseClusterUuidReplicasPostRequestbodyContentApplicationJsonSchema.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name to give the read-only replicating.
    :vartype name: str
    :ivar region: A slug identifier for the region where the read-only replica will be located. If
     excluded, the replica will be placed in the same region as the cluster.
    :vartype region: str
    :ivar size: A slug identifier representing the size of the node for the read-only replica. The
     size of the replica must be at least as large as the node size for the database cluster from
     which it is replicating.
    :vartype size: str
    :ivar status: A string representing the current status of the database cluster. Known values
     are: "creating", "online", "resizing", "migrating", "forking".
    :vartype status: str or ~digital_ocean_api.models.DatabaseReplicaStatus
    :ivar tags: A set of tags. A flat array of tag names as strings to apply to the read-only
     replica after it is created. Tag names can either be existing or new tags.
    :vartype tags: list[str]
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the database cluster was created.
    :vartype created_at: ~datetime.datetime
    :ivar private_network_uuid: A string specifying the UUID of the VPC to which the read-only
     replica will be assigned. If excluded, the replica will be assigned to your account's default
     VPC for the region.
    :vartype private_network_uuid: str
    :ivar connection:
    :vartype connection: ~digital_ocean_api.models.DatabaseReplicaConnection
    :ivar private_connection:
    :vartype private_connection: ~digital_ocean_api.models.DatabaseReplicaPrivateConnection
    """

    _validation = {
        'name': {'required': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'size': {'key': 'size', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'private_network_uuid': {'key': 'private_network_uuid', 'type': 'str'},
        'connection': {'key': 'connection', 'type': 'DatabaseReplicaConnection'},
        'private_connection': {'key': 'private_connection', 'type': 'DatabaseReplicaPrivateConnection'},
    }

    def __init__(
        self,
        *,
        name: str,
        region: Optional[str] = None,
        size: Optional[str] = None,
        tags: Optional[List[str]] = None,
        private_network_uuid: Optional[str] = None,
        connection: Optional["_models.DatabaseReplicaConnection"] = None,
        private_connection: Optional["_models.DatabaseReplicaPrivateConnection"] = None,
        **kwargs
    ):
        """
        :keyword name: Required. The name to give the read-only replicating.
        :paramtype name: str
        :keyword region: A slug identifier for the region where the read-only replica will be located.
         If excluded, the replica will be placed in the same region as the cluster.
        :paramtype region: str
        :keyword size: A slug identifier representing the size of the node for the read-only replica.
         The size of the replica must be at least as large as the node size for the database cluster
         from which it is replicating.
        :paramtype size: str
        :keyword tags: A set of tags. A flat array of tag names as strings to apply to the read-only
         replica after it is created. Tag names can either be existing or new tags.
        :paramtype tags: list[str]
        :keyword private_network_uuid: A string specifying the UUID of the VPC to which the read-only
         replica will be assigned. If excluded, the replica will be assigned to your account's default
         VPC for the region.
        :paramtype private_network_uuid: str
        :keyword connection:
        :paramtype connection: ~digital_ocean_api.models.DatabaseReplicaConnection
        :keyword private_connection:
        :paramtype private_connection: ~digital_ocean_api.models.DatabaseReplicaPrivateConnection
        """
        super(PathsQqxkghV2DatabasesDatabaseClusterUuidReplicasPostRequestbodyContentApplicationJsonSchema, self).__init__(name=name, region=region, size=size, tags=tags, private_network_uuid=private_network_uuid, connection=connection, private_connection=private_connection, **kwargs)


class PathsU3Jsx2V2FirewallsFirewallIdTagsPostRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """PathsU3Jsx2V2FirewallsFirewallIdTagsPostRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar tags: Required. A set of tags. Any object.
    :vartype tags: any
    """

    _validation = {
        'tags': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        tags: Any,
        **kwargs
    ):
        """
        :keyword tags: Required. A set of tags. Any object.
        :paramtype tags: any
        """
        super(PathsU3Jsx2V2FirewallsFirewallIdTagsPostRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.tags = tags


class PathsUckfxvV2FirewallsFirewallIdTagsDeleteRequestbodyContentApplicationJsonSchema(msrest.serialization.Model):
    """PathsUckfxvV2FirewallsFirewallIdTagsDeleteRequestbodyContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar tags: Required. A set of tags. Any object.
    :vartype tags: any
    """

    _validation = {
        'tags': {'required': True},
    }

    _attribute_map = {
        'tags': {'key': 'tags', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        tags: Any,
        **kwargs
    ):
        """
        :keyword tags: Required. A set of tags. Any object.
        :paramtype tags: any
        """
        super(PathsUckfxvV2FirewallsFirewallIdTagsDeleteRequestbodyContentApplicationJsonSchema, self).__init__(**kwargs)
        self.tags = tags


class PathsUzekzV2ProjectsProjectIdPutRequestbodyContentApplicationJsonSchema(Project):
    """PathsUzekzV2ProjectsProjectIdPutRequestbodyContentApplicationJsonSchema.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The unique universal identifier of this project.
    :vartype id: str
    :ivar owner_uuid: The unique universal identifier of the project owner.
    :vartype owner_uuid: str
    :ivar owner_id: The integer id of the project owner.
    :vartype owner_id: int
    :ivar name: The human-readable name for the project. The maximum length is 175 characters and
     the name must be unique.
    :vartype name: str
    :ivar description: The description of the project. The maximum length is 255 characters.
    :vartype description: str
    :ivar purpose: The purpose of the project. The maximum length is 255 characters. It can
     have one of the following values:
    
    
     * Just trying out DigitalOcean
     * Class project / Educational purposes
     * Website or blog
     * Web Application
     * Service or API
     * Mobile Application
     * Machine learning / AI / Data processing
     * IoT
     * Operational / Developer tooling
    
     If another value for purpose is specified, for example, "your custom purpose",
     your purpose will be stored as ``Other: your custom purpose``.
    :vartype purpose: str
    :ivar environment: The environment of the project's resources. Known values are: "Development",
     "Staging", "Production".
    :vartype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the project was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: A time value given in ISO8601 combined date and time format that represents
     when the project was updated.
    :vartype updated_at: ~datetime.datetime
    :ivar is_default: If true, all resources will be added to this project if no project is
     specified.
    :vartype is_default: bool
    """

    _validation = {
        'id': {'readonly': True},
        'owner_uuid': {'readonly': True},
        'owner_id': {'readonly': True},
        'name': {'max_length': 175, 'min_length': 0},
        'description': {'max_length': 255, 'min_length': 0},
        'purpose': {'max_length': 255, 'min_length': 0},
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'owner_uuid': {'key': 'owner_uuid', 'type': 'str'},
        'owner_id': {'key': 'owner_id', 'type': 'int'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'purpose': {'key': 'purpose', 'type': 'str'},
        'environment': {'key': 'environment', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
        'is_default': {'key': 'is_default', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        purpose: Optional[str] = None,
        environment: Optional[Union[str, "_models.ProjectBaseEnvironment"]] = None,
        is_default: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword name: The human-readable name for the project. The maximum length is 175 characters
         and the name must be unique.
        :paramtype name: str
        :keyword description: The description of the project. The maximum length is 255 characters.
        :paramtype description: str
        :keyword purpose: The purpose of the project. The maximum length is 255 characters. It can
         have one of the following values:
        
        
         * Just trying out DigitalOcean
         * Class project / Educational purposes
         * Website or blog
         * Web Application
         * Service or API
         * Mobile Application
         * Machine learning / AI / Data processing
         * IoT
         * Operational / Developer tooling
        
         If another value for purpose is specified, for example, "your custom purpose",
         your purpose will be stored as ``Other: your custom purpose``.
        :paramtype purpose: str
        :keyword environment: The environment of the project's resources. Known values are:
         "Development", "Staging", "Production".
        :paramtype environment: str or ~digital_ocean_api.models.ProjectBaseEnvironment
        :keyword is_default: If true, all resources will be added to this project if no project is
         specified.
        :paramtype is_default: bool
        """
        super(PathsUzekzV2ProjectsProjectIdPutRequestbodyContentApplicationJsonSchema, self).__init__(name=name, description=description, purpose=purpose, environment=environment, is_default=is_default, **kwargs)


class PathsWzgyvjV2VpcsVpcIdPutRequestbodyContentApplicationJsonSchema(VpcUpdatable, VpcDefault):
    """PathsWzgyvjV2VpcsVpcIdPutRequestbodyContentApplicationJsonSchema.

    :ivar default: A boolean value indicating whether or not the VPC is the default network for the
     region. All applicable resources are placed into the default VPC network unless otherwise
     specified during their creation. The ``default`` field cannot be unset from ``true``. If you
     want to set a new default VPC network, update the ``default`` field of another VPC network in
     the same region. The previous network's ``default`` field will be set to ``false`` when a new
     default VPC has been defined.
    :vartype default: bool
    :ivar name: The name of the VPC. Must be unique and may only contain alphanumeric characters,
     dashes, and periods.
    :vartype name: str
    :ivar description: A free-form text field for describing the VPC's purpose. It may be a maximum
     of 255 characters.
    :vartype description: str
    """

    _validation = {
        'name': {'pattern': r'^[a-zA-Z0-9\-\.]+$'},
        'description': {'max_length': 255, 'min_length': 0},
    }

    _attribute_map = {
        'default': {'key': 'default', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        default: Optional[bool] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword default: A boolean value indicating whether or not the VPC is the default network for
         the region. All applicable resources are placed into the default VPC network unless otherwise
         specified during their creation. The ``default`` field cannot be unset from ``true``. If you
         want to set a new default VPC network, update the ``default`` field of another VPC network in
         the same region. The previous network's ``default`` field will be set to ``false`` when a new
         default VPC has been defined.
        :paramtype default: bool
        :keyword name: The name of the VPC. Must be unique and may only contain alphanumeric
         characters, dashes, and periods.
        :paramtype name: str
        :keyword description: A free-form text field for describing the VPC's purpose. It may be a
         maximum of 255 characters.
        :paramtype description: str
        """
        super(PathsWzgyvjV2VpcsVpcIdPutRequestbodyContentApplicationJsonSchema, self).__init__(name=name, description=description, default=default, **kwargs)
        self.default = default
        self.name = name
        self.description = description


class PathsWztbx8V2DatabasesPostRequestbodyContentApplicationJsonSchema(DatabaseCluster, Paths142ArgoV2DatabasesPostRequestbodyContentApplicationJsonSchemaAllof1):
    """PathsWztbx8V2DatabasesPostRequestbodyContentApplicationJsonSchema.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar backup_restore:
    :vartype backup_restore: ~digital_ocean_api.models.DatabaseBackup
    :ivar id: A unique ID that can be used to identify and reference a database cluster.
    :vartype id: str
    :ivar name: Required. A unique, human-readable name referring to a database cluster.
    :vartype name: str
    :ivar engine: Required. A slug representing the database engine used for the cluster. The
     possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb"
     for MongoDB. Known values are: "pg", "mysql", "redis", "mongodb".
    :vartype engine: str or ~digital_ocean_api.models.DatabaseClusterEngine
    :ivar version: A string representing the version of the database engine in use for the cluster.
    :vartype version: str
    :ivar num_nodes: Required. The number of nodes in the database cluster.
    :vartype num_nodes: int
    :ivar size: Required. The slug identifier representing the size of the nodes in the database
     cluster.
    :vartype size: str
    :ivar region: Required. The slug identifier for the region where the database cluster is
     located.
    :vartype region: str
    :ivar status: A string representing the current status of the database cluster. Known values
     are: "creating", "online", "resizing", "migrating", "forking".
    :vartype status: str or ~digital_ocean_api.models.DatabaseClusterStatus
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the database cluster was created.
    :vartype created_at: ~datetime.datetime
    :ivar private_network_uuid: A string specifying the UUID of the VPC to which the database
     cluster will be assigned. If excluded, the cluster when creating a new database cluster, it
     will be assigned to your account's default VPC for the region.
    :vartype private_network_uuid: str
    :ivar tags: A set of tags. An array of tags that have been applied to the database cluster.
    :vartype tags: list[str]
    :ivar db_names: An array of strings containing the names of databases created in the database
     cluster.
    :vartype db_names: list[str]
    :ivar connection:
    :vartype connection: ~digital_ocean_api.models.DatabaseClusterConnection
    :ivar private_connection:
    :vartype private_connection: ~digital_ocean_api.models.DatabaseClusterPrivateConnection
    :ivar users:
    :vartype users: list[~digital_ocean_api.models.DatabaseUser]
    :ivar maintenance_window:
    :vartype maintenance_window: ~digital_ocean_api.models.DatabaseClusterMaintenanceWindow
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'required': True},
        'engine': {'required': True},
        'num_nodes': {'required': True},
        'size': {'required': True},
        'region': {'required': True},
        'status': {'readonly': True},
        'created_at': {'readonly': True},
        'private_network_uuid': {'pattern': r'^$|[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}'},
        'db_names': {'readonly': True},
        'users': {'readonly': True},
    }

    _attribute_map = {
        'backup_restore': {'key': 'backup_restore', 'type': 'DatabaseBackup'},
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'engine': {'key': 'engine', 'type': 'str'},
        'version': {'key': 'version', 'type': 'str'},
        'num_nodes': {'key': 'num_nodes', 'type': 'int'},
        'size': {'key': 'size', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'private_network_uuid': {'key': 'private_network_uuid', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'db_names': {'key': 'db_names', 'type': '[str]'},
        'connection': {'key': 'connection', 'type': 'DatabaseClusterConnection'},
        'private_connection': {'key': 'private_connection', 'type': 'DatabaseClusterPrivateConnection'},
        'users': {'key': 'users', 'type': '[DatabaseUser]'},
        'maintenance_window': {'key': 'maintenance_window', 'type': 'DatabaseClusterMaintenanceWindow'},
    }

    def __init__(
        self,
        *,
        name: str,
        engine: Union[str, "_models.DatabaseClusterEngine"],
        num_nodes: int,
        size: str,
        region: str,
        backup_restore: Optional["_models.DatabaseBackup"] = None,
        version: Optional[str] = None,
        private_network_uuid: Optional[str] = None,
        tags: Optional[List[str]] = None,
        connection: Optional["_models.DatabaseClusterConnection"] = None,
        private_connection: Optional["_models.DatabaseClusterPrivateConnection"] = None,
        maintenance_window: Optional["_models.DatabaseClusterMaintenanceWindow"] = None,
        **kwargs
    ):
        """
        :keyword backup_restore:
        :paramtype backup_restore: ~digital_ocean_api.models.DatabaseBackup
        :keyword name: Required. A unique, human-readable name referring to a database cluster.
        :paramtype name: str
        :keyword engine: Required. A slug representing the database engine used for the cluster. The
         possible values are: "pg" for PostgreSQL, "mysql" for MySQL, "redis" for Redis, and "mongodb"
         for MongoDB. Known values are: "pg", "mysql", "redis", "mongodb".
        :paramtype engine: str or ~digital_ocean_api.models.DatabaseClusterEngine
        :keyword version: A string representing the version of the database engine in use for the
         cluster.
        :paramtype version: str
        :keyword num_nodes: Required. The number of nodes in the database cluster.
        :paramtype num_nodes: int
        :keyword size: Required. The slug identifier representing the size of the nodes in the database
         cluster.
        :paramtype size: str
        :keyword region: Required. The slug identifier for the region where the database cluster is
         located.
        :paramtype region: str
        :keyword private_network_uuid: A string specifying the UUID of the VPC to which the database
         cluster will be assigned. If excluded, the cluster when creating a new database cluster, it
         will be assigned to your account's default VPC for the region.
        :paramtype private_network_uuid: str
        :keyword tags: A set of tags. An array of tags that have been applied to the database cluster.
        :paramtype tags: list[str]
        :keyword connection:
        :paramtype connection: ~digital_ocean_api.models.DatabaseClusterConnection
        :keyword private_connection:
        :paramtype private_connection: ~digital_ocean_api.models.DatabaseClusterPrivateConnection
        :keyword maintenance_window:
        :paramtype maintenance_window: ~digital_ocean_api.models.DatabaseClusterMaintenanceWindow
        """
        super(PathsWztbx8V2DatabasesPostRequestbodyContentApplicationJsonSchema, self).__init__(name=name, engine=engine, version=version, num_nodes=num_nodes, size=size, region=region, private_network_uuid=private_network_uuid, tags=tags, connection=connection, private_connection=private_connection, maintenance_window=maintenance_window, backup_restore=backup_restore, **kwargs)
        self.backup_restore = backup_restore
        self.id = None
        self.name = name
        self.engine = engine
        self.version = version
        self.num_nodes = num_nodes
        self.size = size
        self.region = region
        self.status = None
        self.created_at = None
        self.private_network_uuid = private_network_uuid
        self.tags = tags
        self.db_names = None
        self.connection = connection
        self.private_connection = private_connection
        self.users = None
        self.maintenance_window = maintenance_window


class Postgres(msrest.serialization.Model):
    """Postgres.

    :ivar autovacuum_freeze_max_age: Specifies the maximum age (in transactions) that a table's
     pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent
     transaction ID wraparound within the table. Note that the system will launch autovacuum
     processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will
     cause the server to be restarted.
    :vartype autovacuum_freeze_max_age: int
    :ivar autovacuum_max_workers: Specifies the maximum number of autovacuum processes (other than
     the autovacuum launcher) that may be running at any one time. The default is three. This
     parameter can only be set at server start.
    :vartype autovacuum_max_workers: int
    :ivar autovacuum_naptime: Specifies the minimum delay, in seconds, between autovacuum runs on
     any given database. The default is one minute.
    :vartype autovacuum_naptime: int
    :ivar autovacuum_vacuum_threshold: Specifies the minimum number of updated or deleted tuples
     needed to trigger a VACUUM in any one table. The default is 50 tuples.
    :vartype autovacuum_vacuum_threshold: int
    :ivar autovacuum_analyze_threshold: Specifies the minimum number of inserted, updated, or
     deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
    :vartype autovacuum_analyze_threshold: int
    :ivar autovacuum_vacuum_scale_factor: Specifies a fraction, in a decimal value, of the table
     size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The
     default is 0.2 (20% of table size).
    :vartype autovacuum_vacuum_scale_factor: float
    :ivar autovacuum_analyze_scale_factor: Specifies a fraction, in a decimal value, of the table
     size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The
     default is 0.2 (20% of table size).
    :vartype autovacuum_analyze_scale_factor: float
    :ivar autovacuum_vacuum_cost_delay: Specifies the cost delay value, in milliseconds, that will
     be used in automatic VACUUM operations. If -1, uses the regular vacuum_cost_delay value, which
     is 20 milliseconds.
    :vartype autovacuum_vacuum_cost_delay: int
    :ivar autovacuum_vacuum_cost_limit: Specifies the cost limit value that will be used in
     automatic VACUUM operations. If -1 is specified (which is the default), the regular
     vacuum_cost_limit value will be used.
    :vartype autovacuum_vacuum_cost_limit: int
    :ivar bgwriter_delay: Specifies the delay, in milliseconds, between activity rounds for the
     background writer. Default is 200 ms.
    :vartype bgwriter_delay: int
    :ivar bgwriter_flush_after: The amount of kilobytes that need to be written by the background
     writer before attempting to force the OS to issue these writes to underlying storage. Specified
     in kilobytes, default is 512.  Setting of 0 disables forced writeback.
    :vartype bgwriter_flush_after: int
    :ivar bgwriter_lru_maxpages: The maximum number of buffers that the background writer can
     write. Setting this to zero disables background writing. Default is 100.
    :vartype bgwriter_lru_maxpages: int
    :ivar bgwriter_lru_multiplier: The average recent need for new buffers is multiplied by
     bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the
     next round, (up to bgwriter_lru_maxpages). 1.0 represents a just in time policy of writing
     exactly the number of buffers predicted to be needed. Larger values provide some cushion
     against spikes in demand, while smaller values intentionally leave writes to be done by server
     processes. The default is 2.0.
    :vartype bgwriter_lru_multiplier: float
    :ivar deadlock_timeout: The amount of time, in milliseconds, to wait on a lock before checking
     to see if there is a deadlock condition.
    :vartype deadlock_timeout: int
    :ivar default_toast_compression: Specifies the default TOAST compression method for values of
     compressible columns (the default is lz4). Known values are: "lz4", "pglz".
    :vartype default_toast_compression: str or
     ~digital_ocean_api.models.PostgresDefaultToastCompression
    :ivar idle_in_transaction_session_timeout: Time out sessions with open transactions after this
     number of milliseconds.
    :vartype idle_in_transaction_session_timeout: int
    :ivar jit: Activates, in a boolean, the system-wide use of Just-in-Time Compilation (JIT).
    :vartype jit: bool
    :ivar log_autovacuum_min_duration: Causes each action executed by autovacuum to be logged if it
     ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum
     actions. Minus-one (the default) disables logging autovacuum actions.
    :vartype log_autovacuum_min_duration: int
    :ivar log_error_verbosity: Controls the amount of detail written in the server log for each
     message that is logged. Known values are: "TERSE", "DEFAULT", "VERBOSE".
    :vartype log_error_verbosity: str or ~digital_ocean_api.models.PostgresLogErrorVerbosity
    :ivar log_line_prefix: Selects one of the available log-formats. These can support popular log
     analyzers like pgbadger, pganalyze, etc. Known values are:
     "pid=%p,user=%u,db=%d,app=%a,client=%h", "%m [%p] %q[user=%u,db=%d,app=%a]", "%t [%p]: [%l-1]
     user=%u,db=%d,app=%a,client=%h".
    :vartype log_line_prefix: str or ~digital_ocean_api.models.PostgresLogLinePrefix
    :ivar log_min_duration_statement: Log statements that take more than this number of
     milliseconds to run. If -1, disables.
    :vartype log_min_duration_statement: int
    :ivar max_files_per_process: PostgreSQL maximum number of files that can be open per process.
    :vartype max_files_per_process: int
    :ivar max_prepared_transactions: PostgreSQL maximum prepared transactions.
    :vartype max_prepared_transactions: int
    :ivar max_pred_locks_per_transaction: PostgreSQL maximum predicate locks per transaction.
    :vartype max_pred_locks_per_transaction: int
    :ivar max_locks_per_transaction: PostgreSQL maximum locks per transaction.
    :vartype max_locks_per_transaction: int
    :ivar max_stack_depth: Maximum depth of the stack in bytes.
    :vartype max_stack_depth: int
    :ivar max_standby_archive_delay: Max standby archive delay in milliseconds.
    :vartype max_standby_archive_delay: int
    :ivar max_standby_streaming_delay: Max standby streaming delay in milliseconds.
    :vartype max_standby_streaming_delay: int
    :ivar max_replication_slots: PostgreSQL maximum replication slots.
    :vartype max_replication_slots: int
    :ivar max_logical_replication_workers: PostgreSQL maximum logical replication workers (taken
     from the pool of max_parallel_workers).
    :vartype max_logical_replication_workers: int
    :ivar max_parallel_workers: Sets the maximum number of workers that the system can support for
     parallel queries.
    :vartype max_parallel_workers: int
    :ivar max_parallel_workers_per_gather: Sets the maximum number of workers that can be started
     by a single Gather or Gather Merge node.
    :vartype max_parallel_workers_per_gather: int
    :ivar max_worker_processes: Sets the maximum number of background processes that the system can
     support.
    :vartype max_worker_processes: int
    :ivar pg_partman_bgw_role: Controls which role to use for pg_partman's scheduled background
     tasks. Must consist of alpha-numeric characters, dots, underscores, or dashes. May not start
     with dash or dot. Maximum of 64 characters.
    :vartype pg_partman_bgw_role: str
    :ivar pg_partman_bgw_interval: Sets the time interval to run pg_partman's scheduled tasks.
    :vartype pg_partman_bgw_interval: int
    :ivar pg_stat_statements_track: Controls which statements are counted. Specify 'top' to track
     top-level statements (those issued directly by clients), 'all' to also track nested statements
     (such as statements invoked within functions), or 'none' to disable statement statistics
     collection. The default value is top. Known values are: "all", "top", "none".
    :vartype pg_stat_statements_track: str or
     ~digital_ocean_api.models.PostgresPgStatStatementsTrack
    :ivar temp_file_limit: PostgreSQL temporary file limit in KiB. If -1, sets to unlimited.
    :vartype temp_file_limit: int
    :ivar timezone: PostgreSQL service timezone.
    :vartype timezone: str
    :ivar track_activity_query_size: Specifies the number of bytes reserved to track the currently
     executing command for each active session.
    :vartype track_activity_query_size: int
    :ivar track_commit_timestamp: Record commit time of transactions. Known values are: "off",
     "on".
    :vartype track_commit_timestamp: str or ~digital_ocean_api.models.PostgresTrackCommitTimestamp
    :ivar track_functions: Enables tracking of function call counts and time used. Known values
     are: "all", "pl", "none".
    :vartype track_functions: str or ~digital_ocean_api.models.PostgresTrackFunctions
    :ivar track_io_timing: Enables timing of database I/O calls. This parameter is off by default,
     because it will repeatedly query the operating system for the current time, which may cause
     significant overhead on some platforms. Known values are: "off", "on".
    :vartype track_io_timing: str or ~digital_ocean_api.models.PostgresTrackIoTiming
    :ivar max_wal_senders: PostgreSQL maximum WAL senders.
    :vartype max_wal_senders: int
    :ivar wal_sender_timeout: Terminate replication connections that are inactive for longer than
     this amount of time, in milliseconds. Setting this value to zero disables the timeout. Must be
     either 0 or between 5000 and 10800000.
    :vartype wal_sender_timeout: int
    :ivar wal_writer_delay: WAL flush interval in milliseconds. Note that setting this value to
     lower than the default 200ms may negatively impact performance.
    :vartype wal_writer_delay: int
    """

    _validation = {
        'autovacuum_freeze_max_age': {'maximum': 1500000000, 'minimum': 200000000},
        'autovacuum_max_workers': {'maximum': 20, 'minimum': 1},
        'autovacuum_naptime': {'maximum': 86400, 'minimum': 0},
        'autovacuum_vacuum_threshold': {'maximum': 2147483647, 'minimum': 0},
        'autovacuum_analyze_threshold': {'maximum': 2147483647, 'minimum': 0},
        'autovacuum_vacuum_scale_factor': {'maximum': 1, 'minimum': 0},
        'autovacuum_analyze_scale_factor': {'maximum': 1, 'minimum': 0},
        'autovacuum_vacuum_cost_delay': {'maximum': 100, 'minimum': -1},
        'autovacuum_vacuum_cost_limit': {'maximum': 10000, 'minimum': -1},
        'bgwriter_delay': {'maximum': 10000, 'minimum': 10},
        'bgwriter_flush_after': {'maximum': 2048, 'minimum': 0},
        'bgwriter_lru_maxpages': {'maximum': 1073741823, 'minimum': 0},
        'bgwriter_lru_multiplier': {'maximum': 10, 'minimum': 0},
        'deadlock_timeout': {'maximum': 1800000, 'minimum': 500},
        'idle_in_transaction_session_timeout': {'maximum': 604800000, 'minimum': 0},
        'log_autovacuum_min_duration': {'maximum': 2147483647, 'minimum': -1},
        'log_min_duration_statement': {'maximum': 86400000, 'minimum': -1},
        'max_files_per_process': {'maximum': 4096, 'minimum': 1000},
        'max_prepared_transactions': {'maximum': 10000, 'minimum': 0},
        'max_pred_locks_per_transaction': {'maximum': 640, 'minimum': 64},
        'max_locks_per_transaction': {'maximum': 6400, 'minimum': 64},
        'max_stack_depth': {'maximum': 6291456, 'minimum': 2097152},
        'max_standby_archive_delay': {'maximum': 43200000, 'minimum': 1},
        'max_standby_streaming_delay': {'maximum': 43200000, 'minimum': 1},
        'max_replication_slots': {'maximum': 64, 'minimum': 8},
        'max_logical_replication_workers': {'maximum': 64, 'minimum': 4},
        'max_parallel_workers': {'maximum': 96, 'minimum': 0},
        'max_parallel_workers_per_gather': {'maximum': 96, 'minimum': 0},
        'max_worker_processes': {'maximum': 96, 'minimum': 8},
        'pg_partman_bgw_role': {'max_length': 64, 'min_length': 0, 'pattern': r'^[_A-Za-z0-9][-._A-Za-z0-9]{0,63}$'},
        'pg_partman_bgw_interval': {'maximum': 604800, 'minimum': 3600},
        'temp_file_limit': {'maximum': 2147483647, 'minimum': -1},
        'timezone': {'max_length': 64, 'min_length': 0},
        'track_activity_query_size': {'maximum': 10240, 'minimum': 1024},
        'max_wal_senders': {'maximum': 64, 'minimum': 8},
        'wal_sender_timeout': {'maximum': 10800000, 'minimum': 0},
        'wal_writer_delay': {'maximum': 200, 'minimum': 10},
    }

    _attribute_map = {
        'autovacuum_freeze_max_age': {'key': 'autovacuum_freeze_max_age', 'type': 'int'},
        'autovacuum_max_workers': {'key': 'autovacuum_max_workers', 'type': 'int'},
        'autovacuum_naptime': {'key': 'autovacuum_naptime', 'type': 'int'},
        'autovacuum_vacuum_threshold': {'key': 'autovacuum_vacuum_threshold', 'type': 'int'},
        'autovacuum_analyze_threshold': {'key': 'autovacuum_analyze_threshold', 'type': 'int'},
        'autovacuum_vacuum_scale_factor': {'key': 'autovacuum_vacuum_scale_factor', 'type': 'float'},
        'autovacuum_analyze_scale_factor': {'key': 'autovacuum_analyze_scale_factor', 'type': 'float'},
        'autovacuum_vacuum_cost_delay': {'key': 'autovacuum_vacuum_cost_delay', 'type': 'int'},
        'autovacuum_vacuum_cost_limit': {'key': 'autovacuum_vacuum_cost_limit', 'type': 'int'},
        'bgwriter_delay': {'key': 'bgwriter_delay', 'type': 'int'},
        'bgwriter_flush_after': {'key': 'bgwriter_flush_after', 'type': 'int'},
        'bgwriter_lru_maxpages': {'key': 'bgwriter_lru_maxpages', 'type': 'int'},
        'bgwriter_lru_multiplier': {'key': 'bgwriter_lru_multiplier', 'type': 'float'},
        'deadlock_timeout': {'key': 'deadlock_timeout', 'type': 'int'},
        'default_toast_compression': {'key': 'default_toast_compression', 'type': 'str'},
        'idle_in_transaction_session_timeout': {'key': 'idle_in_transaction_session_timeout', 'type': 'int'},
        'jit': {'key': 'jit', 'type': 'bool'},
        'log_autovacuum_min_duration': {'key': 'log_autovacuum_min_duration', 'type': 'int'},
        'log_error_verbosity': {'key': 'log_error_verbosity', 'type': 'str'},
        'log_line_prefix': {'key': 'log_line_prefix', 'type': 'str'},
        'log_min_duration_statement': {'key': 'log_min_duration_statement', 'type': 'int'},
        'max_files_per_process': {'key': 'max_files_per_process', 'type': 'int'},
        'max_prepared_transactions': {'key': 'max_prepared_transactions', 'type': 'int'},
        'max_pred_locks_per_transaction': {'key': 'max_pred_locks_per_transaction', 'type': 'int'},
        'max_locks_per_transaction': {'key': 'max_locks_per_transaction', 'type': 'int'},
        'max_stack_depth': {'key': 'max_stack_depth', 'type': 'int'},
        'max_standby_archive_delay': {'key': 'max_standby_archive_delay', 'type': 'int'},
        'max_standby_streaming_delay': {'key': 'max_standby_streaming_delay', 'type': 'int'},
        'max_replication_slots': {'key': 'max_replication_slots', 'type': 'int'},
        'max_logical_replication_workers': {'key': 'max_logical_replication_workers', 'type': 'int'},
        'max_parallel_workers': {'key': 'max_parallel_workers', 'type': 'int'},
        'max_parallel_workers_per_gather': {'key': 'max_parallel_workers_per_gather', 'type': 'int'},
        'max_worker_processes': {'key': 'max_worker_processes', 'type': 'int'},
        'pg_partman_bgw_role': {'key': 'pg_partman_bgw\\.role', 'type': 'str'},
        'pg_partman_bgw_interval': {'key': 'pg_partman_bgw\\.interval', 'type': 'int'},
        'pg_stat_statements_track': {'key': 'pg_stat_statements\\.track', 'type': 'str'},
        'temp_file_limit': {'key': 'temp_file_limit', 'type': 'int'},
        'timezone': {'key': 'timezone', 'type': 'str'},
        'track_activity_query_size': {'key': 'track_activity_query_size', 'type': 'int'},
        'track_commit_timestamp': {'key': 'track_commit_timestamp', 'type': 'str'},
        'track_functions': {'key': 'track_functions', 'type': 'str'},
        'track_io_timing': {'key': 'track_io_timing', 'type': 'str'},
        'max_wal_senders': {'key': 'max_wal_senders', 'type': 'int'},
        'wal_sender_timeout': {'key': 'wal_sender_timeout', 'type': 'int'},
        'wal_writer_delay': {'key': 'wal_writer_delay', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        autovacuum_freeze_max_age: Optional[int] = None,
        autovacuum_max_workers: Optional[int] = None,
        autovacuum_naptime: Optional[int] = None,
        autovacuum_vacuum_threshold: Optional[int] = None,
        autovacuum_analyze_threshold: Optional[int] = None,
        autovacuum_vacuum_scale_factor: Optional[float] = None,
        autovacuum_analyze_scale_factor: Optional[float] = None,
        autovacuum_vacuum_cost_delay: Optional[int] = None,
        autovacuum_vacuum_cost_limit: Optional[int] = None,
        bgwriter_delay: Optional[int] = None,
        bgwriter_flush_after: Optional[int] = None,
        bgwriter_lru_maxpages: Optional[int] = None,
        bgwriter_lru_multiplier: Optional[float] = None,
        deadlock_timeout: Optional[int] = None,
        default_toast_compression: Optional[Union[str, "_models.PostgresDefaultToastCompression"]] = None,
        idle_in_transaction_session_timeout: Optional[int] = None,
        jit: Optional[bool] = None,
        log_autovacuum_min_duration: Optional[int] = None,
        log_error_verbosity: Optional[Union[str, "_models.PostgresLogErrorVerbosity"]] = None,
        log_line_prefix: Optional[Union[str, "_models.PostgresLogLinePrefix"]] = None,
        log_min_duration_statement: Optional[int] = None,
        max_files_per_process: Optional[int] = None,
        max_prepared_transactions: Optional[int] = None,
        max_pred_locks_per_transaction: Optional[int] = None,
        max_locks_per_transaction: Optional[int] = None,
        max_stack_depth: Optional[int] = None,
        max_standby_archive_delay: Optional[int] = None,
        max_standby_streaming_delay: Optional[int] = None,
        max_replication_slots: Optional[int] = None,
        max_logical_replication_workers: Optional[int] = None,
        max_parallel_workers: Optional[int] = None,
        max_parallel_workers_per_gather: Optional[int] = None,
        max_worker_processes: Optional[int] = None,
        pg_partman_bgw_role: Optional[str] = None,
        pg_partman_bgw_interval: Optional[int] = None,
        pg_stat_statements_track: Optional[Union[str, "_models.PostgresPgStatStatementsTrack"]] = None,
        temp_file_limit: Optional[int] = None,
        timezone: Optional[str] = None,
        track_activity_query_size: Optional[int] = None,
        track_commit_timestamp: Optional[Union[str, "_models.PostgresTrackCommitTimestamp"]] = None,
        track_functions: Optional[Union[str, "_models.PostgresTrackFunctions"]] = None,
        track_io_timing: Optional[Union[str, "_models.PostgresTrackIoTiming"]] = None,
        max_wal_senders: Optional[int] = None,
        wal_sender_timeout: Optional[int] = None,
        wal_writer_delay: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword autovacuum_freeze_max_age: Specifies the maximum age (in transactions) that a table's
         pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent
         transaction ID wraparound within the table. Note that the system will launch autovacuum
         processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will
         cause the server to be restarted.
        :paramtype autovacuum_freeze_max_age: int
        :keyword autovacuum_max_workers: Specifies the maximum number of autovacuum processes (other
         than the autovacuum launcher) that may be running at any one time. The default is three. This
         parameter can only be set at server start.
        :paramtype autovacuum_max_workers: int
        :keyword autovacuum_naptime: Specifies the minimum delay, in seconds, between autovacuum runs
         on any given database. The default is one minute.
        :paramtype autovacuum_naptime: int
        :keyword autovacuum_vacuum_threshold: Specifies the minimum number of updated or deleted tuples
         needed to trigger a VACUUM in any one table. The default is 50 tuples.
        :paramtype autovacuum_vacuum_threshold: int
        :keyword autovacuum_analyze_threshold: Specifies the minimum number of inserted, updated, or
         deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        :paramtype autovacuum_analyze_threshold: int
        :keyword autovacuum_vacuum_scale_factor: Specifies a fraction, in a decimal value, of the table
         size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The
         default is 0.2 (20% of table size).
        :paramtype autovacuum_vacuum_scale_factor: float
        :keyword autovacuum_analyze_scale_factor: Specifies a fraction, in a decimal value, of the
         table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE.
         The default is 0.2 (20% of table size).
        :paramtype autovacuum_analyze_scale_factor: float
        :keyword autovacuum_vacuum_cost_delay: Specifies the cost delay value, in milliseconds, that
         will be used in automatic VACUUM operations. If -1, uses the regular vacuum_cost_delay value,
         which is 20 milliseconds.
        :paramtype autovacuum_vacuum_cost_delay: int
        :keyword autovacuum_vacuum_cost_limit: Specifies the cost limit value that will be used in
         automatic VACUUM operations. If -1 is specified (which is the default), the regular
         vacuum_cost_limit value will be used.
        :paramtype autovacuum_vacuum_cost_limit: int
        :keyword bgwriter_delay: Specifies the delay, in milliseconds, between activity rounds for the
         background writer. Default is 200 ms.
        :paramtype bgwriter_delay: int
        :keyword bgwriter_flush_after: The amount of kilobytes that need to be written by the
         background writer before attempting to force the OS to issue these writes to underlying
         storage. Specified in kilobytes, default is 512.  Setting of 0 disables forced writeback.
        :paramtype bgwriter_flush_after: int
        :keyword bgwriter_lru_maxpages: The maximum number of buffers that the background writer can
         write. Setting this to zero disables background writing. Default is 100.
        :paramtype bgwriter_lru_maxpages: int
        :keyword bgwriter_lru_multiplier: The average recent need for new buffers is multiplied by
         bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the
         next round, (up to bgwriter_lru_maxpages). 1.0 represents a just in time policy of writing
         exactly the number of buffers predicted to be needed. Larger values provide some cushion
         against spikes in demand, while smaller values intentionally leave writes to be done by server
         processes. The default is 2.0.
        :paramtype bgwriter_lru_multiplier: float
        :keyword deadlock_timeout: The amount of time, in milliseconds, to wait on a lock before
         checking to see if there is a deadlock condition.
        :paramtype deadlock_timeout: int
        :keyword default_toast_compression: Specifies the default TOAST compression method for values
         of compressible columns (the default is lz4). Known values are: "lz4", "pglz".
        :paramtype default_toast_compression: str or
         ~digital_ocean_api.models.PostgresDefaultToastCompression
        :keyword idle_in_transaction_session_timeout: Time out sessions with open transactions after
         this number of milliseconds.
        :paramtype idle_in_transaction_session_timeout: int
        :keyword jit: Activates, in a boolean, the system-wide use of Just-in-Time Compilation (JIT).
        :paramtype jit: bool
        :keyword log_autovacuum_min_duration: Causes each action executed by autovacuum to be logged if
         it ran for at least the specified number of milliseconds. Setting this to zero logs all
         autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        :paramtype log_autovacuum_min_duration: int
        :keyword log_error_verbosity: Controls the amount of detail written in the server log for each
         message that is logged. Known values are: "TERSE", "DEFAULT", "VERBOSE".
        :paramtype log_error_verbosity: str or ~digital_ocean_api.models.PostgresLogErrorVerbosity
        :keyword log_line_prefix: Selects one of the available log-formats. These can support popular
         log analyzers like pgbadger, pganalyze, etc. Known values are:
         "pid=%p,user=%u,db=%d,app=%a,client=%h", "%m [%p] %q[user=%u,db=%d,app=%a]", "%t [%p]: [%l-1]
         user=%u,db=%d,app=%a,client=%h".
        :paramtype log_line_prefix: str or ~digital_ocean_api.models.PostgresLogLinePrefix
        :keyword log_min_duration_statement: Log statements that take more than this number of
         milliseconds to run. If -1, disables.
        :paramtype log_min_duration_statement: int
        :keyword max_files_per_process: PostgreSQL maximum number of files that can be open per
         process.
        :paramtype max_files_per_process: int
        :keyword max_prepared_transactions: PostgreSQL maximum prepared transactions.
        :paramtype max_prepared_transactions: int
        :keyword max_pred_locks_per_transaction: PostgreSQL maximum predicate locks per transaction.
        :paramtype max_pred_locks_per_transaction: int
        :keyword max_locks_per_transaction: PostgreSQL maximum locks per transaction.
        :paramtype max_locks_per_transaction: int
        :keyword max_stack_depth: Maximum depth of the stack in bytes.
        :paramtype max_stack_depth: int
        :keyword max_standby_archive_delay: Max standby archive delay in milliseconds.
        :paramtype max_standby_archive_delay: int
        :keyword max_standby_streaming_delay: Max standby streaming delay in milliseconds.
        :paramtype max_standby_streaming_delay: int
        :keyword max_replication_slots: PostgreSQL maximum replication slots.
        :paramtype max_replication_slots: int
        :keyword max_logical_replication_workers: PostgreSQL maximum logical replication workers (taken
         from the pool of max_parallel_workers).
        :paramtype max_logical_replication_workers: int
        :keyword max_parallel_workers: Sets the maximum number of workers that the system can support
         for parallel queries.
        :paramtype max_parallel_workers: int
        :keyword max_parallel_workers_per_gather: Sets the maximum number of workers that can be
         started by a single Gather or Gather Merge node.
        :paramtype max_parallel_workers_per_gather: int
        :keyword max_worker_processes: Sets the maximum number of background processes that the system
         can support.
        :paramtype max_worker_processes: int
        :keyword pg_partman_bgw_role: Controls which role to use for pg_partman's scheduled background
         tasks. Must consist of alpha-numeric characters, dots, underscores, or dashes. May not start
         with dash or dot. Maximum of 64 characters.
        :paramtype pg_partman_bgw_role: str
        :keyword pg_partman_bgw_interval: Sets the time interval to run pg_partman's scheduled tasks.
        :paramtype pg_partman_bgw_interval: int
        :keyword pg_stat_statements_track: Controls which statements are counted. Specify 'top' to
         track top-level statements (those issued directly by clients), 'all' to also track nested
         statements (such as statements invoked within functions), or 'none' to disable statement
         statistics collection. The default value is top. Known values are: "all", "top", "none".
        :paramtype pg_stat_statements_track: str or
         ~digital_ocean_api.models.PostgresPgStatStatementsTrack
        :keyword temp_file_limit: PostgreSQL temporary file limit in KiB. If -1, sets to unlimited.
        :paramtype temp_file_limit: int
        :keyword timezone: PostgreSQL service timezone.
        :paramtype timezone: str
        :keyword track_activity_query_size: Specifies the number of bytes reserved to track the
         currently executing command for each active session.
        :paramtype track_activity_query_size: int
        :keyword track_commit_timestamp: Record commit time of transactions. Known values are: "off",
         "on".
        :paramtype track_commit_timestamp: str or
         ~digital_ocean_api.models.PostgresTrackCommitTimestamp
        :keyword track_functions: Enables tracking of function call counts and time used. Known values
         are: "all", "pl", "none".
        :paramtype track_functions: str or ~digital_ocean_api.models.PostgresTrackFunctions
        :keyword track_io_timing: Enables timing of database I/O calls. This parameter is off by
         default, because it will repeatedly query the operating system for the current time, which may
         cause significant overhead on some platforms. Known values are: "off", "on".
        :paramtype track_io_timing: str or ~digital_ocean_api.models.PostgresTrackIoTiming
        :keyword max_wal_senders: PostgreSQL maximum WAL senders.
        :paramtype max_wal_senders: int
        :keyword wal_sender_timeout: Terminate replication connections that are inactive for longer
         than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
         Must be either 0 or between 5000 and 10800000.
        :paramtype wal_sender_timeout: int
        :keyword wal_writer_delay: WAL flush interval in milliseconds. Note that setting this value to
         lower than the default 200ms may negatively impact performance.
        :paramtype wal_writer_delay: int
        """
        super(Postgres, self).__init__(**kwargs)
        self.autovacuum_freeze_max_age = autovacuum_freeze_max_age
        self.autovacuum_max_workers = autovacuum_max_workers
        self.autovacuum_naptime = autovacuum_naptime
        self.autovacuum_vacuum_threshold = autovacuum_vacuum_threshold
        self.autovacuum_analyze_threshold = autovacuum_analyze_threshold
        self.autovacuum_vacuum_scale_factor = autovacuum_vacuum_scale_factor
        self.autovacuum_analyze_scale_factor = autovacuum_analyze_scale_factor
        self.autovacuum_vacuum_cost_delay = autovacuum_vacuum_cost_delay
        self.autovacuum_vacuum_cost_limit = autovacuum_vacuum_cost_limit
        self.bgwriter_delay = bgwriter_delay
        self.bgwriter_flush_after = bgwriter_flush_after
        self.bgwriter_lru_maxpages = bgwriter_lru_maxpages
        self.bgwriter_lru_multiplier = bgwriter_lru_multiplier
        self.deadlock_timeout = deadlock_timeout
        self.default_toast_compression = default_toast_compression
        self.idle_in_transaction_session_timeout = idle_in_transaction_session_timeout
        self.jit = jit
        self.log_autovacuum_min_duration = log_autovacuum_min_duration
        self.log_error_verbosity = log_error_verbosity
        self.log_line_prefix = log_line_prefix
        self.log_min_duration_statement = log_min_duration_statement
        self.max_files_per_process = max_files_per_process
        self.max_prepared_transactions = max_prepared_transactions
        self.max_pred_locks_per_transaction = max_pred_locks_per_transaction
        self.max_locks_per_transaction = max_locks_per_transaction
        self.max_stack_depth = max_stack_depth
        self.max_standby_archive_delay = max_standby_archive_delay
        self.max_standby_streaming_delay = max_standby_streaming_delay
        self.max_replication_slots = max_replication_slots
        self.max_logical_replication_workers = max_logical_replication_workers
        self.max_parallel_workers = max_parallel_workers
        self.max_parallel_workers_per_gather = max_parallel_workers_per_gather
        self.max_worker_processes = max_worker_processes
        self.pg_partman_bgw_role = pg_partman_bgw_role
        self.pg_partman_bgw_interval = pg_partman_bgw_interval
        self.pg_stat_statements_track = pg_stat_statements_track
        self.temp_file_limit = temp_file_limit
        self.timezone = timezone
        self.track_activity_query_size = track_activity_query_size
        self.track_commit_timestamp = track_commit_timestamp
        self.track_functions = track_functions
        self.track_io_timing = track_io_timing
        self.max_wal_senders = max_wal_senders
        self.wal_sender_timeout = wal_sender_timeout
        self.wal_writer_delay = wal_writer_delay


class ProductChargeItem(msrest.serialization.Model):
    """ProductChargeItem.

    :ivar amount: Amount of the charge.
    :vartype amount: str
    :ivar name: Description of the charge.
    :vartype name: str
    :ivar count: Number of times the charge was applied.
    :vartype count: str
    """

    _attribute_map = {
        'amount': {'key': 'amount', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'count': {'key': 'count', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        amount: Optional[str] = None,
        name: Optional[str] = None,
        count: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword amount: Amount of the charge.
        :paramtype amount: str
        :keyword name: Description of the charge.
        :paramtype name: str
        :keyword count: Number of times the charge was applied.
        :paramtype count: str
        """
        super(ProductChargeItem, self).__init__(**kwargs)
        self.amount = amount
        self.name = name
        self.count = count


class ProjectAssignment(msrest.serialization.Model):
    """ProjectAssignment.

    :ivar resources: A list of uniform resource names (URNs) to be added to a project.
    :vartype resources: list[str]
    """

    _attribute_map = {
        'resources': {'key': 'resources', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        resources: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword resources: A list of uniform resource names (URNs) to be added to a project.
        :paramtype resources: list[str]
        """
        super(ProjectAssignment, self).__init__(**kwargs)
        self.resources = resources


class PurgeCache(msrest.serialization.Model):
    """PurgeCache.

    All required parameters must be populated in order to send to Azure.

    :ivar files: Required. An array of strings containing the path to the content to be purged from
     the CDN cache.
    :vartype files: list[str]
    """

    _validation = {
        'files': {'required': True},
    }

    _attribute_map = {
        'files': {'key': 'files', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        files: List[str],
        **kwargs
    ):
        """
        :keyword files: Required. An array of strings containing the path to the content to be purged
         from the CDN cache.
        :paramtype files: list[str]
        """
        super(PurgeCache, self).__init__(**kwargs)
        self.files = files


class Redis(msrest.serialization.Model):
    """Redis.

    :ivar redis_maxmemory_policy: Known values are: "noeviction", "allkeys-lru", "volatile-lru",
     "allkeys-random", "volatile-random", "volatile-ttl", "volatile-lfu", "allkeys-lfu". Default
     value: "noeviction".
    :vartype redis_maxmemory_policy: str or ~digital_ocean_api.models.RedisMaxmemoryPolicy
    :ivar redis_pubsub_client_output_buffer_limit: Set output buffer limit for pub / sub clients in
     MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the
     limit, be mindful of the available memory in the selected service plan.
    :vartype redis_pubsub_client_output_buffer_limit: int
    :ivar redis_number_of_databases: Set number of redis databases. Changing this will cause a
     restart of redis service.
    :vartype redis_number_of_databases: int
    :ivar redis_io_threads: Redis IO thread count.
    :vartype redis_io_threads: int
    :ivar redis_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu
     maxmemory-policies.
    :vartype redis_lfu_log_factor: int
    :ivar redis_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes.
    :vartype redis_lfu_decay_time: int
    :ivar redis_ssl: Require SSL to access Redis.
    :vartype redis_ssl: bool
    :ivar redis_timeout: Redis idle connection timeout in seconds.
    :vartype redis_timeout: int
    :ivar redis_notify_keyspace_events: Set notify-keyspace-events option.
    :vartype redis_notify_keyspace_events: str
    :ivar redis_persistence: When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any
     key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When
     persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if
     service is restarted for any reason, or if service is powered off. Also service can't be
     forked. Known values are: "off", "rdb".
    :vartype redis_persistence: str or ~digital_ocean_api.models.RedisPersistence
    :ivar redis_acl_channels_default: Determines default pub/sub channels' ACL for new users if ACL
     is not supplied. When this option is not defined, all_channels is assumed to keep backward
     compatibility. This option doesn't affect Redis configuration acl-pubsub-default. Known values
     are: "allchannels", "resetchannels".
    :vartype redis_acl_channels_default: str or ~digital_ocean_api.models.RedisAclChannelsDefault
    """

    _validation = {
        'redis_pubsub_client_output_buffer_limit': {'maximum': 512, 'minimum': 32},
        'redis_number_of_databases': {'maximum': 128, 'minimum': 1},
        'redis_io_threads': {'maximum': 32, 'minimum': 1},
        'redis_lfu_log_factor': {'maximum': 100, 'minimum': 0},
        'redis_lfu_decay_time': {'maximum': 120, 'minimum': 1},
        'redis_timeout': {'maximum': 31536000, 'minimum': 0},
        'redis_notify_keyspace_events': {'max_length': 32, 'min_length': 0, 'pattern': r'^[KEg\$lshzxeA]*$'},
    }

    _attribute_map = {
        'redis_maxmemory_policy': {'key': 'redis_maxmemory_policy', 'type': 'str'},
        'redis_pubsub_client_output_buffer_limit': {'key': 'redis_pubsub_client_output_buffer_limit', 'type': 'int'},
        'redis_number_of_databases': {'key': 'redis_number_of_databases', 'type': 'int'},
        'redis_io_threads': {'key': 'redis_io_threads', 'type': 'int'},
        'redis_lfu_log_factor': {'key': 'redis_lfu_log_factor', 'type': 'int'},
        'redis_lfu_decay_time': {'key': 'redis_lfu_decay_time', 'type': 'int'},
        'redis_ssl': {'key': 'redis_ssl', 'type': 'bool'},
        'redis_timeout': {'key': 'redis_timeout', 'type': 'int'},
        'redis_notify_keyspace_events': {'key': 'redis_notify_keyspace_events', 'type': 'str'},
        'redis_persistence': {'key': 'redis_persistence', 'type': 'str'},
        'redis_acl_channels_default': {'key': 'redis_acl_channels_default', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        redis_maxmemory_policy: Optional[Union[str, "_models.RedisMaxmemoryPolicy"]] = "noeviction",
        redis_pubsub_client_output_buffer_limit: Optional[int] = None,
        redis_number_of_databases: Optional[int] = None,
        redis_io_threads: Optional[int] = None,
        redis_lfu_log_factor: Optional[int] = 10,
        redis_lfu_decay_time: Optional[int] = 1,
        redis_ssl: Optional[bool] = True,
        redis_timeout: Optional[int] = 300,
        redis_notify_keyspace_events: Optional[str] = "",
        redis_persistence: Optional[Union[str, "_models.RedisPersistence"]] = None,
        redis_acl_channels_default: Optional[Union[str, "_models.RedisAclChannelsDefault"]] = None,
        **kwargs
    ):
        """
        :keyword redis_maxmemory_policy: Known values are: "noeviction", "allkeys-lru", "volatile-lru",
         "allkeys-random", "volatile-random", "volatile-ttl", "volatile-lfu", "allkeys-lfu". Default
         value: "noeviction".
        :paramtype redis_maxmemory_policy: str or ~digital_ocean_api.models.RedisMaxmemoryPolicy
        :keyword redis_pubsub_client_output_buffer_limit: Set output buffer limit for pub / sub clients
         in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the
         limit, be mindful of the available memory in the selected service plan.
        :paramtype redis_pubsub_client_output_buffer_limit: int
        :keyword redis_number_of_databases: Set number of redis databases. Changing this will cause a
         restart of redis service.
        :paramtype redis_number_of_databases: int
        :keyword redis_io_threads: Redis IO thread count.
        :paramtype redis_io_threads: int
        :keyword redis_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu
         maxmemory-policies.
        :paramtype redis_lfu_log_factor: int
        :keyword redis_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes.
        :paramtype redis_lfu_decay_time: int
        :keyword redis_ssl: Require SSL to access Redis.
        :paramtype redis_ssl: bool
        :keyword redis_timeout: Redis idle connection timeout in seconds.
        :paramtype redis_timeout: int
        :keyword redis_notify_keyspace_events: Set notify-keyspace-events option.
        :paramtype redis_notify_keyspace_events: str
        :keyword redis_persistence: When persistence is 'rdb', Redis does RDB dumps each 10 minutes if
         any key is changed. Also RDB dumps are done according to backup schedule for backup purposes.
         When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment
         if service is restarted for any reason, or if service is powered off. Also service can't be
         forked. Known values are: "off", "rdb".
        :paramtype redis_persistence: str or ~digital_ocean_api.models.RedisPersistence
        :keyword redis_acl_channels_default: Determines default pub/sub channels' ACL for new users if
         ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward
         compatibility. This option doesn't affect Redis configuration acl-pubsub-default. Known values
         are: "allchannels", "resetchannels".
        :paramtype redis_acl_channels_default: str or ~digital_ocean_api.models.RedisAclChannelsDefault
        """
        super(Redis, self).__init__(**kwargs)
        self.redis_maxmemory_policy = redis_maxmemory_policy
        self.redis_pubsub_client_output_buffer_limit = redis_pubsub_client_output_buffer_limit
        self.redis_number_of_databases = redis_number_of_databases
        self.redis_io_threads = redis_io_threads
        self.redis_lfu_log_factor = redis_lfu_log_factor
        self.redis_lfu_decay_time = redis_lfu_decay_time
        self.redis_ssl = redis_ssl
        self.redis_timeout = redis_timeout
        self.redis_notify_keyspace_events = redis_notify_keyspace_events
        self.redis_persistence = redis_persistence
        self.redis_acl_channels_default = redis_acl_channels_default


class Registry(msrest.serialization.Model):
    """Registry.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: A globally unique name for the container registry. Must be lowercase and be
     composed only of numbers, letters and ``-``\ , up to a limit of 63 characters.
    :vartype name: str
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the registry was created.
    :vartype created_at: ~datetime.datetime
    :ivar region: Slug of the region where registry data is stored.
    :vartype region: str
    :ivar storage_usage_bytes: The amount of storage used in the registry in bytes.
    :vartype storage_usage_bytes: int
    :ivar storage_usage_bytes_updated_at: The time at which the storage usage was updated. Storage
     usage is calculated asynchronously, and may not immediately reflect pushes to the registry.
    :vartype storage_usage_bytes_updated_at: ~datetime.datetime
    :ivar subscription:
    :vartype subscription: ~digital_ocean_api.models.RegistrySubscription
    """

    _validation = {
        'name': {'max_length': 63, 'min_length': 0, 'pattern': r'^[a-z0-9-]{1,63}$'},
        'created_at': {'readonly': True},
        'storage_usage_bytes': {'readonly': True},
        'storage_usage_bytes_updated_at': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'region': {'key': 'region', 'type': 'str'},
        'storage_usage_bytes': {'key': 'storage_usage_bytes', 'type': 'int'},
        'storage_usage_bytes_updated_at': {'key': 'storage_usage_bytes_updated_at', 'type': 'iso-8601'},
        'subscription': {'key': 'subscription', 'type': 'RegistrySubscription'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        region: Optional[str] = None,
        subscription: Optional["_models.RegistrySubscription"] = None,
        **kwargs
    ):
        """
        :keyword name: A globally unique name for the container registry. Must be lowercase and be
         composed only of numbers, letters and ``-``\ , up to a limit of 63 characters.
        :paramtype name: str
        :keyword region: Slug of the region where registry data is stored.
        :paramtype region: str
        :keyword subscription:
        :paramtype subscription: ~digital_ocean_api.models.RegistrySubscription
        """
        super(Registry, self).__init__(**kwargs)
        self.name = name
        self.created_at = None
        self.region = region
        self.storage_usage_bytes = None
        self.storage_usage_bytes_updated_at = None
        self.subscription = subscription


class RegistryCreate(msrest.serialization.Model):
    """RegistryCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A globally unique name for the container registry. Must be lowercase and
     be composed only of numbers, letters and ``-``\ , up to a limit of 63 characters.
    :vartype name: str
    :ivar subscription_tier_slug: Required. The slug of the subscription tier to sign up for. Valid
     values can be retrieved using the options endpoint. Known values are: "starter", "basic",
     "professional".
    :vartype subscription_tier_slug: str or
     ~digital_ocean_api.models.RegistryCreateSubscriptionTierSlug
    :ivar region: Slug of the region where registry data is stored. When not provided, a region
     will be selected. Known values are: "nyc3", "sfo3", "ams3", "sgp1", "fra1".
    :vartype region: str or ~digital_ocean_api.models.RegistryCreateRegion
    """

    _validation = {
        'name': {'required': True, 'max_length': 63, 'min_length': 0, 'pattern': r'^[a-z0-9-]{1,63}$'},
        'subscription_tier_slug': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'subscription_tier_slug': {'key': 'subscription_tier_slug', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        subscription_tier_slug: Union[str, "_models.RegistryCreateSubscriptionTierSlug"],
        region: Optional[Union[str, "_models.RegistryCreateRegion"]] = None,
        **kwargs
    ):
        """
        :keyword name: Required. A globally unique name for the container registry. Must be lowercase
         and be composed only of numbers, letters and ``-``\ , up to a limit of 63 characters.
        :paramtype name: str
        :keyword subscription_tier_slug: Required. The slug of the subscription tier to sign up for.
         Valid values can be retrieved using the options endpoint. Known values are: "starter", "basic",
         "professional".
        :paramtype subscription_tier_slug: str or
         ~digital_ocean_api.models.RegistryCreateSubscriptionTierSlug
        :keyword region: Slug of the region where registry data is stored. When not provided, a region
         will be selected. Known values are: "nyc3", "sfo3", "ams3", "sgp1", "fra1".
        :paramtype region: str or ~digital_ocean_api.models.RegistryCreateRegion
        """
        super(RegistryCreate, self).__init__(**kwargs)
        self.name = name
        self.subscription_tier_slug = subscription_tier_slug
        self.region = region


class RegistryOptionsResponseApplicationJsonProperties(msrest.serialization.Model):
    """RegistryOptionsResponseApplicationJsonProperties.

    :ivar available_regions:
    :vartype available_regions: list[str]
    :ivar subscription_tiers:
    :vartype subscription_tiers:
     list[~digital_ocean_api.models.Components1Vh7GehResponsesRegistryOptionsResponseContentApplicationJsonSchemaPropertiesOptionsPropertiesSubscriptionTiersItems]
    """

    _attribute_map = {
        'available_regions': {'key': 'available_regions', 'type': '[str]'},
        'subscription_tiers': {'key': 'subscription_tiers', 'type': '[Components1Vh7GehResponsesRegistryOptionsResponseContentApplicationJsonSchemaPropertiesOptionsPropertiesSubscriptionTiersItems]'},
    }

    def __init__(
        self,
        *,
        available_regions: Optional[List[str]] = None,
        subscription_tiers: Optional[List["_models.Components1Vh7GehResponsesRegistryOptionsResponseContentApplicationJsonSchemaPropertiesOptionsPropertiesSubscriptionTiersItems"]] = None,
        **kwargs
    ):
        """
        :keyword available_regions:
        :paramtype available_regions: list[str]
        :keyword subscription_tiers:
        :paramtype subscription_tiers:
         list[~digital_ocean_api.models.Components1Vh7GehResponsesRegistryOptionsResponseContentApplicationJsonSchemaPropertiesOptionsPropertiesSubscriptionTiersItems]
        """
        super(RegistryOptionsResponseApplicationJsonProperties, self).__init__(**kwargs)
        self.available_regions = available_regions
        self.subscription_tiers = subscription_tiers


class Subscription(msrest.serialization.Model):
    """Subscription.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tier:
    :vartype tier: ~digital_ocean_api.models.SubscriptionTierBase
    :ivar created_at: The time at which the subscription was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: The time at which the subscription was last updated.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'tier': {'key': 'tier', 'type': 'SubscriptionTierBase'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        tier: Optional["_models.SubscriptionTierBase"] = None,
        **kwargs
    ):
        """
        :keyword tier:
        :paramtype tier: ~digital_ocean_api.models.SubscriptionTierBase
        """
        super(Subscription, self).__init__(**kwargs)
        self.tier = tier
        self.created_at = None
        self.updated_at = None


class RegistrySubscription(Subscription):
    """RegistrySubscription.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tier:
    :vartype tier: ~digital_ocean_api.models.SubscriptionTierBase
    :ivar created_at: The time at which the subscription was created.
    :vartype created_at: ~datetime.datetime
    :ivar updated_at: The time at which the subscription was last updated.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        'created_at': {'readonly': True},
        'updated_at': {'readonly': True},
    }

    _attribute_map = {
        'tier': {'key': 'tier', 'type': 'SubscriptionTierBase'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        tier: Optional["_models.SubscriptionTierBase"] = None,
        **kwargs
    ):
        """
        :keyword tier:
        :paramtype tier: ~digital_ocean_api.models.SubscriptionTierBase
        """
        super(RegistrySubscription, self).__init__(tier=tier, **kwargs)


class Repository(msrest.serialization.Model):
    """Repository.

    :ivar registry_name: The name of the container registry.
    :vartype registry_name: str
    :ivar name: The name of the repository.
    :vartype name: str
    :ivar latest_tag:
    :vartype latest_tag: ~digital_ocean_api.models.RepositoryTag
    :ivar tag_count: The number of tags in the repository.
    :vartype tag_count: int
    """

    _attribute_map = {
        'registry_name': {'key': 'registry_name', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'latest_tag': {'key': 'latest_tag', 'type': 'RepositoryTag'},
        'tag_count': {'key': 'tag_count', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        registry_name: Optional[str] = None,
        name: Optional[str] = None,
        latest_tag: Optional["_models.RepositoryTag"] = None,
        tag_count: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword registry_name: The name of the container registry.
        :paramtype registry_name: str
        :keyword name: The name of the repository.
        :paramtype name: str
        :keyword latest_tag:
        :paramtype latest_tag: ~digital_ocean_api.models.RepositoryTag
        :keyword tag_count: The number of tags in the repository.
        :paramtype tag_count: int
        """
        super(Repository, self).__init__(**kwargs)
        self.registry_name = registry_name
        self.name = name
        self.latest_tag = latest_tag
        self.tag_count = tag_count


class RepositoryBlob(msrest.serialization.Model):
    """RepositoryBlob.

    :ivar digest: The digest of the blob.
    :vartype digest: str
    :ivar compressed_size_bytes: The compressed size of the blob in bytes.
    :vartype compressed_size_bytes: int
    """

    _attribute_map = {
        'digest': {'key': 'digest', 'type': 'str'},
        'compressed_size_bytes': {'key': 'compressed_size_bytes', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        digest: Optional[str] = None,
        compressed_size_bytes: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword digest: The digest of the blob.
        :paramtype digest: str
        :keyword compressed_size_bytes: The compressed size of the blob in bytes.
        :paramtype compressed_size_bytes: int
        """
        super(RepositoryBlob, self).__init__(**kwargs)
        self.digest = digest
        self.compressed_size_bytes = compressed_size_bytes


class RepositoryManifest(msrest.serialization.Model):
    """RepositoryManifest.

    :ivar registry_name: The name of the container registry.
    :vartype registry_name: str
    :ivar repository: The name of the repository.
    :vartype repository: str
    :ivar digest: The manifest digest.
    :vartype digest: str
    :ivar compressed_size_bytes: The compressed size of the manifest in bytes.
    :vartype compressed_size_bytes: int
    :ivar size_bytes: The uncompressed size of the manifest in bytes (this size is calculated
     asynchronously so it may not be immediately available).
    :vartype size_bytes: int
    :ivar updated_at: The time the manifest was last updated.
    :vartype updated_at: ~datetime.datetime
    :ivar tags: A set of tags. All tags associated with this manifest.
    :vartype tags: list[str]
    :ivar blobs: All blobs associated with this manifest.
    :vartype blobs: list[~digital_ocean_api.models.RepositoryBlob]
    """

    _attribute_map = {
        'registry_name': {'key': 'registry_name', 'type': 'str'},
        'repository': {'key': 'repository', 'type': 'str'},
        'digest': {'key': 'digest', 'type': 'str'},
        'compressed_size_bytes': {'key': 'compressed_size_bytes', 'type': 'int'},
        'size_bytes': {'key': 'size_bytes', 'type': 'int'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'blobs': {'key': 'blobs', 'type': '[RepositoryBlob]'},
    }

    def __init__(
        self,
        *,
        registry_name: Optional[str] = None,
        repository: Optional[str] = None,
        digest: Optional[str] = None,
        compressed_size_bytes: Optional[int] = None,
        size_bytes: Optional[int] = None,
        updated_at: Optional[datetime.datetime] = None,
        tags: Optional[List[str]] = None,
        blobs: Optional[List["_models.RepositoryBlob"]] = None,
        **kwargs
    ):
        """
        :keyword registry_name: The name of the container registry.
        :paramtype registry_name: str
        :keyword repository: The name of the repository.
        :paramtype repository: str
        :keyword digest: The manifest digest.
        :paramtype digest: str
        :keyword compressed_size_bytes: The compressed size of the manifest in bytes.
        :paramtype compressed_size_bytes: int
        :keyword size_bytes: The uncompressed size of the manifest in bytes (this size is calculated
         asynchronously so it may not be immediately available).
        :paramtype size_bytes: int
        :keyword updated_at: The time the manifest was last updated.
        :paramtype updated_at: ~datetime.datetime
        :keyword tags: A set of tags. All tags associated with this manifest.
        :paramtype tags: list[str]
        :keyword blobs: All blobs associated with this manifest.
        :paramtype blobs: list[~digital_ocean_api.models.RepositoryBlob]
        """
        super(RepositoryManifest, self).__init__(**kwargs)
        self.registry_name = registry_name
        self.repository = repository
        self.digest = digest
        self.compressed_size_bytes = compressed_size_bytes
        self.size_bytes = size_bytes
        self.updated_at = updated_at
        self.tags = tags
        self.blobs = blobs


class RepositoryTag(msrest.serialization.Model):
    """RepositoryTag.

    :ivar registry_name: The name of the container registry.
    :vartype registry_name: str
    :ivar repository: The name of the repository.
    :vartype repository: str
    :ivar tag: The name of the tag.
    :vartype tag: str
    :ivar manifest_digest: The digest of the manifest associated with the tag.
    :vartype manifest_digest: str
    :ivar compressed_size_bytes: The compressed size of the tag in bytes.
    :vartype compressed_size_bytes: int
    :ivar size_bytes: The uncompressed size of the tag in bytes (this size is calculated
     asynchronously so it may not be immediately available).
    :vartype size_bytes: int
    :ivar updated_at: The time the tag was last updated.
    :vartype updated_at: ~datetime.datetime
    """

    _attribute_map = {
        'registry_name': {'key': 'registry_name', 'type': 'str'},
        'repository': {'key': 'repository', 'type': 'str'},
        'tag': {'key': 'tag', 'type': 'str'},
        'manifest_digest': {'key': 'manifest_digest', 'type': 'str'},
        'compressed_size_bytes': {'key': 'compressed_size_bytes', 'type': 'int'},
        'size_bytes': {'key': 'size_bytes', 'type': 'int'},
        'updated_at': {'key': 'updated_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        registry_name: Optional[str] = None,
        repository: Optional[str] = None,
        tag: Optional[str] = None,
        manifest_digest: Optional[str] = None,
        compressed_size_bytes: Optional[int] = None,
        size_bytes: Optional[int] = None,
        updated_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword registry_name: The name of the container registry.
        :paramtype registry_name: str
        :keyword repository: The name of the repository.
        :paramtype repository: str
        :keyword tag: The name of the tag.
        :paramtype tag: str
        :keyword manifest_digest: The digest of the manifest associated with the tag.
        :paramtype manifest_digest: str
        :keyword compressed_size_bytes: The compressed size of the tag in bytes.
        :paramtype compressed_size_bytes: int
        :keyword size_bytes: The uncompressed size of the tag in bytes (this size is calculated
         asynchronously so it may not be immediately available).
        :paramtype size_bytes: int
        :keyword updated_at: The time the tag was last updated.
        :paramtype updated_at: ~datetime.datetime
        """
        super(RepositoryTag, self).__init__(**kwargs)
        self.registry_name = registry_name
        self.repository = repository
        self.tag = tag
        self.manifest_digest = manifest_digest
        self.compressed_size_bytes = compressed_size_bytes
        self.size_bytes = size_bytes
        self.updated_at = updated_at


class RepositoryV2(msrest.serialization.Model):
    """RepositoryV2.

    :ivar registry_name: The name of the container registry.
    :vartype registry_name: str
    :ivar name: The name of the repository.
    :vartype name: str
    :ivar latest_manifest:
    :vartype latest_manifest: ~digital_ocean_api.models.RepositoryManifest
    :ivar tag_count: The number of tags in the repository.
    :vartype tag_count: int
    :ivar manifest_count: The number of manifests in the repository.
    :vartype manifest_count: int
    """

    _attribute_map = {
        'registry_name': {'key': 'registry_name', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'latest_manifest': {'key': 'latest_manifest', 'type': 'RepositoryManifest'},
        'tag_count': {'key': 'tag_count', 'type': 'int'},
        'manifest_count': {'key': 'manifest_count', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        registry_name: Optional[str] = None,
        name: Optional[str] = None,
        latest_manifest: Optional["_models.RepositoryManifest"] = None,
        tag_count: Optional[int] = None,
        manifest_count: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword registry_name: The name of the container registry.
        :paramtype registry_name: str
        :keyword name: The name of the repository.
        :paramtype name: str
        :keyword latest_manifest:
        :paramtype latest_manifest: ~digital_ocean_api.models.RepositoryManifest
        :keyword tag_count: The number of tags in the repository.
        :paramtype tag_count: int
        :keyword manifest_count: The number of manifests in the repository.
        :paramtype manifest_count: int
        """
        super(RepositoryV2, self).__init__(**kwargs)
        self.registry_name = registry_name
        self.name = name
        self.latest_manifest = latest_manifest
        self.tag_count = tag_count
        self.manifest_count = manifest_count


class ReserveToRegion(msrest.serialization.Model):
    """Reserve to Region.

    All required parameters must be populated in order to send to Azure.

    :ivar region: Required. The slug identifier for the region the floating IP will be reserved to.
    :vartype region: str
    """

    _validation = {
        'region': {'required': True},
    }

    _attribute_map = {
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        region: str,
        **kwargs
    ):
        """
        :keyword region: Required. The slug identifier for the region the floating IP will be reserved
         to.
        :paramtype region: str
        """
        super(ReserveToRegion, self).__init__(**kwargs)
        self.region = region


class Resource(msrest.serialization.Model):
    """Resource.

    :ivar urn: The uniform resource name (URN) for the resource in the format
     do:resource_type:resource_id.
    :vartype urn: str
    :ivar assigned_at: A time value given in ISO8601 combined date and time format that represents
     when the project was created.
    :vartype assigned_at: ~datetime.datetime
    :ivar links: The links object contains the ``self`` object, which contains the resource
     relationship.
    :vartype links: ~digital_ocean_api.models.ResourceLinks
    :ivar status: The status of assigning and fetching the resources. Known values are: "ok",
     "not_found", "assigned", "already_assigned", "service_down".
    :vartype status: str or ~digital_ocean_api.models.ResourceStatus
    """

    _validation = {
        'urn': {'pattern': r'^do:(dbaas|domain|droplet|floatingip|loadbalancer|space|volume|kubernetes|vpc):.*'},
    }

    _attribute_map = {
        'urn': {'key': 'urn', 'type': 'str'},
        'assigned_at': {'key': 'assigned_at', 'type': 'iso-8601'},
        'links': {'key': 'links', 'type': 'ResourceLinks'},
        'status': {'key': 'status', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        urn: Optional[str] = None,
        assigned_at: Optional[datetime.datetime] = None,
        links: Optional["_models.ResourceLinks"] = None,
        status: Optional[Union[str, "_models.ResourceStatus"]] = None,
        **kwargs
    ):
        """
        :keyword urn: The uniform resource name (URN) for the resource in the format
         do:resource_type:resource_id.
        :paramtype urn: str
        :keyword assigned_at: A time value given in ISO8601 combined date and time format that
         represents when the project was created.
        :paramtype assigned_at: ~datetime.datetime
        :keyword links: The links object contains the ``self`` object, which contains the resource
         relationship.
        :paramtype links: ~digital_ocean_api.models.ResourceLinks
        :keyword status: The status of assigning and fetching the resources. Known values are: "ok",
         "not_found", "assigned", "already_assigned", "service_down".
        :paramtype status: str or ~digital_ocean_api.models.ResourceStatus
        """
        super(Resource, self).__init__(**kwargs)
        self.urn = urn
        self.assigned_at = assigned_at
        self.links = links
        self.status = status


class ResourceLinks(msrest.serialization.Model):
    """The links object contains the ``self`` object, which contains the resource relationship.

    :ivar self_property: A URI that can be used to retrieve the resource.
    :vartype self_property: str
    """

    _attribute_map = {
        'self_property': {'key': 'self', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        self_property: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword self_property: A URI that can be used to retrieve the resource.
        :paramtype self_property: str
        """
        super(ResourceLinks, self).__init__(**kwargs)
        self.self_property = self_property


class SingleDropletResponse(msrest.serialization.Model):
    """Single Droplet Response.

    All required parameters must be populated in order to send to Azure.

    :ivar droplet: Required.
    :vartype droplet: ~digital_ocean_api.models.Droplet
    :ivar links: Required.
    :vartype links: ~digital_ocean_api.models.DropletCreateApplicationJsonOneOfProperties
    """

    _validation = {
        'droplet': {'required': True},
        'links': {'required': True},
    }

    _attribute_map = {
        'droplet': {'key': 'droplet', 'type': 'Droplet'},
        'links': {'key': 'links', 'type': 'DropletCreateApplicationJsonOneOfProperties'},
    }

    def __init__(
        self,
        *,
        droplet: "_models.Droplet",
        links: "_models.DropletCreateApplicationJsonOneOfProperties",
        **kwargs
    ):
        """
        :keyword droplet: Required.
        :paramtype droplet: ~digital_ocean_api.models.Droplet
        :keyword links: Required.
        :paramtype links: ~digital_ocean_api.models.DropletCreateApplicationJsonOneOfProperties
        """
        super(SingleDropletResponse, self).__init__(**kwargs)
        self.droplet = droplet
        self.links = links


class Size(msrest.serialization.Model):
    """Size.

    All required parameters must be populated in order to send to Azure.

    :ivar slug: Required. A human-readable string that is used to uniquely identify each size.
    :vartype slug: str
    :ivar memory: Required. The amount of RAM allocated to Droplets created of this size. The value
     is represented in megabytes.
    :vartype memory: int
    :ivar vcpus: Required. The integer of number CPUs allocated to Droplets of this size.
    :vartype vcpus: int
    :ivar disk: Required. The amount of disk space set aside for Droplets of this size. The value
     is represented in gigabytes.
    :vartype disk: int
    :ivar transfer: Required. The amount of transfer bandwidth that is available for Droplets
     created in this size. This only counts traffic on the public interface. The value is given in
     terabytes.
    :vartype transfer: float
    :ivar price_monthly: Required. This attribute describes the monthly cost of this Droplet size
     if the Droplet is kept for an entire month. The value is measured in US dollars.
    :vartype price_monthly: float
    :ivar price_hourly: Required. This describes the price of the Droplet size as measured hourly.
     The value is measured in US dollars.
    :vartype price_hourly: float
    :ivar regions: Required. An array containing the region slugs where this size is available for
     Droplet creates.
    :vartype regions: list[str]
    :ivar available: Required. This is a boolean value that represents whether new Droplets can be
     created with this size.
    :vartype available: bool
    :ivar description: Required. A string describing the class of Droplets created from this size.
     For example: Basic, General Purpose, CPU-Optimized, Memory-Optimized, or Storage-Optimized.
    :vartype description: str
    """

    _validation = {
        'slug': {'required': True},
        'memory': {'required': True, 'minimum': 8, 'multiple': 8},
        'vcpus': {'required': True},
        'disk': {'required': True},
        'transfer': {'required': True},
        'price_monthly': {'required': True},
        'price_hourly': {'required': True},
        'regions': {'required': True},
        'available': {'required': True},
        'description': {'required': True},
    }

    _attribute_map = {
        'slug': {'key': 'slug', 'type': 'str'},
        'memory': {'key': 'memory', 'type': 'int'},
        'vcpus': {'key': 'vcpus', 'type': 'int'},
        'disk': {'key': 'disk', 'type': 'int'},
        'transfer': {'key': 'transfer', 'type': 'float'},
        'price_monthly': {'key': 'price_monthly', 'type': 'float'},
        'price_hourly': {'key': 'price_hourly', 'type': 'float'},
        'regions': {'key': 'regions', 'type': '[str]'},
        'available': {'key': 'available', 'type': 'bool'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        slug: str,
        memory: int,
        vcpus: int,
        disk: int,
        transfer: float,
        price_monthly: float,
        price_hourly: float,
        regions: List[str],
        available: bool = True,
        description: str,
        **kwargs
    ):
        """
        :keyword slug: Required. A human-readable string that is used to uniquely identify each size.
        :paramtype slug: str
        :keyword memory: Required. The amount of RAM allocated to Droplets created of this size. The
         value is represented in megabytes.
        :paramtype memory: int
        :keyword vcpus: Required. The integer of number CPUs allocated to Droplets of this size.
        :paramtype vcpus: int
        :keyword disk: Required. The amount of disk space set aside for Droplets of this size. The
         value is represented in gigabytes.
        :paramtype disk: int
        :keyword transfer: Required. The amount of transfer bandwidth that is available for Droplets
         created in this size. This only counts traffic on the public interface. The value is given in
         terabytes.
        :paramtype transfer: float
        :keyword price_monthly: Required. This attribute describes the monthly cost of this Droplet
         size if the Droplet is kept for an entire month. The value is measured in US dollars.
        :paramtype price_monthly: float
        :keyword price_hourly: Required. This describes the price of the Droplet size as measured
         hourly. The value is measured in US dollars.
        :paramtype price_hourly: float
        :keyword regions: Required. An array containing the region slugs where this size is available
         for Droplet creates.
        :paramtype regions: list[str]
        :keyword available: Required. This is a boolean value that represents whether new Droplets can
         be created with this size.
        :paramtype available: bool
        :keyword description: Required. A string describing the class of Droplets created from this
         size. For example: Basic, General Purpose, CPU-Optimized, Memory-Optimized, or
         Storage-Optimized.
        :paramtype description: str
        """
        super(Size, self).__init__(**kwargs)
        self.slug = slug
        self.memory = memory
        self.vcpus = vcpus
        self.disk = disk
        self.transfer = transfer
        self.price_monthly = price_monthly
        self.price_hourly = price_hourly
        self.regions = regions
        self.available = available
        self.description = description


class SlackDetails(msrest.serialization.Model):
    """SlackDetails.

    All required parameters must be populated in order to send to Azure.

    :ivar channel: Required. Slack channel to notify of an alert trigger.
    :vartype channel: str
    :ivar url: Required. Slack Webhook URL.
    :vartype url: str
    """

    _validation = {
        'channel': {'required': True},
        'url': {'required': True},
    }

    _attribute_map = {
        'channel': {'key': 'channel', 'type': 'str'},
        'url': {'key': 'url', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        channel: str,
        url: str,
        **kwargs
    ):
        """
        :keyword channel: Required. Slack channel to notify of an alert trigger.
        :paramtype channel: str
        :keyword url: Required. Slack Webhook URL.
        :paramtype url: str
        """
        super(SlackDetails, self).__init__(**kwargs)
        self.channel = channel
        self.url = url


class Snapshot(SnapshotBase):
    """Snapshot.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A human-readable name for the snapshot.
    :vartype name: str
    :ivar created_at: Required. A time value given in ISO8601 combined date and time format that
     represents when the snapshot was created.
    :vartype created_at: ~datetime.datetime
    :ivar regions: Required. An array of the regions that the snapshot is available in. The regions
     are represented by their identifying slug values.
    :vartype regions: list[str]
    :ivar min_disk_size: Required. The minimum size in GB required for a volume or Droplet to use
     this snapshot.
    :vartype min_disk_size: int
    :ivar size_gigabytes: Required. The billable size of the snapshot in gigabytes.
    :vartype size_gigabytes: float
    :ivar resource_id: Required. The unique identifier for the resource that the snapshot
     originated from.
    :vartype resource_id: str
    :ivar resource_type: Required. The type of resource that the snapshot originated from. Known
     values are: "droplet", "volume".
    :vartype resource_type: str or ~digital_ocean_api.models.SnapshotResourceType
    :ivar tags: Required. A set of tags. An array of Tags the snapshot has been tagged with.
    :vartype tags: list[str]
    """

    _validation = {
        'name': {'required': True},
        'created_at': {'required': True},
        'regions': {'required': True},
        'min_disk_size': {'required': True},
        'size_gigabytes': {'required': True},
        'resource_id': {'required': True},
        'resource_type': {'required': True},
        'tags': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'regions': {'key': 'regions', 'type': '[str]'},
        'min_disk_size': {'key': 'min_disk_size', 'type': 'int'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'float'},
        'resource_id': {'key': 'resource_id', 'type': 'str'},
        'resource_type': {'key': 'resource_type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        name: str,
        created_at: datetime.datetime,
        regions: List[str],
        min_disk_size: int,
        size_gigabytes: float,
        resource_id: str,
        resource_type: Union[str, "_models.SnapshotResourceType"],
        tags: List[str],
        **kwargs
    ):
        """
        :keyword name: Required. A human-readable name for the snapshot.
        :paramtype name: str
        :keyword created_at: Required. A time value given in ISO8601 combined date and time format that
         represents when the snapshot was created.
        :paramtype created_at: ~datetime.datetime
        :keyword regions: Required. An array of the regions that the snapshot is available in. The
         regions are represented by their identifying slug values.
        :paramtype regions: list[str]
        :keyword min_disk_size: Required. The minimum size in GB required for a volume or Droplet to
         use this snapshot.
        :paramtype min_disk_size: int
        :keyword size_gigabytes: Required. The billable size of the snapshot in gigabytes.
        :paramtype size_gigabytes: float
        :keyword resource_id: Required. The unique identifier for the resource that the snapshot
         originated from.
        :paramtype resource_id: str
        :keyword resource_type: Required. The type of resource that the snapshot originated from. Known
         values are: "droplet", "volume".
        :paramtype resource_type: str or ~digital_ocean_api.models.SnapshotResourceType
        :keyword tags: Required. A set of tags. An array of Tags the snapshot has been tagged with.
        :paramtype tags: list[str]
        """
        super(Snapshot, self).__init__(name=name, created_at=created_at, regions=regions, min_disk_size=min_disk_size, size_gigabytes=size_gigabytes, **kwargs)
        self.resource_id = resource_id
        self.resource_type = resource_type
        self.tags = tags


class SourceDatabase(msrest.serialization.Model):
    """SourceDatabase.

    :ivar source:
    :vartype source: ~digital_ocean_api.models.SourceDatabaseSource
    :ivar disable_ssl: Enables SSL encryption when connecting to the source database.
    :vartype disable_ssl: bool
    """

    _attribute_map = {
        'source': {'key': 'source', 'type': 'SourceDatabaseSource'},
        'disable_ssl': {'key': 'disable_ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        source: Optional["_models.SourceDatabaseSource"] = None,
        disable_ssl: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword source:
        :paramtype source: ~digital_ocean_api.models.SourceDatabaseSource
        :keyword disable_ssl: Enables SSL encryption when connecting to the source database.
        :paramtype disable_ssl: bool
        """
        super(SourceDatabase, self).__init__(**kwargs)
        self.source = source
        self.disable_ssl = disable_ssl


class SourceDatabaseSource(DatabaseConnection):
    """SourceDatabaseSource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar uri: A connection string in the format accepted by the ``psql`` command. This is provided
     as a convenience and should be able to be constructed by the other attributes.
    :vartype uri: str
    :ivar database: The name of the default database.
    :vartype database: str
    :ivar host: The FQDN pointing to the database cluster's current primary node.
    :vartype host: str
    :ivar port: The port on which the database cluster is listening.
    :vartype port: int
    :ivar user: The default user for the database.
    :vartype user: str
    :ivar password: The randomly generated password for the default user.
    :vartype password: str
    :ivar ssl: A boolean value indicating if the connection should be made over SSL.
    :vartype ssl: bool
    """

    _validation = {
        'uri': {'readonly': True},
        'database': {'readonly': True},
        'host': {'readonly': True},
        'port': {'readonly': True},
        'user': {'readonly': True},
        'password': {'readonly': True},
        'ssl': {'readonly': True},
    }

    _attribute_map = {
        'uri': {'key': 'uri', 'type': 'str'},
        'database': {'key': 'database', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'user': {'key': 'user', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
        'ssl': {'key': 'ssl', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(SourceDatabaseSource, self).__init__(**kwargs)


class SqlMode(msrest.serialization.Model):
    """SqlMode.

    All required parameters must be populated in order to send to Azure.

    :ivar sql_mode: Required. A string specifying the configured SQL modes for the MySQL cluster.
    :vartype sql_mode: str
    """

    _validation = {
        'sql_mode': {'required': True},
    }

    _attribute_map = {
        'sql_mode': {'key': 'sql_mode', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        sql_mode: str,
        **kwargs
    ):
        """
        :keyword sql_mode: Required. A string specifying the configured SQL modes for the MySQL
         cluster.
        :paramtype sql_mode: str
        """
        super(SqlMode, self).__init__(**kwargs)
        self.sql_mode = sql_mode


class SshKey(msrest.serialization.Model):
    """SshKey.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: A unique identification number for this key. Can be used to embed a  specific SSH key
     into a Droplet.
    :vartype id: int
    :ivar fingerprint: A unique identifier that differentiates this key from other keys using  a
     format that SSH recognizes. The fingerprint is created when the key is added to your account.
    :vartype fingerprint: str
    :ivar public_key: Required. The entire public key string that was uploaded. Embedded into the
     root user's ``authorized_keys`` file if you include this key during Droplet creation.
    :vartype public_key: str
    :ivar name: Required. A human-readable display name for this key, used to easily identify the
     SSH keys when they are displayed.
    :vartype name: str
    """

    _validation = {
        'id': {'readonly': True},
        'fingerprint': {'readonly': True},
        'public_key': {'required': True},
        'name': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'fingerprint': {'key': 'fingerprint', 'type': 'str'},
        'public_key': {'key': 'public_key', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        public_key: str,
        name: str,
        **kwargs
    ):
        """
        :keyword public_key: Required. The entire public key string that was uploaded. Embedded into
         the root user's ``authorized_keys`` file if you include this key during Droplet creation.
        :paramtype public_key: str
        :keyword name: Required. A human-readable display name for this key, used to easily identify
         the SSH keys when they are displayed.
        :paramtype name: str
        """
        super(SshKey, self).__init__(**kwargs)
        self.id = None
        self.fingerprint = None
        self.public_key = public_key
        self.name = name


class StickySessions(msrest.serialization.Model):
    """An object specifying sticky sessions settings for the load balancer.

    :ivar type: An attribute indicating how and if requests from a client will be persistently
     served by the same backend Droplet. The possible values are ``cookies`` or ``none``. Known
     values are: "cookies", "none". Default value: "none".
    :vartype type: str or ~digital_ocean_api.models.StickySessionsType
    :ivar cookie_name: The name of the cookie sent to the client. This attribute is only returned
     when using ``cookies`` for the sticky sessions type.
    :vartype cookie_name: str
    :ivar cookie_ttl_seconds: The number of seconds until the cookie set by the load balancer
     expires. This attribute is only returned when using ``cookies`` for the sticky sessions type.
    :vartype cookie_ttl_seconds: int
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'cookie_name': {'key': 'cookie_name', 'type': 'str'},
        'cookie_ttl_seconds': {'key': 'cookie_ttl_seconds', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.StickySessionsType"]] = "none",
        cookie_name: Optional[str] = None,
        cookie_ttl_seconds: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword type: An attribute indicating how and if requests from a client will be persistently
         served by the same backend Droplet. The possible values are ``cookies`` or ``none``. Known
         values are: "cookies", "none". Default value: "none".
        :paramtype type: str or ~digital_ocean_api.models.StickySessionsType
        :keyword cookie_name: The name of the cookie sent to the client. This attribute is only
         returned when using ``cookies`` for the sticky sessions type.
        :paramtype cookie_name: str
        :keyword cookie_ttl_seconds: The number of seconds until the cookie set by the load balancer
         expires. This attribute is only returned when using ``cookies`` for the sticky sessions type.
        :paramtype cookie_ttl_seconds: int
        """
        super(StickySessions, self).__init__(**kwargs)
        self.type = type
        self.cookie_name = cookie_name
        self.cookie_ttl_seconds = cookie_ttl_seconds


class Tag(msrest.serialization.Model):
    """A tag is a label that can be applied to a resource (currently Droplets, Images, Volumes, Volume Snapshots, and Database clusters) in order to better organize or facilitate the lookups and actions on it.
Tags have two attributes: a user defined ``name`` attribute and an embedded ``resources`` attribute with information about resources that have been tagged.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar name: The name of the tag. Tags may contain letters, numbers, colons, dashes, and
     underscores.
     There is a limit of 255 characters per tag.
    
     **Note:** Tag names are case stable, which means the capitalization you use when you first
     create a tag is canonical.
    
     When working with tags in the API, you must use the tag's canonical capitalization. For
     example, if you create a tag named "PROD", the URL to add that tag to a resource would be
     ``https://api.digitalocean.com/v2/tags/PROD/resources`` (not ``/v2/tags/prod/resources``\ ).
    
     Tagged resources in the control panel will always display the canonical capitalization. For
     example, if you create a tag named "PROD", you can tag resources in the control panel by
     entering "prod". The tag will still display with its canonical capitalization, "PROD".
    :vartype name: str
    :ivar resources: An embedded object containing key value pairs of resource type and resource
     statistics. It also includes a count of the total number of resources tagged with the current
     tag as well as a ``last_tagged_uri`` attribute set to the last resource tagged with the current
     tag.
    :vartype resources: ~digital_ocean_api.models.TagResources
    """

    _validation = {
        'name': {'max_length': 255, 'min_length': 0, 'pattern': r'^[a-zA-Z0-9_\-\:]+$'},
        'resources': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'resources': {'key': 'resources', 'type': 'TagResources'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of the tag. Tags may contain letters, numbers, colons, dashes, and
         underscores.
         There is a limit of 255 characters per tag.
        
         **Note:** Tag names are case stable, which means the capitalization you use when you first
         create a tag is canonical.
        
         When working with tags in the API, you must use the tag's canonical capitalization. For
         example, if you create a tag named "PROD", the URL to add that tag to a resource would be
         ``https://api.digitalocean.com/v2/tags/PROD/resources`` (not ``/v2/tags/prod/resources``\ ).
        
         Tagged resources in the control panel will always display the canonical capitalization. For
         example, if you create a tag named "PROD", you can tag resources in the control panel by
         entering "prod". The tag will still display with its canonical capitalization, "PROD".
        :paramtype name: str
        """
        super(Tag, self).__init__(**kwargs)
        self.name = name
        self.resources = None


class TagMetadata(msrest.serialization.Model):
    """Tagged Resource Statistics include metadata regarding the resource type that has been tagged.

    :ivar count: The number of tagged objects for this type of resource.
    :vartype count: int
    :ivar last_tagged_uri: The URI for the last tagged object for this type of resource.
    :vartype last_tagged_uri: str
    """

    _validation = {
        'count': {'minimum': 0},
    }

    _attribute_map = {
        'count': {'key': 'count', 'type': 'int'},
        'last_tagged_uri': {'key': 'last_tagged_uri', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        last_tagged_uri: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword count: The number of tagged objects for this type of resource.
        :paramtype count: int
        :keyword last_tagged_uri: The URI for the last tagged object for this type of resource.
        :paramtype last_tagged_uri: str
        """
        super(TagMetadata, self).__init__(**kwargs)
        self.count = count
        self.last_tagged_uri = last_tagged_uri


class TagResource(msrest.serialization.Model):
    """TagResource.

    All required parameters must be populated in order to send to Azure.

    :ivar resources: Required. An array of objects containing resource_id and resource_type
     attributes.
    :vartype resources: list[~digital_ocean_api.models.TagResourceResourcesItem]
    """

    _validation = {
        'resources': {'required': True},
    }

    _attribute_map = {
        'resources': {'key': 'resources', 'type': '[TagResourceResourcesItem]'},
    }

    def __init__(
        self,
        *,
        resources: List["_models.TagResourceResourcesItem"],
        **kwargs
    ):
        """
        :keyword resources: Required. An array of objects containing resource_id and resource_type
         attributes.
        :paramtype resources: list[~digital_ocean_api.models.TagResourceResourcesItem]
        """
        super(TagResource, self).__init__(**kwargs)
        self.resources = resources


class TagResourceResourcesItem(msrest.serialization.Model):
    """TagResourceResourcesItem.

    :ivar resource_id: The identifier of a resource.
    :vartype resource_id: str
    :ivar resource_type: The type of the resource. Known values are: "droplet", "image", "volume",
     "volume_snapshot".
    :vartype resource_type: str or ~digital_ocean_api.models.TagResourceResourcesItemResourceType
    """

    _attribute_map = {
        'resource_id': {'key': 'resource_id', 'type': 'str'},
        'resource_type': {'key': 'resource_type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        resource_id: Optional[str] = None,
        resource_type: Optional[Union[str, "_models.TagResourceResourcesItemResourceType"]] = None,
        **kwargs
    ):
        """
        :keyword resource_id: The identifier of a resource.
        :paramtype resource_id: str
        :keyword resource_type: The type of the resource. Known values are: "droplet", "image",
         "volume", "volume_snapshot".
        :paramtype resource_type: str or ~digital_ocean_api.models.TagResourceResourcesItemResourceType
        """
        super(TagResourceResourcesItem, self).__init__(**kwargs)
        self.resource_id = resource_id
        self.resource_type = resource_type


class TagResources(TagMetadata, Components1Jlkn4DSchemasTagPropertiesResourcesAllof1):
    """An embedded object containing key value pairs of resource type and resource statistics. It also includes a count of the total number of resources tagged with the current tag as well as a ``last_tagged_uri`` attribute set to the last resource tagged with the current tag.

    :ivar droplets: Tagged Resource Statistics include metadata regarding the resource type that
     has been tagged.
    :vartype droplets: ~digital_ocean_api.models.TagMetadata
    :ivar imgages: Tagged Resource Statistics include metadata regarding the resource type that has
     been tagged.
    :vartype imgages: ~digital_ocean_api.models.TagMetadata
    :ivar volumes: Tagged Resource Statistics include metadata regarding the resource type that has
     been tagged.
    :vartype volumes: ~digital_ocean_api.models.TagMetadata
    :ivar volume_snapshots: Tagged Resource Statistics include metadata regarding the resource type
     that has been tagged.
    :vartype volume_snapshots: ~digital_ocean_api.models.TagMetadata
    :ivar databases: Tagged Resource Statistics include metadata regarding the resource type that
     has been tagged.
    :vartype databases: ~digital_ocean_api.models.TagMetadata
    :ivar count: The number of tagged objects for this type of resource.
    :vartype count: int
    :ivar last_tagged_uri: The URI for the last tagged object for this type of resource.
    :vartype last_tagged_uri: str
    """

    _validation = {
        'count': {'minimum': 0},
    }

    _attribute_map = {
        'droplets': {'key': 'droplets', 'type': 'TagMetadata'},
        'imgages': {'key': 'imgages', 'type': 'TagMetadata'},
        'volumes': {'key': 'volumes', 'type': 'TagMetadata'},
        'volume_snapshots': {'key': 'volume_snapshots', 'type': 'TagMetadata'},
        'databases': {'key': 'databases', 'type': 'TagMetadata'},
        'count': {'key': 'count', 'type': 'int'},
        'last_tagged_uri': {'key': 'last_tagged_uri', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        droplets: Optional["_models.TagMetadata"] = None,
        imgages: Optional["_models.TagMetadata"] = None,
        volumes: Optional["_models.TagMetadata"] = None,
        volume_snapshots: Optional["_models.TagMetadata"] = None,
        databases: Optional["_models.TagMetadata"] = None,
        count: Optional[int] = None,
        last_tagged_uri: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword droplets: Tagged Resource Statistics include metadata regarding the resource type that
         has been tagged.
        :paramtype droplets: ~digital_ocean_api.models.TagMetadata
        :keyword imgages: Tagged Resource Statistics include metadata regarding the resource type that
         has been tagged.
        :paramtype imgages: ~digital_ocean_api.models.TagMetadata
        :keyword volumes: Tagged Resource Statistics include metadata regarding the resource type that
         has been tagged.
        :paramtype volumes: ~digital_ocean_api.models.TagMetadata
        :keyword volume_snapshots: Tagged Resource Statistics include metadata regarding the resource
         type that has been tagged.
        :paramtype volume_snapshots: ~digital_ocean_api.models.TagMetadata
        :keyword databases: Tagged Resource Statistics include metadata regarding the resource type
         that has been tagged.
        :paramtype databases: ~digital_ocean_api.models.TagMetadata
        :keyword count: The number of tagged objects for this type of resource.
        :paramtype count: int
        :keyword last_tagged_uri: The URI for the last tagged object for this type of resource.
        :paramtype last_tagged_uri: str
        """
        super(TagResources, self).__init__(count=count, last_tagged_uri=last_tagged_uri, droplets=droplets, imgages=imgages, volumes=volumes, volume_snapshots=volume_snapshots, databases=databases, **kwargs)
        self.droplets = droplets
        self.imgages = imgages
        self.volumes = volumes
        self.volume_snapshots = volume_snapshots
        self.databases = databases
        self.count = count
        self.last_tagged_uri = last_tagged_uri


class UpdateEndpoint(msrest.serialization.Model):
    """UpdateEndpoint.

    :ivar ttl: The amount of time the content is cached by the CDN's edge servers in seconds. TTL
     must be one of 60, 600, 3600, 86400, or 604800. Defaults to 3600 (one hour) when excluded.
     Known values are: 60, 600, 3600, 86400, 604800. Default value: "3600".
    :vartype ttl: int or ~digital_ocean_api.models.UpdateEndpointTtl
    :ivar certificate_id: The ID of a DigitalOcean managed TLS certificate used for SSL when a
     custom subdomain is provided.
    :vartype certificate_id: str
    :ivar custom_domain: The fully qualified domain name (FQDN) of the custom subdomain used with
     the CDN endpoint.
    :vartype custom_domain: str
    """

    _attribute_map = {
        'ttl': {'key': 'ttl', 'type': 'int'},
        'certificate_id': {'key': 'certificate_id', 'type': 'str'},
        'custom_domain': {'key': 'custom_domain', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        ttl: Optional[Union[int, "_models.UpdateEndpointTtl"]] = 3600,
        certificate_id: Optional[str] = None,
        custom_domain: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword ttl: The amount of time the content is cached by the CDN's edge servers in seconds.
         TTL must be one of 60, 600, 3600, 86400, or 604800. Defaults to 3600 (one hour) when excluded.
         Known values are: 60, 600, 3600, 86400, 604800. Default value: "3600".
        :paramtype ttl: int or ~digital_ocean_api.models.UpdateEndpointTtl
        :keyword certificate_id: The ID of a DigitalOcean managed TLS certificate used for SSL when a
         custom subdomain is provided.
        :paramtype certificate_id: str
        :keyword custom_domain: The fully qualified domain name (FQDN) of the custom subdomain used
         with the CDN endpoint.
        :paramtype custom_domain: str
        """
        super(UpdateEndpoint, self).__init__(**kwargs)
        self.ttl = ttl
        self.certificate_id = certificate_id
        self.custom_domain = custom_domain


class UpdateRegistry(msrest.serialization.Model):
    """UpdateRegistry.

    :ivar cancel: A boolean value indicating that the garbage collection should be cancelled.
    :vartype cancel: bool
    """

    _attribute_map = {
        'cancel': {'key': 'cancel', 'type': 'bool'},
    }

    def __init__(
        self,
        *,
        cancel: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword cancel: A boolean value indicating that the garbage collection should be cancelled.
        :paramtype cancel: bool
        """
        super(UpdateRegistry, self).__init__(**kwargs)
        self.cancel = cancel


class User(msrest.serialization.Model):
    """User.

    :ivar kubernetes_cluster_user:
    :vartype kubernetes_cluster_user: ~digital_ocean_api.models.UserKubernetesClusterUser
    """

    _attribute_map = {
        'kubernetes_cluster_user': {'key': 'kubernetes_cluster_user', 'type': 'UserKubernetesClusterUser'},
    }

    def __init__(
        self,
        *,
        kubernetes_cluster_user: Optional["_models.UserKubernetesClusterUser"] = None,
        **kwargs
    ):
        """
        :keyword kubernetes_cluster_user:
        :paramtype kubernetes_cluster_user: ~digital_ocean_api.models.UserKubernetesClusterUser
        """
        super(User, self).__init__(**kwargs)
        self.kubernetes_cluster_user = kubernetes_cluster_user


class UserKubernetesClusterUser(msrest.serialization.Model):
    """UserKubernetesClusterUser.

    :ivar username: The username for the cluster admin user.
    :vartype username: str
    :ivar groups: A list of in-cluster groups that the user belongs to.
    :vartype groups: list[str]
    """

    _attribute_map = {
        'username': {'key': 'username', 'type': 'str'},
        'groups': {'key': 'groups', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        groups: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword username: The username for the cluster admin user.
        :paramtype username: str
        :keyword groups: A list of in-cluster groups that the user belongs to.
        :paramtype groups: list[str]
        """
        super(UserKubernetesClusterUser, self).__init__(**kwargs)
        self.username = username
        self.groups = groups


class ValidateRegistry(msrest.serialization.Model):
    """ValidateRegistry.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. A globally unique name for the container registry. Must be lowercase and
     be composed only of numbers, letters and ``-``\ , up to a limit of 63 characters.
    :vartype name: str
    """

    _validation = {
        'name': {'required': True, 'max_length': 63, 'min_length': 0, 'pattern': r'^[a-z0-9-]{1,63}$'},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: str,
        **kwargs
    ):
        """
        :keyword name: Required. A globally unique name for the container registry. Must be lowercase
         and be composed only of numbers, letters and ``-``\ , up to a limit of 63 characters.
        :paramtype name: str
        """
        super(ValidateRegistry, self).__init__(**kwargs)
        self.name = name


class VolumeAction(Action):
    """VolumeAction.

    :ivar id: A unique numeric ID that can be used to identify and reference an action.
    :vartype id: int
    :ivar status: The current status of the action. This can be "in-progress", "completed", or
     "errored". Known values are: "in-progress", "completed", "errored". Default value:
     "in-progress".
    :vartype status: str or ~digital_ocean_api.models.ActionStatus
    :ivar started_at: A time value given in ISO8601 combined date and time format that represents
     when the action was initiated.
    :vartype started_at: ~datetime.datetime
    :ivar completed_at: A time value given in ISO8601 combined date and time format that represents
     when the action was completed.
    :vartype completed_at: ~datetime.datetime
    :ivar resource_type: The type of resource that the action is associated with.
    :vartype resource_type: str
    :ivar region:
    :vartype region: ~digital_ocean_api.models.Region
    :ivar region_slug: Any object.
    :vartype region_slug: any
    :ivar type: This is the type of action that the object represents. For example, this could be
     "attach_volume" to represent the state of a volume attach action.
    :vartype type: str
    :ivar resource_id:
    :vartype resource_id: int
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'status': {'key': 'status', 'type': 'str'},
        'started_at': {'key': 'started_at', 'type': 'iso-8601'},
        'completed_at': {'key': 'completed_at', 'type': 'iso-8601'},
        'resource_type': {'key': 'resource_type', 'type': 'str'},
        'region': {'key': 'region', 'type': 'Region'},
        'region_slug': {'key': 'region_slug', 'type': 'object'},
        'type': {'key': 'type', 'type': 'str'},
        'resource_id': {'key': 'resource_id', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        status: Optional[Union[str, "_models.ActionStatus"]] = "in-progress",
        started_at: Optional[datetime.datetime] = None,
        completed_at: Optional[datetime.datetime] = None,
        resource_type: Optional[str] = None,
        region: Optional["_models.Region"] = None,
        region_slug: Optional[Any] = None,
        type: Optional[str] = None,
        resource_id: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword id: A unique numeric ID that can be used to identify and reference an action.
        :paramtype id: int
        :keyword status: The current status of the action. This can be "in-progress", "completed", or
         "errored". Known values are: "in-progress", "completed", "errored". Default value:
         "in-progress".
        :paramtype status: str or ~digital_ocean_api.models.ActionStatus
        :keyword started_at: A time value given in ISO8601 combined date and time format that
         represents when the action was initiated.
        :paramtype started_at: ~datetime.datetime
        :keyword completed_at: A time value given in ISO8601 combined date and time format that
         represents when the action was completed.
        :paramtype completed_at: ~datetime.datetime
        :keyword resource_type: The type of resource that the action is associated with.
        :paramtype resource_type: str
        :keyword region:
        :paramtype region: ~digital_ocean_api.models.Region
        :keyword region_slug: Any object.
        :paramtype region_slug: any
        :keyword type: This is the type of action that the object represents. For example, this could
         be "attach_volume" to represent the state of a volume attach action.
        :paramtype type: str
        :keyword resource_id:
        :paramtype resource_id: int
        """
        super(VolumeAction, self).__init__(id=id, status=status, started_at=started_at, completed_at=completed_at, resource_type=resource_type, region=region, region_slug=region_slug, **kwargs)
        self.type = type
        self.resource_id = resource_id


class VolumeActionPostBase(msrest.serialization.Model):
    """VolumeActionPostBase.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The volume action to initiate. Known values are: "attach", "detach",
     "resize".
    :vartype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.VolumeActionPostBaseType"],
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The volume action to initiate. Known values are: "attach", "detach",
         "resize".
        :paramtype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        """
        super(VolumeActionPostBase, self).__init__(**kwargs)
        self.type = type
        self.region = region


class VolumeActionPostAttach(VolumeActionPostBase):
    """VolumeActionPostAttach.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The volume action to initiate. Known values are: "attach", "detach",
     "resize".
    :vartype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar droplet_id: Required. The unique identifier for the Droplet the volume will be attached
     or detached from.
    :vartype droplet_id: int
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    """

    _validation = {
        'type': {'required': True},
        'droplet_id': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'droplet_id': {'key': 'droplet_id', 'type': 'int'},
        'tags': {'key': 'tags', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.VolumeActionPostBaseType"],
        droplet_id: int,
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        tags: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The volume action to initiate. Known values are: "attach", "detach",
         "resize".
        :paramtype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword droplet_id: Required. The unique identifier for the Droplet the volume will be
         attached or detached from.
        :paramtype droplet_id: int
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        """
        super(VolumeActionPostAttach, self).__init__(type=type, region=region, **kwargs)
        self.droplet_id = droplet_id
        self.tags = tags


class VolumeActionPostDetach(VolumeActionPostBase):
    """VolumeActionPostDetach.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The volume action to initiate. Known values are: "attach", "detach",
     "resize".
    :vartype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar droplet_id: Required. The unique identifier for the Droplet the volume will be attached
     or detached from.
    :vartype droplet_id: int
    """

    _validation = {
        'type': {'required': True},
        'droplet_id': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'droplet_id': {'key': 'droplet_id', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.VolumeActionPostBaseType"],
        droplet_id: int,
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The volume action to initiate. Known values are: "attach", "detach",
         "resize".
        :paramtype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword droplet_id: Required. The unique identifier for the Droplet the volume will be
         attached or detached from.
        :paramtype droplet_id: int
        """
        super(VolumeActionPostDetach, self).__init__(type=type, region=region, **kwargs)
        self.droplet_id = droplet_id


class VolumeActionPostResize(VolumeActionPostBase):
    """VolumeActionPostResize.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The volume action to initiate. Known values are: "attach", "detach",
     "resize".
    :vartype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
    :ivar region: The slug identifier for the region where the resource will initially be
     available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
     "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
    :vartype region: str or ~digital_ocean_api.models.RegionSlug
    :ivar size_gigabytes: Required. The new size of the block storage volume in GiB (1024^3).
    :vartype size_gigabytes: int
    """

    _validation = {
        'type': {'required': True},
        'size_gigabytes': {'required': True, 'maximum': 16384},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'region': {'key': 'region', 'type': 'str'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.VolumeActionPostBaseType"],
        size_gigabytes: int,
        region: Optional[Union[str, "_models.RegionSlug"]] = None,
        **kwargs
    ):
        """
        :keyword type: Required. The volume action to initiate. Known values are: "attach", "detach",
         "resize".
        :paramtype type: str or ~digital_ocean_api.models.VolumeActionPostBaseType
        :keyword region: The slug identifier for the region where the resource will initially be
         available. Known values are: "ams1", "ams2", "ams3", "blr1", "fra1", "lon1", "nyc1", "nyc2",
         "nyc3", "sfo1", "sfo2", "sfo3", "sgp1", "tor1".
        :paramtype region: str or ~digital_ocean_api.models.RegionSlug
        :keyword size_gigabytes: Required. The new size of the block storage volume in GiB (1024^3).
        :paramtype size_gigabytes: int
        """
        super(VolumeActionPostResize, self).__init__(type=type, region=region, **kwargs)
        self.size_gigabytes = size_gigabytes


class VolumeFull(VolumeBase):
    """VolumeFull.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: The unique identifier for the block storage volume.
    :vartype id: str
    :ivar droplet_ids: An array containing the IDs of the Droplets the volume is attached to. Note
     that at this time, a volume can only be attached to a single Droplet.
    :vartype droplet_ids: list[int]
    :ivar name: A human-readable name for the block storage volume. Must be lowercase and be
     composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
     with a letter.
    :vartype name: str
    :ivar description: An optional free-form text field to describe a block storage volume.
    :vartype description: str
    :ivar size_gigabytes: The size of the block storage volume in GiB (1024^3).
    :vartype size_gigabytes: int
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the block storage volume was created.
    :vartype created_at: str
    :ivar tags: A set of tags. A flat array of tag names as strings to be applied to the resource.
     Tag names may be for either existing or new tags.
    :vartype tags: list[str]
    :ivar region:
    :vartype region: ~digital_ocean_api.models.VolumeFullRegion
    :ivar filesystem_type: The type of filesystem currently in-use on the volume.
    :vartype filesystem_type: str
    :ivar filesystem_label: The label currently applied to the filesystem.
    :vartype filesystem_label: str
    """

    _validation = {
        'id': {'readonly': True},
        'droplet_ids': {'readonly': True},
        'created_at': {'readonly': True},
        'region': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'droplet_ids': {'key': 'droplet_ids', 'type': '[int]'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'size_gigabytes': {'key': 'size_gigabytes', 'type': 'int'},
        'created_at': {'key': 'created_at', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '[str]'},
        'region': {'key': 'region', 'type': 'VolumeFullRegion'},
        'filesystem_type': {'key': 'filesystem_type', 'type': 'str'},
        'filesystem_label': {'key': 'filesystem_label', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        size_gigabytes: Optional[int] = None,
        tags: Optional[List[str]] = None,
        filesystem_type: Optional[str] = None,
        filesystem_label: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: A human-readable name for the block storage volume. Must be lowercase and be
         composed only of numbers, letters and "-", up to a limit of 64 characters. The name must begin
         with a letter.
        :paramtype name: str
        :keyword description: An optional free-form text field to describe a block storage volume.
        :paramtype description: str
        :keyword size_gigabytes: The size of the block storage volume in GiB (1024^3).
        :paramtype size_gigabytes: int
        :keyword tags: A set of tags. A flat array of tag names as strings to be applied to the
         resource. Tag names may be for either existing or new tags.
        :paramtype tags: list[str]
        :keyword filesystem_type: The type of filesystem currently in-use on the volume.
        :paramtype filesystem_type: str
        :keyword filesystem_label: The label currently applied to the filesystem.
        :paramtype filesystem_label: str
        """
        super(VolumeFull, self).__init__(name=name, description=description, size_gigabytes=size_gigabytes, tags=tags, **kwargs)
        self.region = None
        self.filesystem_type = filesystem_type
        self.filesystem_label = filesystem_label


class VolumeFullRegion(Region):
    """VolumeFullRegion.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The display name of the region.  This will be a full name that is used in
     the control panel and other interfaces.
    :vartype name: str
    :ivar slug: Required. A human-readable string that is used as a unique identifier for each
     region.
    :vartype slug: str
    :ivar features: Required. This attribute is set to an array which contains features available
     in this region.
    :vartype features: any
    :ivar available: Required. This is a boolean value that represents whether new Droplets can be
     created in this region.
    :vartype available: bool
    :ivar sizes: Required. This attribute is set to an array which contains the identifying slugs
     for the sizes available in this region.
    :vartype sizes: any
    """

    _validation = {
        'name': {'required': True},
        'slug': {'required': True},
        'features': {'required': True},
        'available': {'required': True},
        'sizes': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'slug': {'key': 'slug', 'type': 'str'},
        'features': {'key': 'features', 'type': 'object'},
        'available': {'key': 'available', 'type': 'bool'},
        'sizes': {'key': 'sizes', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        name: str,
        slug: str,
        features: Any,
        available: bool,
        sizes: Any,
        **kwargs
    ):
        """
        :keyword name: Required. The display name of the region.  This will be a full name that is used
         in the control panel and other interfaces.
        :paramtype name: str
        :keyword slug: Required. A human-readable string that is used as a unique identifier for each
         region.
        :paramtype slug: str
        :keyword features: Required. This attribute is set to an array which contains features
         available in this region.
        :paramtype features: any
        :keyword available: Required. This is a boolean value that represents whether new Droplets can
         be created in this region.
        :paramtype available: bool
        :keyword sizes: Required. This attribute is set to an array which contains the identifying
         slugs for the sizes available in this region.
        :paramtype sizes: any
        """
        super(VolumeFullRegion, self).__init__(name=name, slug=slug, features=features, available=available, sizes=sizes, **kwargs)


class VpcBase(msrest.serialization.Model):
    """VpcBase.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A unique ID that can be used to identify and reference the VPC.
    :vartype id: str
    :ivar urn: The uniform resource name (URN) for the resource in the format
     do:resource_type:resource_id.
    :vartype urn: str
    :ivar created_at: A time value given in ISO8601 combined date and time format.
    :vartype created_at: ~datetime.datetime
    """

    _validation = {
        'id': {'readonly': True},
        'urn': {'pattern': r'^do:(dbaas|domain|droplet|floatingip|loadbalancer|space|volume|kubernetes|vpc):.*'},
        'created_at': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'urn': {'key': 'urn', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        *,
        urn: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword urn: The uniform resource name (URN) for the resource in the format
         do:resource_type:resource_id.
        :paramtype urn: str
        """
        super(VpcBase, self).__init__(**kwargs)
        self.id = None
        self.urn = urn
        self.created_at = None


class Vpc(VpcUpdatable, VpcCreate, VpcDefault, VpcBase):
    """Vpc.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A unique ID that can be used to identify and reference the VPC.
    :vartype id: str
    :ivar urn: The uniform resource name (URN) for the resource in the format
     do:resource_type:resource_id.
    :vartype urn: str
    :ivar created_at: A time value given in ISO8601 combined date and time format.
    :vartype created_at: ~datetime.datetime
    :ivar default: A boolean value indicating whether or not the VPC is the default network for the
     region. All applicable resources are placed into the default VPC network unless otherwise
     specified during their creation. The ``default`` field cannot be unset from ``true``. If you
     want to set a new default VPC network, update the ``default`` field of another VPC network in
     the same region. The previous network's ``default`` field will be set to ``false`` when a new
     default VPC has been defined.
    :vartype default: bool
    :ivar region: The slug identifier for the region where the VPC will be created.
    :vartype region: str
    :ivar ip_range: The range of IP addresses in the VPC in CIDR notation. Network ranges cannot
     overlap with other networks in the same account and must be in range of private addresses as
     defined in RFC1918. It may not be smaller than ``/28`` nor larger than ``/16``. If no IP range
     is specified, a ``/20`` network range is generated that won't conflict with other VPC networks
     in your account.
    :vartype ip_range: str
    :ivar name: The name of the VPC. Must be unique and may only contain alphanumeric characters,
     dashes, and periods.
    :vartype name: str
    :ivar description: A free-form text field for describing the VPC's purpose. It may be a maximum
     of 255 characters.
    :vartype description: str
    """

    _validation = {
        'id': {'readonly': True},
        'urn': {'pattern': r'^do:(dbaas|domain|droplet|floatingip|loadbalancer|space|volume|kubernetes|vpc):.*'},
        'created_at': {'readonly': True},
        'name': {'pattern': r'^[a-zA-Z0-9\-\.]+$'},
        'description': {'max_length': 255, 'min_length': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'urn': {'key': 'urn', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'iso-8601'},
        'default': {'key': 'default', 'type': 'bool'},
        'region': {'key': 'region', 'type': 'str'},
        'ip_range': {'key': 'ip_range', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        urn: Optional[str] = None,
        default: Optional[bool] = None,
        region: Optional[str] = None,
        ip_range: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword urn: The uniform resource name (URN) for the resource in the format
         do:resource_type:resource_id.
        :paramtype urn: str
        :keyword default: A boolean value indicating whether or not the VPC is the default network for
         the region. All applicable resources are placed into the default VPC network unless otherwise
         specified during their creation. The ``default`` field cannot be unset from ``true``. If you
         want to set a new default VPC network, update the ``default`` field of another VPC network in
         the same region. The previous network's ``default`` field will be set to ``false`` when a new
         default VPC has been defined.
        :paramtype default: bool
        :keyword region: The slug identifier for the region where the VPC will be created.
        :paramtype region: str
        :keyword ip_range: The range of IP addresses in the VPC in CIDR notation. Network ranges cannot
         overlap with other networks in the same account and must be in range of private addresses as
         defined in RFC1918. It may not be smaller than ``/28`` nor larger than ``/16``. If no IP range
         is specified, a ``/20`` network range is generated that won't conflict with other VPC networks
         in your account.
        :paramtype ip_range: str
        :keyword name: The name of the VPC. Must be unique and may only contain alphanumeric
         characters, dashes, and periods.
        :paramtype name: str
        :keyword description: A free-form text field for describing the VPC's purpose. It may be a
         maximum of 255 characters.
        :paramtype description: str
        """
        super(Vpc, self).__init__(name=name, description=description, region=region, ip_range=ip_range, default=default, urn=urn, **kwargs)
        self.id = None
        self.urn = urn
        self.created_at = None
        self.default = default
        self.region = region
        self.ip_range = ip_range
        self.name = name
        self.description = description


class VpcMember(msrest.serialization.Model):
    """VpcMember.

    :ivar name: The name of the resource.
    :vartype name: str
    :ivar urn: The uniform resource name (URN) for the resource in the format
     do:resource_type:resource_id.
    :vartype urn: str
    :ivar created_at: A time value given in ISO8601 combined date and time format that represents
     when the resource was created.
    :vartype created_at: str
    """

    _validation = {
        'urn': {'pattern': r'^do:(dbaas|domain|droplet|floatingip|loadbalancer|space|volume|kubernetes|vpc):.*'},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'urn': {'key': 'urn', 'type': 'str'},
        'created_at': {'key': 'created_at', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        urn: Optional[str] = None,
        created_at: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword name: The name of the resource.
        :paramtype name: str
        :keyword urn: The uniform resource name (URN) for the resource in the format
         do:resource_type:resource_id.
        :paramtype urn: str
        :keyword created_at: A time value given in ISO8601 combined date and time format that
         represents when the resource was created.
        :paramtype created_at: str
        """
        super(VpcMember, self).__init__(**kwargs)
        self.name = name
        self.urn = urn
        self.created_at = created_at
